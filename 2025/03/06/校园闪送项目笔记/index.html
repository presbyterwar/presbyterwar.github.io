

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="presbyter">
  <meta name="keywords" content="">
  
    <meta name="description" content="项目：校园内送项目介绍：校园闪送项目，是专为餐饮企业打造的一款软件产品，涵盖 “系统管理后台” 与 “小程序端应用” 两大板块。系统管理后台主要供餐饮企业内部员工操作，支持对餐厅的分类、菜品、套餐、订单以及员工等信息进行管理与维护。同时，能对餐厅各类数据展开统计，还具备来单语音播报功能。在技术层面，该项目采用了 Spring Boot、Spring MVC、MyBatis 等框架，部分功能还借助">
<meta property="og:type" content="article">
<meta property="og:title" content="校园闪送项目笔记">
<meta property="og:url" content="http://example.com/2025/03/06/%E6%A0%A1%E5%9B%AD%E9%97%AA%E9%80%81%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="项目：校园内送项目介绍：校园闪送项目，是专为餐饮企业打造的一款软件产品，涵盖 “系统管理后台” 与 “小程序端应用” 两大板块。系统管理后台主要供餐饮企业内部员工操作，支持对餐厅的分类、菜品、套餐、订单以及员工等信息进行管理与维护。同时，能对餐厅各类数据展开统计，还具备来单语音播报功能。在技术层面，该项目采用了 Spring Boot、Spring MVC、MyBatis 等框架，部分功能还借助">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/2025/03/06/%E6%A0%A1%E5%9B%AD%E9%97%AA%E9%80%81%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/%E9%A1%B9%E7%9B%AE%E6%A8%A1%E5%9D%97.png">
<meta property="article:published_time" content="2025-03-06T13:26:17.000Z">
<meta property="article:modified_time" content="2025-03-25T09:34:42.170Z">
<meta property="article:author" content="presbyter">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://example.com/2025/03/06/%E6%A0%A1%E5%9B%AD%E9%97%AA%E9%80%81%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/%E9%A1%B9%E7%9B%AE%E6%A8%A1%E5%9D%97.png">
  
  
  
  <title>校园闪送项目笔记 - Hexo</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 5.4.1"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Fluid</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="校园闪送项目笔记"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-03-06 21:26" pubdate>
          2025年3月6日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          11k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          91 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">校园闪送项目笔记</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="项目：校园内送"><a href="#项目：校园内送" class="headerlink" title="项目：校园内送"></a>项目：校园内送</h1><p><strong>项目介绍</strong>：<br><br>校园闪送项目，是专为餐饮企业打造的一款软件产品，涵盖 “系统管理后台” 与 “小程序端应用” 两大板块。<br>系统管理后台主要供餐饮企业内部员工操作，支持对餐厅的分类、菜品、套餐、订单以及员工等信息进行管理与维护。同时，能对餐厅各类数据展开统计，还具备来单语音播报功能。在技术层面，该项目采用了 Spring Boot、Spring MVC、MyBatis 等框架，部分功能还借助 Redis 实现分布式缓存 ，并运用 Springdoc 生成 API 接口文档，整体是单体架构模式。<br>小程序端则是面向消费者，消费者可通过它在线浏览菜品、将心仪菜品添加至购物车、完成下单支付流程，还能进行催单操作。</p>
<p>项目的痛点：单体项目所有功能模块都耦合在一个项目中，一处代码的修改可能影响其他功能。并且，单体架构在应对高并发场景时，性能表现欠佳。</p>
<p><img src="/2025/03/06/%E6%A0%A1%E5%9B%AD%E9%97%AA%E9%80%81%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/%E9%A1%B9%E7%9B%AE%E6%A8%A1%E5%9D%97.png" srcset="/img/loading.gif" lazyload title="项目模块"></p>
<hr>
<h2 id="1-Redis缓存高频数据与SpringCache优化"><a href="#1-Redis缓存高频数据与SpringCache优化" class="headerlink" title="1. Redis缓存高频数据与SpringCache优化"></a><strong>1. Redis缓存高频数据与SpringCache优化</strong></h2><h3 id="场景描述"><a href="#场景描述" class="headerlink" title="场景描述"></a><strong>场景描述</strong></h3><p><strong>校园闪送</strong> 是一款为餐饮企业定制的 B&#x2F;S 架构系统，包含管理端（供商家管理菜品、订单、数据统计）和用户端（微信小程序点餐、支付）。系统的主要功能包括：</p>
<ol>
<li><strong>商家管理端</strong>：<ul>
<li>管理菜品信息（添加、删除、修改菜品）。</li>
<li>查看订单列表和订单详情。</li>
<li>数据统计和报表生成。</li>
</ul>
</li>
<li><strong>用户端</strong>：<ul>
<li>浏览菜品分类和菜品详情。</li>
<li>下单、支付、催单等操作。</li>
<li>查看订单状态。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="为什么使用-Redis-缓存？"><a href="#为什么使用-Redis-缓存？" class="headerlink" title="为什么使用 Redis 缓存？"></a><strong>为什么使用 Redis 缓存？</strong></h3><h4 id="1-高频数据访问"><a href="#1-高频数据访问" class="headerlink" title="1. 高频数据访问"></a><strong>1. 高频数据访问</strong></h4><p>在校园闪送系统中，某些数据会被频繁访问，例如：</p>
<ul>
<li><strong>菜品分类</strong>：用户在点餐时需要频繁查询菜品分类。</li>
<li><strong>热门菜品</strong>：用户经常访问的菜品信息。</li>
<li><strong>订单状态</strong>：用户和商家需要实时查看订单的最新状态。</li>
</ul>
<p>这些数据的查询频率很高，如果每次都从数据库中读取，会导致数据库压力过大，响应速度变慢。通过将这些高频数据缓存到 Redis 中，可以显著减少数据库的访问次数，提升系统的响应速度。</p>
<h4 id="2-缓存穿透、击穿和雪崩问题"><a href="#2-缓存穿透、击穿和雪崩问题" class="headerlink" title="2. 缓存穿透、击穿和雪崩问题"></a><strong>2. 缓存穿透、击穿和雪崩问题</strong></h4><p>在实际应用中，缓存可能会面临以下问题：</p>
<ul>
<li><strong>缓存穿透</strong>：查询不存在的数据，导致数据库被频繁访问。</li>
<li><strong>缓存击穿</strong>：热点数据的缓存失效时，大量请求直接冲击数据库。</li>
<li><strong>缓存雪崩</strong>：大量缓存同时失效，导致数据库压力过大。</li>
</ul>
<p>通过使用 Redis 缓存，并结合 SpringCache 的注解，可以有效解决这些问题，确保系统的稳定性。</p>
<h4 id="3-提升系统性能"><a href="#3-提升系统性能" class="headerlink" title="3. 提升系统性能"></a><strong>3. 提升系统性能</strong></h4><p>Redis 是一种高性能的内存数据库，读写速度非常快（通常在微秒级别）。通过将高频数据缓存到 Redis 中，可以显著提升系统的读取速度，减少数据库的负载，从而提升整体性能。</p>
<h4 id="4-分布式系统的需求"><a href="#4-分布式系统的需求" class="headerlink" title="4. 分布式系统的需求"></a><strong>4. 分布式系统的需求</strong></h4><p>在分布式系统中，多个服务实例可能需要共享某些数据。Redis 作为一个分布式缓存系统，可以方便地实现数据的共享和同步，确保系统的一致性。</p>
<hr>
<h3 id="具体场景分析"><a href="#具体场景分析" class="headerlink" title="具体场景分析"></a><strong>具体场景分析</strong></h3><h4 id="场景-1：菜品分类和热门菜品的缓存"><a href="#场景-1：菜品分类和热门菜品的缓存" class="headerlink" title="场景 1：菜品分类和热门菜品的缓存"></a><strong>场景 1：菜品分类和热门菜品的缓存</strong></h4><ul>
<li><strong>问题</strong>：用户在点餐时需要频繁查询菜品分类和热门菜品。如果每次都从数据库中读取，会导致数据库压力过大。</li>
<li><strong>解决方案</strong>：<ul>
<li>使用 <strong>Redis</strong> 缓存菜品分类和热门菜品数据。</li>
<li>通过 <strong>SpringCache</strong> 的 <code>@Cacheable</code> 注解，将查询结果缓存到 Redis 中。</li>
<li>设置合理的缓存过期时间（如 5 分钟），确保数据的时效性。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Cacheable(value = &quot;dish-categories&quot;, key = &quot;#root.methodName&quot;)</span><br><span class="hljs-keyword">public</span> List&lt;DishCategory&gt; <span class="hljs-title function_">getDishCategories</span><span class="hljs-params">()</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;Fetching dish categories from database...&quot;</span>);<br>    <span class="hljs-keyword">return</span> dishRepository.findAllCategories();<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Cacheable(value = &quot;hot-dishes&quot;, key = &quot;#categoryId&quot;)</span><br><span class="hljs-keyword">public</span> List&lt;Dish&gt; <span class="hljs-title function_">getHotDishesByCategory</span><span class="hljs-params">(<span class="hljs-type">int</span> categoryId)</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;Fetching hot dishes from database...&quot;</span>);<br>    <span class="hljs-keyword">return</span> dishRepository.findHotDishesByCategory(categoryId);<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="场景-2：订单状态的缓存"><a href="#场景-2：订单状态的缓存" class="headerlink" title="场景 2：订单状态的缓存"></a><strong>场景 2：订单状态的缓存</strong></h4><ul>
<li><strong>问题</strong>：用户和商家需要实时查看订单的最新状态。订单状态的查询频率很高，如果每次都从数据库中读取，会导致数据库压力过大。</li>
<li><strong>解决方案</strong>：<ul>
<li>使用 <strong>Redis</strong> 缓存订单状态。</li>
<li>在订单状态更新时，同步更新缓存，确保数据的一致性。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Cacheable(value = &quot;order-status&quot;, key = &quot;#orderId&quot;)</span><br><span class="hljs-keyword">public</span> OrderStatus <span class="hljs-title function_">getOrderStatus</span><span class="hljs-params">(<span class="hljs-type">int</span> orderId)</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;Fetching order status from database...&quot;</span>);<br>    <span class="hljs-keyword">return</span> orderRepository.findOrderStatus(orderId);<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@CachePut(value = &quot;order-status&quot;, key = &quot;#order.id&quot;)</span><br><span class="hljs-keyword">public</span> OrderStatus <span class="hljs-title function_">updateOrderStatus</span><span class="hljs-params">(Order order)</span> &#123;<br>    orderRepository.updateOrderStatus(order);<br>    <span class="hljs-keyword">return</span> order.getStatus();<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="场景-3：缓存穿透、击穿和雪崩的解决方案"><a href="#场景-3：缓存穿透、击穿和雪崩的解决方案" class="headerlink" title="场景 3：缓存穿透、击穿和雪崩的解决方案"></a><strong>场景 3：缓存穿透、击穿和雪崩的解决方案</strong></h4><ul>
<li><strong>缓存穿透</strong>：对于查询结果为空的数据，也存储一个空对象到缓存中，设置较短的过期时间（如 1 分钟）。</li>
<li><strong>缓存击穿</strong>：使用布隆过滤器（Bloom Filter）预判数据是否存在，避免查询不存在的数据。</li>
<li><strong>缓存雪崩</strong>：为缓存设置随机的过期时间，避免大量缓存同时失效；使用本地缓存（如 Caffeine）作为二级缓存，缓解 Redis 压力。</li>
</ul>
<hr>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><p>在 <strong>校园闪送</strong> 项目中，使用 <strong>Redis</strong> 缓存高频数据并结合 <strong>SpringCache</strong> 进行优化的主要原因包括：</p>
<ol>
<li><strong>高频数据访问</strong>：减少数据库压力，提升系统响应速度。</li>
<li><strong>解决缓存问题</strong>：有效应对缓存穿透、击穿和雪崩问题，确保系统稳定性。</li>
<li><strong>提升系统性能</strong>：利用 Redis 的高性能读写能力，优化系统性能。</li>
<li><strong>分布式系统需求</strong>：实现数据共享和同步，确保系统一致性。</li>
</ol>
<hr>
<h3 id="1-引入-Redis-和-SpringCache-依赖"><a href="#1-引入-Redis-和-SpringCache-依赖" class="headerlink" title="1. 引入 Redis 和 SpringCache 依赖"></a><strong>1. 引入 Redis 和 SpringCache 依赖</strong></h3><p>在 Spring Boot 项目中，需要引入 Redis 和 SpringCache 的相关依赖。通常使用 <code>spring-boot-starter-data-redis</code> 和 <code>spring-context-support</code>。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-cache<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>

<hr>
<h3 id="2-配置-Redis-连接"><a href="#2-配置-Redis-连接" class="headerlink" title="2. 配置 Redis 连接"></a><strong>2. 配置 Redis 连接</strong></h3><p>在 <code>application.properties</code> 或 <code>application.yml</code> 文件中配置 Redis 的连接信息。</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># Redis 配置</span><br><span class="hljs-attr">spring.redis.host</span>=<span class="hljs-string">localhost</span><br><span class="hljs-attr">spring.redis.port</span>=<span class="hljs-string">6379</span><br><span class="hljs-attr">spring.redis.password</span>=<span class="hljs-string">your_password</span><br><span class="hljs-attr">spring.redis.database</span>=<span class="hljs-string">0</span><br></code></pre></td></tr></table></figure>

<hr>
<h3 id="3-配置-SpringCache"><a href="#3-配置-SpringCache" class="headerlink" title="3. 配置 SpringCache"></a><strong>3. 配置 SpringCache</strong></h3><p>在 Spring Boot 项目中启用缓存支持，并配置缓存管理器。</p>
<h4 id="1-启用缓存支持"><a href="#1-启用缓存支持" class="headerlink" title="(1) 启用缓存支持"></a><strong>(1) 启用缓存支持</strong></h4><p>在主类或配置类上添加 <code>@EnableCaching</code> 注解，启用 SpringCache 功能。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-meta">@EnableCaching</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CampusFlashDeliveryApplication</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        SpringApplication.run(CampusFlashDeliveryApplication.class, args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="2-配置缓存管理器"><a href="#2-配置缓存管理器" class="headerlink" title="(2) 配置缓存管理器"></a><strong>(2) 配置缓存管理器</strong></h4><p>配置 Redis 作为缓存存储，定义缓存管理器和序列化策略。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CacheConfig</span> &#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> RedisCacheManager <span class="hljs-title function_">cacheManager</span><span class="hljs-params">(RedisConnectionFactory redisConnectionFactory)</span> &#123;<br>        <span class="hljs-type">RedisCacheConfiguration</span> <span class="hljs-variable">config</span> <span class="hljs-operator">=</span> RedisCacheConfiguration.defaultCacheConfig()<br>                .entryTtl(Duration.ofMinutes(<span class="hljs-number">5</span>)) <span class="hljs-comment">// 设置默认缓存过期时间</span><br>                .disableCachingNullValues() <span class="hljs-comment">// 不缓存空值</span><br>                .serializeKeysWith(RedisSerializationContext.SerializationPair.string()) <span class="hljs-comment">// 键的序列化方式</span><br>                .serializeValuesWith(RedisSerializationContext.SerializationPair.json()); <span class="hljs-comment">// 值的序列化方式</span><br><br>        <span class="hljs-keyword">return</span> RedisCacheManager.builder(redisConnectionFactory)<br>                .cacheDefaults(config)<br>                .build();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h3 id="4-使用-SpringCache-注解缓存高频数据"><a href="#4-使用-SpringCache-注解缓存高频数据" class="headerlink" title="4. 使用 SpringCache 注解缓存高频数据"></a><strong>4. 使用 SpringCache 注解缓存高频数据</strong></h3><p>在业务逻辑中，使用 SpringCache 提供的注解（如 <code>@Cacheable</code>、<code>@CachePut</code>、<code>@CacheEvict</code>）来缓存和管理数据。</p>
<h4 id="1-缓存菜品分类数据"><a href="#1-缓存菜品分类数据" class="headerlink" title="(1) 缓存菜品分类数据"></a><strong>(1) 缓存菜品分类数据</strong></h4><p>假设有一个 <code>DishService</code>，用于获取菜品分类数据。可以使用 <code>@Cacheable</code> 注解将结果缓存到 Redis 中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DishService</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> DishRepository dishRepository;<br><br>    <span class="hljs-meta">@Cacheable(value = &quot;dish-categories&quot;, key = &quot;#root.methodName&quot;)</span><br>    <span class="hljs-keyword">public</span> List&lt;DishCategory&gt; <span class="hljs-title function_">getDishCategories</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Fetching dish categories from database...&quot;</span>);<br>        <span class="hljs-keyword">return</span> dishRepository.findAllCategories();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>**<code>value</code>**：指定缓存的名称（如 <code>dish-categories</code>）。</li>
<li>**<code>key</code>**：指定缓存的键（如方法名 <code>#root.methodName</code>）。</li>
<li>**<code>unless</code>**：可以指定条件，决定是否缓存结果（如 <code>unless = &quot;#result == null&quot;</code>）。</li>
</ul>
<h4 id="2-缓存热门菜品数据"><a href="#2-缓存热门菜品数据" class="headerlink" title="(2) 缓存热门菜品数据"></a><strong>(2) 缓存热门菜品数据</strong></h4><p>对于高频访问的热门菜品数据，也可以使用 <code>@Cacheable</code> 注解缓存。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Cacheable(value = &quot;hot-dishes&quot;, key = &quot;#categoryId&quot;)</span><br><span class="hljs-keyword">public</span> List&lt;Dish&gt; <span class="hljs-title function_">getHotDishesByCategory</span><span class="hljs-params">(<span class="hljs-type">int</span> categoryId)</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;Fetching hot dishes from database...&quot;</span>);<br>    <span class="hljs-keyword">return</span> dishRepository.findHotDishesByCategory(categoryId);<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h3 id="5-缓存穿透、击穿、雪崩的解决方案"><a href="#5-缓存穿透、击穿、雪崩的解决方案" class="headerlink" title="5. 缓存穿透、击穿、雪崩的解决方案"></a><strong>5. 缓存穿透、击穿、雪崩的解决方案</strong></h3><p>在实际应用中，需要解决缓存穿透、击穿和雪崩问题，确保系统的稳定性。</p>
<h4 id="1-缓存穿透"><a href="#1-缓存穿透" class="headerlink" title="(1) 缓存穿透"></a><strong>(1) 缓存穿透</strong></h4><ul>
<li><strong>问题</strong>：查询不存在的数据，导致数据库被频繁访问。</li>
<li><strong>解决方案</strong>：对于查询结果为空的数据，也存储一个空对象（如 <code>null</code> 或自定义的空对象）到缓存中，设置较短的过期时间（如 1 分钟）。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Cacheable(value = &quot;dish-details&quot;, key = &quot;#dishId&quot;, unless = &quot;#result == null&quot;)</span><br><span class="hljs-keyword">public</span> Dish <span class="hljs-title function_">getDishDetails</span><span class="hljs-params">(<span class="hljs-type">int</span> dishId)</span> &#123;<br>    <span class="hljs-keyword">return</span> dishRepository.findById(dishId).orElse(<span class="hljs-literal">null</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="2-缓存击穿"><a href="#2-缓存击穿" class="headerlink" title="(2) 缓存击穿"></a><strong>(2) 缓存击穿</strong></h4><ul>
<li><strong>问题</strong>：热点数据的缓存失效时，大量请求直接冲击数据库。</li>
<li><strong>解决方案</strong>：使用布隆过滤器（Bloom Filter）预判数据是否存在。如果数据不存在，则直接返回，避免查询数据库。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 布隆过滤器初始化</span><br>BloomFilter&lt;Integer&gt; bloomFilter = BloomFilter.create(<br>        Funnels.integerFunnel(), <span class="hljs-number">100000</span>, <span class="hljs-number">0.01</span>);<br><br><span class="hljs-comment">// 在数据加载时，将数据ID加入布隆过滤器</span><br>bloomFilter.put(dishId);<br></code></pre></td></tr></table></figure>

<p>在查询时，先通过布隆过滤器判断数据是否存在：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Dish <span class="hljs-title function_">getDishDetails</span><span class="hljs-params">(<span class="hljs-type">int</span> dishId)</span> &#123;<br>    <span class="hljs-keyword">if</span> (!bloomFilter.mightContain(dishId)) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>; <span class="hljs-comment">// 数据不存在</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> dishRepository.findById(dishId).orElse(<span class="hljs-literal">null</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="3-缓存雪崩"><a href="#3-缓存雪崩" class="headerlink" title="(3) 缓存雪崩"></a><strong>(3) 缓存雪崩</strong></h4><ul>
<li><strong>问题</strong>：大量缓存同时失效，导致数据库压力过大。</li>
<li><strong>解决方案</strong>：<ol>
<li><strong>设置不同的过期时间</strong>：为缓存设置随机的过期时间，避免大量缓存同时失效。</li>
<li><strong>本地缓存作为二级缓存</strong>：使用本地缓存（如 Caffeine）作为二级缓存，缓解 Redis 压力。</li>
<li><strong>使用互斥锁</strong>：在缓存失效时，通过互斥锁（如 Redisson 的分布式锁）确保只有一个线程加载数据。</li>
</ol>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Cacheable(value = &quot;dish-details&quot;, key = &quot;#dishId&quot;, sync = true)</span><br><span class="hljs-keyword">public</span> Dish <span class="hljs-title function_">getDishDetails</span><span class="hljs-params">(<span class="hljs-type">int</span> dishId)</span> &#123;<br>    <span class="hljs-keyword">return</span> dishRepository.findById(dishId).orElse(<span class="hljs-literal">null</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h3 id="6-缓存更新与失效"><a href="#6-缓存更新与失效" class="headerlink" title="6. 缓存更新与失效"></a><strong>6. 缓存更新与失效</strong></h3><p>在数据更新或删除时，需要同步更新缓存，确保缓存数据的一致性。</p>
<h4 id="1-缓存更新"><a href="#1-缓存更新" class="headerlink" title="(1) 缓存更新"></a><strong>(1) 缓存更新</strong></h4><p>使用 <code>@CachePut</code> 注解更新缓存。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@CachePut(value = &quot;dish-details&quot;, key = &quot;#dish.id&quot;)</span><br><span class="hljs-keyword">public</span> Dish <span class="hljs-title function_">updateDishDetails</span><span class="hljs-params">(Dish dish)</span> &#123;<br>    dishRepository.save(dish);<br>    <span class="hljs-keyword">return</span> dish;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="2-缓存失效"><a href="#2-缓存失效" class="headerlink" title="(2) 缓存失效"></a><strong>(2) 缓存失效</strong></h4><p>使用 <code>@CacheEvict</code> 注解删除缓存。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@CacheEvict(value = &quot;dish-details&quot;, key = &quot;#dishId&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deleteDish</span><span class="hljs-params">(<span class="hljs-type">int</span> dishId)</span> &#123;<br>    dishRepository.deleteById(dishId);<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h3 id="7-性能优化"><a href="#7-性能优化" class="headerlink" title="7. 性能优化"></a><strong>7. 性能优化</strong></h3><ul>
<li><strong>批量查询优化</strong>：对于批量查询，可以使用 Redis 的 <code>mget</code> 和 <code>mset</code> 命令批量读写缓存。</li>
<li><strong>缓存预热</strong>：在系统启动时，预加载高频数据到缓存中，减少首次访问的延迟。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@PostConstruct</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">preloadCache</span><span class="hljs-params">()</span> &#123;<br>    List&lt;DishCategory&gt; categories = dishService.getDishCategories();<br>    categories.forEach(category -&gt; &#123;<br>        dishService.getHotDishesByCategory(category.getId());<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a><strong>总结</strong></h3><p>通过以上步骤，实现了使用 <strong>Redis</strong> 缓存高频数据并结合 <strong>SpringCache</strong> 进行优化：</p>
<ol>
<li>引入 Redis 和 SpringCache 依赖，配置 Redis 连接。</li>
<li>启用缓存支持，配置缓存管理器。</li>
<li>使用 <code>@Cacheable</code> 注解缓存高频数据，减少数据库访问。</li>
<li>解决缓存穿透、击穿、雪崩问题，确保系统的稳定性。</li>
<li>在数据更新或删除时，同步更新缓存，确保数据一致性。</li>
<li>通过批量查询和缓存预热优化性能。</li>
</ol>
<p>这种实现方式显著提升了系统的响应速度和性能，同时减轻了数据库的压力。</p>
<hr>
<h2 id="2-JWT令牌校验与ThreadLocal用户上下文"><a href="#2-JWT令牌校验与ThreadLocal用户上下文" class="headerlink" title="2. JWT令牌校验与ThreadLocal用户上下文"></a><strong>2. JWT令牌校验与ThreadLocal用户上下文</strong></h2><h3 id="场景描述与实现：JWT令牌校验与ThreadLocal用户上下文"><a href="#场景描述与实现：JWT令牌校验与ThreadLocal用户上下文" class="headerlink" title="场景描述与实现：JWT令牌校验与ThreadLocal用户上下文"></a><strong>场景描述与实现：JWT令牌校验与ThreadLocal用户上下文</strong></h3><h4 id="1-场景描述"><a href="#1-场景描述" class="headerlink" title="1. 场景描述"></a><strong>1. 场景描述</strong></h4><p>在 <strong>校园闪送</strong> 项目中，系统需要实现用户认证和授权功能。具体场景如下：</p>
<ul>
<li><strong>用户登录</strong>：用户通过用户名和密码登录系统，登录成功后，后端生成一个 JWT 令牌并返回给客户端。</li>
<li><strong>请求验证</strong>：用户在后续请求中携带 JWT 令牌，后端通过拦截器验证令牌的有效性，确保用户已登录。</li>
<li><strong>用户信息传递</strong>：在多线程环境下，需要在不同的服务层和方法中获取当前登录用户的信息，而无需在每次请求中传递用户信息。</li>
</ul>
<h4 id="2-为什么使用-JWT-和-ThreadLocal"><a href="#2-为什么使用-JWT-和-ThreadLocal" class="headerlink" title="2. 为什么使用 JWT 和 ThreadLocal"></a><strong>2. 为什么使用 JWT 和 ThreadLocal</strong></h4><ul>
<li><strong>JWT 的优势</strong>：<ul>
<li><strong>无状态和可扩展性</strong>：JWT 令牌存储在客户端，服务器无需存储会话信息，适合分布式系统。</li>
<li><strong>安全性</strong>：JWT 通过签名机制保证令牌未被篡改。</li>
<li><strong>跨域支持</strong>：JWT 令牌可以轻松用于跨域请求。</li>
</ul>
</li>
<li><strong>ThreadLocal 的优势</strong>：<ul>
<li><strong>线程隔离</strong>：在多线程环境下，ThreadLocal 可以确保每个线程独立存储和访问用户信息。</li>
<li><strong>性能优化</strong>：避免在每次请求中重复查询数据库或传递用户信息。</li>
</ul>
</li>
</ul>
<h4 id="3-实现方法"><a href="#3-实现方法" class="headerlink" title="3. 实现方法"></a><strong>3. 实现方法</strong></h4><h5 id="1-JWT-令牌校验"><a href="#1-JWT-令牌校验" class="headerlink" title="(1) JWT 令牌校验"></a><strong>(1) JWT 令牌校验</strong></h5><p><strong>生成 JWT 令牌</strong>：<br>在用户登录时，后端生成 JWT 令牌并返回给客户端。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@PostMapping(&quot;/login&quot;)</span><br><span class="hljs-keyword">public</span> Result&lt;EmployeeLoginVO&gt; <span class="hljs-title function_">login</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> EmployeeLoginDTO employeeLoginDTO)</span> &#123;<br>    <span class="hljs-comment">// 验证用户信息...</span><br>    Map&lt;String, Object&gt; claims = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    claims.put(<span class="hljs-string">&quot;userId&quot;</span>, employee.getId());<br>    <span class="hljs-type">String</span> <span class="hljs-variable">token</span> <span class="hljs-operator">=</span> JwtUtil.createJWT(jwtProperties.getAdminSecretKey(), jwtProperties.getAdminTtl(), claims);<br>    <span class="hljs-keyword">return</span> Result.success(<span class="hljs-keyword">new</span> <span class="hljs-title class_">EmployeeLoginVO</span>(employee.getId(), employee.getName(), token));<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>校验 JWT 令牌</strong>：<br>通过拦截器验证请求中的 JWT 令牌。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JwtTokenInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">HandlerInterceptor</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> JwtProperties jwtProperties;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">preHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-keyword">if</span> (!(handler <span class="hljs-keyword">instanceof</span> HandlerMethod)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// 非Controller方法直接放行</span><br>        &#125;<br><br>        <span class="hljs-type">String</span> <span class="hljs-variable">token</span> <span class="hljs-operator">=</span> request.getHeader(jwtProperties.getAdminTokenName());<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">Claims</span> <span class="hljs-variable">claims</span> <span class="hljs-operator">=</span> JwtUtil.parseJWT(jwtProperties.getAdminSecretKey(), token);<br>            <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> Long.valueOf(claims.get(<span class="hljs-string">&quot;userId&quot;</span>).toString());<br>            <span class="hljs-comment">// 将用户ID存储到ThreadLocal中</span><br>            UserAuthContext.setUserLoginInfo(<span class="hljs-keyword">new</span> <span class="hljs-title class_">UserDO</span>(userId));<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="2-使用-ThreadLocal-存储用户上下文"><a href="#2-使用-ThreadLocal-存储用户上下文" class="headerlink" title="(2) 使用 ThreadLocal 存储用户上下文"></a><strong>(2) 使用 ThreadLocal 存储用户上下文</strong></h5><p><strong>创建用户上下文工具类</strong>：<br>使用 ThreadLocal 存储当前线程的用户信息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserAuthContext</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ThreadLocal&lt;UserDO&gt; userLoginInfo = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocal</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setUserLoginInfo</span><span class="hljs-params">(UserDO userInfo)</span> &#123;<br>        userLoginInfo.set(userInfo);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> UserDO <span class="hljs-title function_">getUserInfo</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> userLoginInfo.get();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">clear</span><span class="hljs-params">()</span> &#123;<br>        userLoginInfo.remove();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>拦截器中设置用户信息</strong>：<br>在拦截器中解析 JWT 令牌后，将用户信息存储到 ThreadLocal 中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JwtTokenInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">HandlerInterceptor</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">preHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">token</span> <span class="hljs-operator">=</span> request.getHeader(<span class="hljs-string">&quot;Authorization&quot;</span>);<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">Claims</span> <span class="hljs-variable">claims</span> <span class="hljs-operator">=</span> JwtUtil.parseJWT(token);<br>            <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> Long.valueOf(claims.get(<span class="hljs-string">&quot;userId&quot;</span>).toString());<br>            UserAuthContext.setUserLoginInfo(<span class="hljs-keyword">new</span> <span class="hljs-title class_">UserDO</span>(userId));<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>获取用户信息</strong>：<br>在业务逻辑中，通过 ThreadLocal 获取当前线程的用户信息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SomeService</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">someMethod</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">UserDO</span> <span class="hljs-variable">userInfo</span> <span class="hljs-operator">=</span> UserAuthContext.getUserInfo();<br>        <span class="hljs-comment">// 使用用户信息进行业务处理</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>清理 ThreadLocal</strong>：<br>在请求处理完成后，清理 ThreadLocal 中的数据，防止内存泄漏。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JwtTokenInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">HandlerInterceptor</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterCompletion</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        UserAuthContext.clear();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a><strong>总结</strong></h3><p>通过使用 <strong>JWT 令牌校验</strong> 和 <strong>ThreadLocal 用户上下文</strong>，可以实现以下目标：</p>
<ol>
<li><strong>用户认证和授权</strong>：通过 JWT 令牌验证用户身份，确保请求的合法性。</li>
<li><strong>线程隔离和性能优化</strong>：使用 ThreadLocal 在多线程环境下安全地存储和访问用户信息，避免重复查询数据库。</li>
<li><strong>跨域支持和无状态设计</strong>：JWT 令牌支持跨域请求，适合分布式系统。</li>
</ol>
<p>这种实现方式不仅提高了系统的安全性，还优化了性能，确保了线程安全。</p>
<hr>
<h2 id="3-WebSocket实时来单提醒"><a href="#3-WebSocket实时来单提醒" class="headerlink" title="3. WebSocket实时来单提醒"></a><strong>3. WebSocket实时来单提醒</strong></h2><h3 id="使用-WebSocket-实现长连接的场景与具体实现"><a href="#使用-WebSocket-实现长连接的场景与具体实现" class="headerlink" title="使用 WebSocket 实现长连接的场景与具体实现"></a><strong>使用 WebSocket 实现长连接的场景与具体实现</strong></h3><h4 id="1-场景描述-1"><a href="#1-场景描述-1" class="headerlink" title="1. 场景描述"></a><strong>1. 场景描述</strong></h4><p>在 <strong>校园闪送</strong> 项目中，WebSocket 长连接主要用于实现客户端与服务端之间的实时双向通信，具体场景包括：</p>
<ul>
<li><strong>实时消息推送</strong>：当有新订单时，服务端需要实时向商家端推送通知；用户端也可以实时接收催单消息。</li>
<li><strong>订单状态更新</strong>：商家和用户需要实时查看订单的最新状态，WebSocket 可以实现订单状态的即时更新。</li>
<li><strong>在线协作与互动</strong>：例如商家和用户之间的实时沟通功能。</li>
</ul>
<h4 id="2-为什么使用-WebSocket"><a href="#2-为什么使用-WebSocket" class="headerlink" title="2. 为什么使用 WebSocket"></a><strong>2. 为什么使用 WebSocket</strong></h4><ul>
<li><strong>实时性</strong>：WebSocket 提供全双工通信，能够实现实时的数据推送和快速的双向交流，适合需要频繁数据交互的场景。</li>
<li><strong>性能优化</strong>：相比传统的 HTTP 轮询，WebSocket 减少了网络开销，避免了频繁的三次握手和四次挥手。</li>
<li><strong>用户体验</strong>：通过 WebSocket，用户可以即时接收信息，提升交互体验。</li>
</ul>
<h4 id="3-具体实现方法"><a href="#3-具体实现方法" class="headerlink" title="3. 具体实现方法"></a><strong>3. 具体实现方法</strong></h4><h5 id="1-服务端实现"><a href="#1-服务端实现" class="headerlink" title="(1) 服务端实现"></a><strong>(1) 服务端实现</strong></h5><p>在服务端，需要创建一个 WebSocket 服务器来处理客户端的连接请求、消息收发以及连接关闭等事件。以下是使用 Java 和 Spring Boot 实现 WebSocket 服务器的示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@EnableWebSocket</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WebSocketConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">WebSocketConfigurer</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">registerWebSocketHandlers</span><span class="hljs-params">(WebSocketHandlerRegistry registry)</span> &#123;<br>        registry.addHandler(myWebSocketHandler(), <span class="hljs-string">&quot;/websocket&quot;</span>)<br>                .addInterceptors(<span class="hljs-keyword">new</span> <span class="hljs-title class_">HttpSessionHandshakeInterceptor</span>())<br>                .setAllowedOrigins(<span class="hljs-string">&quot;*&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> WebSocketHandler <span class="hljs-title function_">myWebSocketHandler</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyWebSocketHandler</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyWebSocketHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">TextWebSocketHandler</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterConnectionEstablished</span><span class="hljs-params">(WebSocketSession session)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 连接建立后执行的逻辑</span><br>        System.out.println(<span class="hljs-string">&quot;Connection established: &quot;</span> + session.getId());<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleTextMessage</span><span class="hljs-params">(WebSocketSession session, TextMessage message)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 处理来自客户端的消息</span><br>        System.out.println(<span class="hljs-string">&quot;Received message: &quot;</span> + message.getPayload());<br>        session.sendMessage(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TextMessage</span>(<span class="hljs-string">&quot;Hello, Client!&quot;</span>));<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterConnectionClosed</span><span class="hljs-params">(WebSocketSession session, CloseStatus status)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 连接关闭后执行的逻辑</span><br>        System.out.println(<span class="hljs-string">&quot;Connection closed: &quot;</span> + session.getId());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="2-客户端实现"><a href="#2-客户端实现" class="headerlink" title="(2) 客户端实现"></a><strong>(2) 客户端实现</strong></h5><p>客户端通过 WebSocket API 连接到服务器并处理消息。以下是使用 JavaScript 实现 WebSocket 客户端的示例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> socket = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WebSocket</span>(<span class="hljs-string">&quot;ws://localhost:8080/websocket&quot;</span>);<br><br>socket.<span class="hljs-property">onopen</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Connected to WebSocket server&quot;</span>);<br>    socket.<span class="hljs-title function_">send</span>(<span class="hljs-string">&quot;Hello, Server!&quot;</span>);<br>&#125;;<br><br>socket.<span class="hljs-property">onmessage</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Received message from server: &quot;</span> + event.<span class="hljs-property">data</span>);<br>&#125;;<br><br>socket.<span class="hljs-property">onclose</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;WebSocket connection closed&quot;</span>);<br>&#125;;<br><br>socket.<span class="hljs-property">onerror</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">error</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&quot;WebSocket error: &quot;</span> + error.<span class="hljs-property">message</span>);<br>&#125;;<br></code></pre></td></tr></table></figure>

<h5 id="3-保持连接的策略"><a href="#3-保持连接的策略" class="headerlink" title="(3) 保持连接的策略"></a><strong>(3) 保持连接的策略</strong></h5><p>为了保持 WebSocket 长连接，可以采用以下策略：</p>
<ul>
<li><p><strong>心跳机制</strong>：定期向服务器发送心跳消息，以保持连接活跃。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (socket.<span class="hljs-property">readyState</span> === <span class="hljs-title class_">WebSocket</span>.<span class="hljs-property">OPEN</span>) &#123;<br>        socket.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;心跳&#x27;</span>);<br>    &#125;<br>&#125;, <span class="hljs-number">30000</span>); <span class="hljs-comment">// 每30秒发送一次</span><br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>自动重连</strong>：当连接断开时，自动尝试重新连接。</p>
</li>
</ul>
<h5 id="4-消息转发与集群支持"><a href="#4-消息转发与集群支持" class="headerlink" title="(4) 消息转发与集群支持"></a><strong>(4) 消息转发与集群支持</strong></h5><p>在分布式系统中，WebSocket 长连接需要支持消息转发和集群部署。可以通过以下方式实现：</p>
<ul>
<li><strong>服务实例间的消息转发</strong>：每个服务实例作为客户端连接到其他服务实例的 WebSocket 服务端，实现消息的转发。</li>
<li><strong>服务发现</strong>：通过 Spring Cloud 的服务发现组件（如 Nacos 或 Eureka）获取所有服务实例的信息。</li>
</ul>
<h5 id="5-消息选择性发送"><a href="#5-消息选择性发送" class="headerlink" title="(5) 消息选择性发送"></a><strong>(5) 消息选择性发送</strong></h5><p>在某些场景下，可能需要向特定用户发送消息，而不是广播给所有客户端。可以通过以下方式实现：</p>
<ul>
<li><strong>用户标识</strong>：客户端连接时将用户标识（如用户ID）发送给服务端，并存储在连接的元数据中。</li>
<li><strong>自定义选择器</strong>：根据消息头中的用户标识选择特定的连接进行消息发送。</li>
</ul>
<h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a><strong>总结</strong></h3><p>通过使用 WebSocket 实现长连接，可以实现实时的消息推送和双向通信，适用于需要频繁数据交互的场景，如即时通讯、订单状态更新等。具体实现包括服务端和客户端的 WebSocket 实现、保持连接的策略以及消息转发和集群支持。这种技术能够显著提升用户体验和系统性能。</p>
<hr>
<h2 id="4-SpringTask订单超时自动取消"><a href="#4-SpringTask订单超时自动取消" class="headerlink" title="4. SpringTask订单超时自动取消"></a><strong>4. SpringTask订单超时自动取消</strong></h2><p>在 <strong>校园闪送</strong> 项目中，使用 <strong>SpringTask</strong> 实现订单超时自动取消功能的场景和具体实现如下：</p>
<h3 id="1-使用场景"><a href="#1-使用场景" class="headerlink" title="1. 使用场景"></a><strong>1. 使用场景</strong></h3><p>在校园闪送系统中，用户下单后需要在一定时间内完成支付。如果订单在规定时间（如30分钟）内未支付，则需要自动取消订单，释放库存资源，避免资源被长时间占用。这种功能在电商平台、在线订票系统和预约系统中非常常见。</p>
<h3 id="2-为什么使用-SpringTask"><a href="#2-为什么使用-SpringTask" class="headerlink" title="2. 为什么使用 SpringTask"></a><strong>2. 为什么使用 SpringTask</strong></h3><ul>
<li><strong>定时任务的灵活性</strong>：SpringTask 提供了灵活的定时任务配置，可以轻松实现周期性检查订单状态。</li>
<li><strong>轻量级和易于集成</strong>：SpringTask 是 Spring Boot 提供的内置定时任务解决方案，无需额外的依赖，与 Spring 生态系统无缝集成。</li>
<li><strong>性能优化</strong>：通过定时任务，可以减少对数据库的频繁查询，优化系统性能。</li>
</ul>
<h3 id="3-具体实现方法-1"><a href="#3-具体实现方法-1" class="headerlink" title="3. 具体实现方法"></a><strong>3. 具体实现方法</strong></h3><h4 id="1-创建订单取消服务"><a href="#1-创建订单取消服务" class="headerlink" title="(1) 创建订单取消服务"></a><strong>(1) 创建订单取消服务</strong></h4><p>创建一个服务类 <code>OrderCancellationService</code>，用于处理订单的自动取消逻辑。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderCancellationService</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> OrderRepository orderRepository;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">cancelOrdersAfterTimeout</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">cutoffTime</span> <span class="hljs-operator">=</span> LocalDateTime.now().minusMinutes(<span class="hljs-number">30</span>); <span class="hljs-comment">// 设置30分钟的超时时间</span><br>        List&lt;Order&gt; pendingOrders = orderRepository.findByStatusAndCreatedAtBefore(<br>                OrderStatus.PENDING_PAYMENT, cutoffTime);<br><br>        <span class="hljs-keyword">for</span> (Order order : pendingOrders) &#123;<br>            order.setStatus(OrderStatus.CANCELLED); <span class="hljs-comment">// 更新订单状态为已取消</span><br>            orderRepository.save(order);<br>            System.out.println(<span class="hljs-string">&quot;Order &quot;</span> + order.getId() + <span class="hljs-string">&quot; is cancelled due to timeout.&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="2-配置定时任务"><a href="#2-配置定时任务" class="headerlink" title="(2) 配置定时任务"></a><strong>(2) 配置定时任务</strong></h4><p>使用 <code>@Scheduled</code> 注解配置定时任务，周期性地调用订单取消服务。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@EnableScheduling</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ScheduledTasks</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> OrderCancellationService orderCancellationService;<br><br>    <span class="hljs-meta">@Scheduled(fixedRate = 60000)</span> <span class="hljs-comment">// 每分钟执行一次</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">cancelPendingOrders</span><span class="hljs-params">()</span> &#123;<br>        orderCancellationService.cancelOrdersAfterTimeout();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="3-数据库查询方法"><a href="#3-数据库查询方法" class="headerlink" title="(3) 数据库查询方法"></a><strong>(3) 数据库查询方法</strong></h4><p>在 <code>OrderRepository</code> 中，添加一个方法用于查询未支付且超时的订单。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">OrderRepository</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">JpaRepository</span>&lt;Order, Long&gt; &#123;<br><br>    <span class="hljs-meta">@Query(&quot;SELECT o FROM Order o WHERE o.status = &#x27;PENDING_PAYMENT&#x27; AND o.createdAt &lt; ?1&quot;)</span><br>    List&lt;Order&gt; <span class="hljs-title function_">findByStatusAndCreatedAtBefore</span><span class="hljs-params">(OrderStatus status, LocalDateTime cutoffTime)</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="4-测试代码"><a href="#4-测试代码" class="headerlink" title="(4) 测试代码"></a><strong>(4) 测试代码</strong></h4><p>使用 Spring Boot Test 和 H2 数据库来测试订单超时自动取消的功能。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderCancellationTaskTest</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> OrderRepository orderRepository;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> OrderCancellationService orderCancellationService;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testCancelUnpaidOrders</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 创建一个超时未支付的订单</span><br>        <span class="hljs-type">Order</span> <span class="hljs-variable">unpaidOrder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Order</span>(<span class="hljs-string">&quot;PENDING_PAYMENT&quot;</span>, LocalDateTime.now().minusMinutes(<span class="hljs-number">31</span>));<br>        orderRepository.save(unpaidOrder);<br><br>        <span class="hljs-comment">// 执行订单取消任务</span><br>        orderCancellationService.cancelOrdersAfterTimeout();<br><br>        <span class="hljs-comment">// 检查订单是否被取消</span><br>        <span class="hljs-type">Order</span> <span class="hljs-variable">fetchedOrder</span> <span class="hljs-operator">=</span> orderRepository.findById(unpaidOrder.getId()).orElse(<span class="hljs-literal">null</span>);<br>        assertThat(fetchedOrder).isNotNull();<br>        assertThat(fetchedOrder.getStatus()).isEqualTo(<span class="hljs-string">&quot;CANCELLED&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a><strong>4. 总结</strong></h3><p>通过使用 <strong>SpringTask</strong> 实现订单超时自动取消功能，可以有效管理未支付的订单，释放库存资源，提升用户体验。具体实现包括：</p>
<ol>
<li>创建订单取消服务，查询并取消超时未支付的订单。</li>
<li>配置定时任务，周期性地调用订单取消服务。</li>
<li>在数据库中查询超时未支付的订单。</li>
<li>使用测试代码验证功能的正确性。</li>
</ol>
<hr>
<h2 id="5-AOP字段自动填充"><a href="#5-AOP字段自动填充" class="headerlink" title="5. AOP字段自动填充"></a><strong>5. AOP字段自动填充</strong></h2><p>在 <strong>校园闪送</strong> 项目中，使用 <strong>Spring AOP</strong> 实现字段自动填充的场景主要是为了简化开发流程，避免在每个业务逻辑中重复编写公共字段的赋值代码。具体实现步骤如下：</p>
<h3 id="1-使用场景-1"><a href="#1-使用场景-1" class="headerlink" title="1. 使用场景"></a><strong>1. 使用场景</strong></h3><p>在校园闪送系统中，许多实体对象（如订单、用户、菜品等）都包含一些公共字段，例如：</p>
<ul>
<li><strong>创建时间（create_time）</strong></li>
<li><strong>创建人（create_user）</strong></li>
<li><strong>更新时间（update_time）</strong></li>
<li><strong>更新人（update_user）</strong></li>
</ul>
<p>这些字段在新增和更新数据时需要被自动填充。手动编写这些字段的赋值代码不仅繁琐，还容易出错。因此，通过 <strong>Spring AOP</strong> 实现字段自动填充可以显著减少重复代码，提高开发效率。</p>
<h3 id="2-具体实现步骤"><a href="#2-具体实现步骤" class="headerlink" title="2. 具体实现步骤"></a><strong>2. 具体实现步骤</strong></h3><h4 id="1-自定义注解-AutoFill"><a href="#1-自定义注解-AutoFill" class="headerlink" title="(1) 自定义注解 AutoFill"></a><strong>(1) 自定义注解 <code>AutoFill</code></strong></h4><p>创建一个自定义注解 <code>AutoFill</code>，用于标识需要进行字段自动填充的方法。注解中包含一个枚举值，用于区分数据库操作类型（如 <code>INSERT</code> 或 <code>UPDATE</code>）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.example.annotation;<br><br><span class="hljs-keyword">import</span> com.example.enumeration.OperationType;<br><span class="hljs-keyword">import</span> java.lang.annotation.ElementType;<br><span class="hljs-keyword">import</span> java.lang.annotation.Retention;<br><span class="hljs-keyword">import</span> java.lang.annotation.RetentionPolicy;<br><span class="hljs-keyword">import</span> java.lang.annotation.Target;<br><br><span class="hljs-meta">@Target(ElementType.METHOD)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> AutoFill &#123;<br>    OperationType <span class="hljs-title function_">value</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="2-自定义切面类-AutoFillAspect"><a href="#2-自定义切面类-AutoFillAspect" class="headerlink" title="(2) 自定义切面类 AutoFillAspect"></a><strong>(2) 自定义切面类 <code>AutoFillAspect</code></strong></h4><p>创建一个切面类 <code>AutoFillAspect</code>，用于统一拦截加入了 <code>AutoFill</code> 注解的方法，并通过反射为公共字段赋值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.example.aspect;<br><br><span class="hljs-keyword">import</span> com.example.annotation.AutoFill;<br><span class="hljs-keyword">import</span> com.example.constant.AutoFillConstant;<br><span class="hljs-keyword">import</span> com.example.enumeration.OperationType;<br><span class="hljs-keyword">import</span> lombok.extern.slf4j.Slf4j;<br><span class="hljs-keyword">import</span> org.aspectj.lang.JoinPoint;<br><span class="hljs-keyword">import</span> org.aspectj.lang.annotation.Aspect;<br><span class="hljs-keyword">import</span> org.aspectj.lang.annotation.Before;<br><span class="hljs-keyword">import</span> org.aspectj.lang.annotation.Pointcut;<br><span class="hljs-keyword">import</span> org.aspectj.lang.reflect.MethodSignature;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><span class="hljs-keyword">import</span> java.time.LocalDateTime;<br><br><span class="hljs-meta">@Aspect</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AutoFillAspect</span> &#123;<br><br>    <span class="hljs-meta">@Pointcut(&quot;execution(* com.example.mapper.*.*(..)) &amp;&amp; @annotation(com.example.annotation.AutoFill)&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">autoFillPointCut</span><span class="hljs-params">()</span> &#123;&#125;<br><br>    <span class="hljs-meta">@Before(&quot;autoFillPointCut()&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">autoFill</span><span class="hljs-params">(JoinPoint joinPoint)</span> &#123;<br>        <span class="hljs-type">MethodSignature</span> <span class="hljs-variable">signature</span> <span class="hljs-operator">=</span> (MethodSignature) joinPoint.getSignature();<br>        <span class="hljs-type">Method</span> <span class="hljs-variable">method</span> <span class="hljs-operator">=</span> signature.getMethod();<br>        <span class="hljs-type">AutoFill</span> <span class="hljs-variable">autoFill</span> <span class="hljs-operator">=</span> method.getAnnotation(AutoFill.class);<br>        <span class="hljs-type">OperationType</span> <span class="hljs-variable">operationType</span> <span class="hljs-operator">=</span> autoFill.value();<br><br>        Object[] args = joinPoint.getArgs();<br>        <span class="hljs-keyword">if</span> (args == <span class="hljs-literal">null</span> || args.length == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">entity</span> <span class="hljs-operator">=</span> args[<span class="hljs-number">0</span>];<br>        <span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">now</span> <span class="hljs-operator">=</span> LocalDateTime.now();<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">if</span> (operationType == OperationType.INSERT) &#123;<br>                <span class="hljs-type">Method</span> <span class="hljs-variable">setCreateTime</span> <span class="hljs-operator">=</span> entity.getClass().getDeclaredMethod(AutoFillConstant.SET_CREATE_TIME, LocalDateTime.class);<br>                <span class="hljs-type">Method</span> <span class="hljs-variable">setCreateUser</span> <span class="hljs-operator">=</span> entity.getClass().getDeclaredMethod(AutoFillConstant.SET_CREATE_USER, Long.class);<br>                <span class="hljs-type">Method</span> <span class="hljs-variable">setUpdateTime</span> <span class="hljs-operator">=</span> entity.getClass().getDeclaredMethod(AutoFillConstant.SET_UPDATE_TIME, LocalDateTime.class);<br>                <span class="hljs-type">Method</span> <span class="hljs-variable">setUpdateUser</span> <span class="hljs-operator">=</span> entity.getClass().getDeclaredMethod(AutoFillConstant.SET_UPDATE_USER, Long.class);<br><br>                setCreateTime.invoke(entity, now);<br>                setCreateUser.invoke(entity, getCurrentUserId());<br>                setUpdateTime.invoke(entity, now);<br>                setUpdateUser.invoke(entity, getCurrentUserId());<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (operationType == OperationType.UPDATE) &#123;<br>                <span class="hljs-type">Method</span> <span class="hljs-variable">setUpdateTime</span> <span class="hljs-operator">=</span> entity.getClass().getDeclaredMethod(AutoFillConstant.SET_UPDATE_TIME, LocalDateTime.class);<br>                <span class="hljs-type">Method</span> <span class="hljs-variable">setUpdateUser</span> <span class="hljs-operator">=</span> entity.getClass().getDeclaredMethod(AutoFillConstant.SET_UPDATE_USER, Long.class);<br><br>                setUpdateTime.invoke(entity, now);<br>                setUpdateUser.invoke(entity, getCurrentUserId());<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            log.error(<span class="hljs-string">&quot;Error during auto-fill operation&quot;</span>, e);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> Long <span class="hljs-title function_">getCurrentUserId</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 获取当前登录用户ID的逻辑</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1L</span>; <span class="hljs-comment">// 示例</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="3-在-Mapper-方法上加入-AutoFill-注解"><a href="#3-在-Mapper-方法上加入-AutoFill-注解" class="headerlink" title="(3) 在 Mapper 方法上加入 AutoFill 注解"></a><strong>(3) 在 Mapper 方法上加入 <code>AutoFill</code> 注解</strong></h4><p>在需要进行字段自动填充的 Mapper 方法上加入 <code>AutoFill</code> 注解，指定操作类型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.example.mapper;<br><br><span class="hljs-keyword">import</span> com.example.annotation.AutoFill;<br><span class="hljs-keyword">import</span> com.example.enumeration.OperationType;<br><span class="hljs-keyword">import</span> org.apache.ibatis.annotations.Mapper;<br><br><span class="hljs-meta">@Mapper</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">OrderMapper</span> &#123;<br>    <span class="hljs-meta">@AutoFill(OperationType.INSERT)</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">insertOrder</span><span class="hljs-params">(Order order)</span>;<br><br>    <span class="hljs-meta">@AutoFill(OperationType.UPDATE)</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">updateOrder</span><span class="hljs-params">(Order order)</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="3-其他实现方法"><a href="#3-其他实现方法" class="headerlink" title="3. 其他实现方法"></a><strong>3. 其他实现方法</strong></h3><p>除了使用 <strong>Spring AOP</strong>，还可以通过以下方法实现字段自动填充：</p>
<ul>
<li><strong>MyBatis Plus</strong>：MyBatis Plus 提供了内置的字段自动填充功能，通过在实体类中定义 <code>@TableField</code> 注解，并设置 <code>fill</code> 属性，可以实现类似的功能。</li>
<li><strong>数据库触发器</strong>：在数据库层面使用触发器，在数据插入或更新时自动填充字段。这种方法不依赖于应用代码，但需要在数据库中进行配置。</li>
</ul>
<h3 id="4-总结-1"><a href="#4-总结-1" class="headerlink" title="4. 总结"></a><strong>4. 总结</strong></h3><p>通过 <strong>Spring AOP</strong> 实现字段自动填充，可以显著减少重复代码，提高开发效率。具体实现包括：</p>
<ol>
<li>创建自定义注解 <code>AutoFill</code>，用于标识需要自动填充的方法。</li>
<li>创建切面类 <code>AutoFillAspect</code>，通过反射为公共字段赋值。</li>
<li>在 Mapper 方法上加入 <code>AutoFill</code> 注解，指定操作类型。</li>
</ol>
<h2 id="这种方法不仅适用于校园闪送项目，还可以广泛应用于其他需要字段自动填充的场景。"><a href="#这种方法不仅适用于校园闪送项目，还可以广泛应用于其他需要字段自动填充的场景。" class="headerlink" title="这种方法不仅适用于校园闪送项目，还可以广泛应用于其他需要字段自动填充的场景。"></a>这种方法不仅适用于校园闪送项目，还可以广泛应用于其他需要字段自动填充的场景。</h2><h2 id="6-使用-Nginx-配置反向代理与负载均衡"><a href="#6-使用-Nginx-配置反向代理与负载均衡" class="headerlink" title="6. 使用 Nginx 配置反向代理与负载均衡"></a><strong>6. 使用 Nginx 配置反向代理与负载均衡</strong></h2><h3 id="为什么在项目中使用-Nginx-配置反向代理与负载均衡？"><a href="#为什么在项目中使用-Nginx-配置反向代理与负载均衡？" class="headerlink" title="为什么在项目中使用 Nginx 配置反向代理与负载均衡？"></a><strong>为什么在项目中使用 Nginx 配置反向代理与负载均衡？</strong></h3><h4 id="1-使用场景-2"><a href="#1-使用场景-2" class="headerlink" title="1. 使用场景"></a><strong>1. 使用场景</strong></h4><p>在 <strong>校园闪送</strong> 项目中，Nginx 配置反向代理与负载均衡的场景主要包括以下几点：</p>
<ul>
<li><strong>前后端分离</strong>：前端和后端服务部署在不同的服务器上，需要通过一个统一的入口（如域名）访问后端服务。</li>
<li><strong>高并发处理</strong>：系统需要处理大量用户请求，通过负载均衡将请求分发到多个后端服务器，提高系统的并发处理能力。</li>
<li><strong>跨域问题</strong>：前端和后端服务可能部署在不同的域名或端口上，Nginx 可以通过反向代理解决跨域问题。</li>
<li><strong>安全性增强</strong>：通过 Nginx 提供 SSL&#x2F;TLS 加密，确保数据传输的安全。</li>
</ul>
<h4 id="2-具体实现方法"><a href="#2-具体实现方法" class="headerlink" title="2. 具体实现方法"></a><strong>2. 具体实现方法</strong></h4><h5 id="1-配置反向代理"><a href="#1-配置反向代理" class="headerlink" title="(1) 配置反向代理"></a><strong>(1) 配置反向代理</strong></h5><p>反向代理允许客户端通过一个统一的入口访问后端服务，隐藏后端服务的细节。以下是 Nginx 配置反向代理的基本步骤：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">server</span> &#123;<br>    <span class="hljs-attribute">listen</span> <span class="hljs-number">80</span>;  <span class="hljs-comment"># 监听端口</span><br>    <span class="hljs-attribute">server_name</span> example.com;  <span class="hljs-comment"># 域名</span><br><br>    <span class="hljs-section">location</span> / &#123;<br>        <span class="hljs-attribute">proxy_pass</span> http://backend_server;  <span class="hljs-comment"># 后端服务地址</span><br>        <span class="hljs-attribute">proxy_set_header</span> Host <span class="hljs-variable">$host</span>;  <span class="hljs-comment"># 传递原始 Host 头部</span><br>        <span class="hljs-attribute">proxy_set_header</span> X-Real-IP <span class="hljs-variable">$remote_addr</span>;  <span class="hljs-comment"># 传递客户端真实 IP</span><br>        <span class="hljs-attribute">proxy_set_header</span> X-Forwarded-For <span class="hljs-variable">$proxy_add_x_forwarded_for</span>;  <span class="hljs-comment"># 传递转发的 IP</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在上述配置中，<code>proxy_pass</code> 指定了后端服务的地址，<code>proxy_set_header</code> 用于传递客户端的真实信息。</p>
<h5 id="2-配置负载均衡"><a href="#2-配置负载均衡" class="headerlink" title="(2) 配置负载均衡"></a><strong>(2) 配置负载均衡</strong></h5><p>负载均衡可以将请求分发到多个后端服务器，提高系统的可用性和性能。以下是 Nginx 配置负载均衡的基本步骤：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">http</span> &#123;<br>    <span class="hljs-section">upstream</span> backend_servers &#123;<br>        <span class="hljs-attribute">server</span> backend1.example.com;  <span class="hljs-comment"># 后端服务器1</span><br>        <span class="hljs-attribute">server</span> backend2.example.com;  <span class="hljs-comment"># 后端服务器2</span><br>        <span class="hljs-attribute">server</span> backend3.example.com;  <span class="hljs-comment"># 后端服务器3</span><br>    &#125;<br><br>    <span class="hljs-section">server</span> &#123;<br>        <span class="hljs-attribute">listen</span> <span class="hljs-number">80</span>;<br>        <span class="hljs-attribute">server_name</span> example.com;<br><br>        <span class="hljs-section">location</span> / &#123;<br>            <span class="hljs-attribute">proxy_pass</span> http://backend_servers;  <span class="hljs-comment"># 使用负载均衡的后端服务器</span><br>            <span class="hljs-attribute">proxy_set_header</span> Host <span class="hljs-variable">$host</span>;<br>            <span class="hljs-attribute">proxy_set_header</span> X-Real-IP <span class="hljs-variable">$remote_addr</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在上述配置中，<code>upstream</code> 块定义了一个后端服务器池，<code>proxy_pass</code> 指定了负载均衡的后端服务器。</p>
<h5 id="3-均衡算法"><a href="#3-均衡算法" class="headerlink" title="(3) 均衡算法"></a><strong>(3) 均衡算法</strong></h5><p>Nginx 提供了多种负载均衡算法，可以根据实际需求选择：</p>
<ul>
<li><strong>轮询（默认）</strong>：按照顺序逐一分配请求到后端服务器。</li>
<li><strong>最少连接</strong>：优先将请求分配给当前连接数最少的后端服务器。</li>
<li><strong>IP 哈希</strong>：根据客户端 IP 的哈希值固定分配后端服务器，适用于需要会话保持的场景。</li>
</ul>
<h5 id="4-SSL-x2F-TLS-配置"><a href="#4-SSL-x2F-TLS-配置" class="headerlink" title="(4) SSL&#x2F;TLS 配置"></a><strong>(4) SSL&#x2F;TLS 配置</strong></h5><p>为了确保数据传输的安全，可以配置 Nginx 提供 SSL&#x2F;TLS 加密：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">server</span> &#123;<br>    <span class="hljs-attribute">listen</span> <span class="hljs-number">443</span> ssl;  <span class="hljs-comment"># 监听 HTTPS 端口</span><br>    <span class="hljs-attribute">server_name</span> example.com;<br><br>    <span class="hljs-attribute">ssl_certificate</span> /path/to/cert.pem;  <span class="hljs-comment"># SSL 证书路径</span><br>    <span class="hljs-attribute">ssl_certificate_key</span> /path/to/key.pem;  <span class="hljs-comment"># SSL 私钥路径</span><br><br>    <span class="hljs-section">location</span> / &#123;<br>        <span class="hljs-attribute">proxy_pass</span> http://backend_servers;<br>        <span class="hljs-attribute">proxy_set_header</span> Host <span class="hljs-variable">$host</span>;<br>        <span class="hljs-attribute">proxy_set_header</span> X-Real-IP <span class="hljs-variable">$remote_addr</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在上述配置中，<code>ssl_certificate</code> 和 <code>ssl_certificate_key</code> 指定了 SSL 证书和私钥的路径。</p>
<h3 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a><strong>总结</strong></h3><p>通过使用 Nginx 配置反向代理与负载均衡，可以实现以下目标：</p>
<ol>
<li><strong>前后端分离</strong>：提供统一的访问入口，隐藏后端服务细节。</li>
<li><strong>高并发处理</strong>：通过负载均衡将请求分发到多个后端服务器，提高系统的并发处理能力。</li>
<li><strong>跨域问题</strong>：解决前端和后端服务部署在不同域名或端口上的跨域问题。</li>
<li><strong>安全性增强</strong>：通过 SSL&#x2F;TLS 加密，确保数据传输的安全。</li>
</ol>
<h2 id="7-数据安全与权限校验"><a href="#7-数据安全与权限校验" class="headerlink" title="7. 数据安全与权限校验"></a><strong>7. 数据安全与权限校验</strong></h2><p>在 <strong>校园闪送</strong> 项目中，数据安全与权限校验是确保系统稳定运行和保护用户隐私的关键环节。以下是具体的应用场景和实现方法：</p>
<h3 id="1-使用场景-3"><a href="#1-使用场景-3" class="headerlink" title="1. 使用场景"></a><strong>1. 使用场景</strong></h3><ul>
<li><strong>用户数据保护</strong>：确保用户信息（如订单、个人信息等）只能被授权用户访问。</li>
<li><strong>操作权限控制</strong>：限制用户只能执行其角色允许的操作，例如商家只能管理自己的菜品和订单，用户只能查看自己的订单。</li>
<li><strong>防止越权访问</strong>：防止用户通过非法手段访问不属于自己的数据或执行未授权的操作。</li>
</ul>
<h3 id="2-实现方法"><a href="#2-实现方法" class="headerlink" title="2. 实现方法"></a><strong>2. 实现方法</strong></h3><h4 id="1-使用-Spring-Security-进行权限校验"><a href="#1-使用-Spring-Security-进行权限校验" class="headerlink" title="(1) 使用 Spring Security 进行权限校验"></a><strong>(1) 使用 Spring Security 进行权限校验</strong></h4><p>Spring Security 是一个强大的安全框架，可以方便地实现认证和授权功能。</p>
<ul>
<li><p><strong>添加依赖</strong>：在 <code>pom.xml</code> 中引入 Spring Security 依赖。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>配置 Security</strong>：创建一个配置类 <code>WebSecurityConfig</code>，继承 <code>WebSecurityConfigurerAdapter</code>，并重写 <code>configure</code> 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@EnableWebSecurity</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WebSecurityConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">WebSecurityConfigurerAdapter</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        http<br>            .authorizeRequests()<br>                .antMatchers(<span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-string">&quot;/home&quot;</span>, <span class="hljs-string">&quot;/login&quot;</span>).permitAll() <span class="hljs-comment">// 允许访问的路径</span><br>                .anyRequest().authenticated() <span class="hljs-comment">// 其他请求需要认证</span><br>                .and()<br>            .formLogin()<br>                .loginPage(<span class="hljs-string">&quot;/login&quot;</span>).permitAll() <span class="hljs-comment">// 自定义登录页面</span><br>                .and()<br>            .logout().permitAll(); <span class="hljs-comment">// 允许注销</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>用户认证</strong>：通过 <code>UserDetailsService</code> 加载用户信息，并使用 <code>PasswordEncoder</code> 对密码进行加密。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">configureGlobal</span><span class="hljs-params">(AuthenticationManagerBuilder auth)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    auth.userDetailsService(userDetailsService).passwordEncoder(passwordEncoder());<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h4 id="2-使用-AOP-进行功能权限校验"><a href="#2-使用-AOP-进行功能权限校验" class="headerlink" title="(2) 使用 AOP 进行功能权限校验"></a><strong>(2) 使用 AOP 进行功能权限校验</strong></h4><p>对于更细粒度的权限控制，可以使用 AOP 结合自定义注解来实现。</p>
<ul>
<li><p><strong>自定义注解</strong>：创建一个注解 <code>@ValidatePermission</code>，用于标记需要权限校验的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Target(ElementType.METHOD)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> ValidatePermission &#123;<br>    String <span class="hljs-title function_">value</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>AOP 切面类</strong>：创建一个切面类 <code>PermissionAspect</code>，拦截带有 <code>@ValidatePermission</code> 注解的方法，并进行权限校验。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Aspect</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PermissionAspect</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> SysUserRolePermService sysUserRolePermService;<br><br>    <span class="hljs-meta">@Before(&quot;@annotation(validatePermission)&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">checkPermission</span><span class="hljs-params">(JoinPoint joinPoint, ValidatePermission validatePermission)</span> &#123;<br>        <span class="hljs-comment">// 获取方法参数</span><br>        Object[] args = joinPoint.getArgs();<br>        <span class="hljs-comment">// 获取方法签名</span><br>        <span class="hljs-type">MethodSignature</span> <span class="hljs-variable">signature</span> <span class="hljs-operator">=</span> (MethodSignature) joinPoint.getSignature();<br>        <span class="hljs-type">Method</span> <span class="hljs-variable">method</span> <span class="hljs-operator">=</span> signature.getMethod();<br>        <span class="hljs-comment">// 校验权限</span><br>        <span class="hljs-keyword">if</span> (!sysUserRolePermService.hasPermission(validatePermission.value())) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AccessDeniedException</span>(<span class="hljs-string">&quot;您无权操作！&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>使用注解</strong>：在需要校验权限的方法上添加 <code>@ValidatePermission</code> 注解。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/updateOrder&quot;)</span><br><span class="hljs-meta">@ValidatePermission(&quot;UPDATE_ORDER&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">updateOrder</span><span class="hljs-params">(Order order)</span> &#123;<br>    <span class="hljs-comment">// 更新订单逻辑</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h4 id="3-数据安全标记与访问控制"><a href="#3-数据安全标记与访问控制" class="headerlink" title="(3) 数据安全标记与访问控制"></a><strong>(3) 数据安全标记与访问控制</strong></h4><p>对于数据级别的安全控制，可以采用数据安全标记和强制访问控制策略。</p>
<ul>
<li><p><strong>数据安全标记</strong>：对数据资源进行分类和分级标记，存储在数据库中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DataSecurityLabel</span> &#123;<br>    <span class="hljs-keyword">private</span> String resourceName;<br>    <span class="hljs-keyword">private</span> String category;<br>    <span class="hljs-keyword">private</span> String level;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>强制访问控制</strong>：在业务逻辑中，根据用户的角色和权限，判断其是否可以访问特定数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasDataAccess</span><span class="hljs-params">(String userId, String resourceId)</span> &#123;<br>    <span class="hljs-comment">// 查询用户角色和权限</span><br>    List&lt;String&gt; userPermissions = getUserPermissions(userId);<br>    <span class="hljs-comment">// 查询数据资源的安全标记</span><br>    <span class="hljs-type">DataSecurityLabel</span> <span class="hljs-variable">label</span> <span class="hljs-operator">=</span> getDataSecurityLabel(resourceId);<br>    <span class="hljs-comment">// 判断用户是否有权限访问该数据</span><br>    <span class="hljs-keyword">return</span> userPermissions.contains(label.getCategory()) &amp;&amp; userPermissions.contains(label.getLevel());<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a><strong>3. 总结</strong></h3><p>在 <strong>校园闪送</strong> 项目中，通过以下方法实现了数据安全与权限校验：</p>
<ol>
<li>使用 <strong>Spring Security</strong> 配置全局安全策略，保护用户数据和操作权限。</li>
<li>使用 <strong>AOP</strong> 和自定义注解实现细粒度的功能权限校验。</li>
<li>通过数据安全标记和强制访问控制策略，实现数据级别的安全控制。</li>
</ol>
<hr>
<h2 id="潜在重点难点分析与解决方案"><a href="#潜在重点难点分析与解决方案" class="headerlink" title="潜在重点难点分析与解决方案"></a>潜在重点难点分析与解决方案</h2><h4 id="1-需求频繁变更与业务逻辑耦合"><a href="#1-需求频繁变更与业务逻辑耦合" class="headerlink" title="1. 需求频繁变更与业务逻辑耦合"></a><strong>1. 需求频繁变更与业务逻辑耦合</strong></h4><ul>
<li><strong>难点</strong>：<br>餐饮业务需求多变（如促销活动、菜品分类调整），系统需快速响应调整，但代码耦合度高会导致修改成本剧增。  </li>
<li><strong>解决方案</strong>：  <ul>
<li><strong>领域驱动设计（DDD）</strong>：将核心业务（订单、库存、支付）抽象为独立领域模块，通过防腐层隔离外部依赖。  </li>
<li><strong>插件化架构</strong>：将促销、统计等功能设计为可插拔模块，通过配置文件动态加载。  </li>
<li><strong>契约测试</strong>：定义接口契约文档（如OpenAPI），确保前后端修改不影响已有功能。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="2-多端协同与接口一致性"><a href="#2-多端协同与接口一致性" class="headerlink" title="2. 多端协同与接口一致性"></a><strong>2. 多端协同与接口一致性</strong></h4><ul>
<li><strong>难点</strong>：<br>管理端（Web）与用户端（微信小程序）需共享数据，但接口版本迭代可能导致兼容性问题。  </li>
<li><strong>解决方案</strong>：  <ul>
<li><strong>API版本控制</strong>：通过URL路径（如<code>/v1/order</code>）或请求头区分版本，旧版接口保留过渡期。  </li>
<li><strong>Mock服务</strong>：前端开发阶段使用Swagger+Postman Mock Server模拟接口响应，降低联调阻塞。  </li>
<li><strong>数据同步</strong>：采用Binlog监听MySQL变更，通过RabbitMQ广播事件，触发缓存更新或小程序端数据刷新。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="3-支付与第三方服务集成"><a href="#3-支付与第三方服务集成" class="headerlink" title="3. 支付与第三方服务集成"></a><strong>3. 支付与第三方服务集成</strong></h4><ul>
<li><strong>难点</strong>：<br>微信支付回调的异步处理、网络超时、重复通知等场景易引发订单状态不一致。  </li>
<li><strong>解决方案</strong>：  <ul>
<li><strong>幂等性设计</strong>：支付回调接口通过<code>order_id</code>+<code>payment_id</code>唯一键避免重复处理。  </li>
<li><strong>补偿任务</strong>：定时扫描“支付中”状态的订单，主动查询微信支付结果（通过<code>out_trade_no</code>）。  </li>
<li><strong>熔断降级</strong>：集成Sentinel，在支付服务不可用时降级为“货到付款”模式，保障核心流程可用。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="4-分布式环境下的数据一致性"><a href="#4-分布式环境下的数据一致性" class="headerlink" title="4. 分布式环境下的数据一致性"></a><strong>4. 分布式环境下的数据一致性</strong></h4><ul>
<li><strong>难点</strong>：<br>订单创建、库存扣减、支付回调可能跨服务调用，需保证最终一致性。  </li>
<li><strong>解决方案</strong>：  <ul>
<li><strong>Saga模式</strong>：将订单流程拆分为多个本地事务，通过事件驱动补偿机制（如库存不足时触发订单自动取消）。  </li>
<li><strong>本地消息表</strong>：在MySQL中记录事务日志，通过定时任务重试失败的消息（如库存扣减失败后回滚订单）。  </li>
<li><strong>分布式锁</strong>：使用Redis RedLock算法防止库存超卖（如秒杀场景）。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="5-用户体验与性能优化"><a href="#5-用户体验与性能优化" class="headerlink" title="5. 用户体验与性能优化"></a><strong>5. 用户体验与性能优化</strong></h4><ul>
<li><strong>难点</strong>：<br>微信小程序首屏加载慢、管理端数据统计页面卡顿。  </li>
<li><strong>解决方案</strong>：  <ul>
<li><strong>小程序端</strong>：  <ul>
<li>图片懒加载+WebP格式压缩，减少首屏资源体积。  </li>
<li>使用<code>wx.setStorageSync</code>缓存静态数据（如菜品分类），减少HTTP请求。</li>
</ul>
</li>
<li><strong>管理端</strong>：  <ul>
<li>分页查询+虚拟滚动（如Ant Design Table）优化大数据量渲染。  </li>
<li>复杂统计查询预计算，结果存入Redis，每日定时更新。</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h4 id="6-安全防护纵深不足"><a href="#6-安全防护纵深不足" class="headerlink" title="6. 安全防护纵深不足"></a><strong>6. 安全防护纵深不足</strong></h4><ul>
<li><strong>难点</strong>：<br>系统可能面临SQL注入、XSS攻击、越权访问等风险。  </li>
<li><strong>解决方案</strong>：  <ul>
<li><strong>输入校验</strong>：全局拦截器过滤特殊字符（如<code>&lt;script&gt;</code>），结合MyBatis参数化查询防SQL注入。  </li>
<li><strong>权限细粒度控制</strong>：基于RBAC模型，动态校验接口权限（如<code>@PreAuthorize(&quot;hasRole(&#39;ADMIN&#39;)&quot;)</code>）。  </li>
<li><strong>敏感数据脱敏</strong>：日志中屏蔽用户手机号（如<code>199****2959</code>），数据库字段加密存储（AES-GCM算法）。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="7-运维与监控体系缺失"><a href="#7-运维与监控体系缺失" class="headerlink" title="7. 运维与监控体系缺失"></a><strong>7. 运维与监控体系缺失</strong></h4><ul>
<li><strong>难点</strong>：<br>线上问题定位困难，缺乏实时监控和预警机制。  </li>
<li><strong>解决方案</strong>：  <ul>
<li><strong>日志聚合</strong>：ELK（Elasticsearch+Logstash+Kibana）收集分析日志，关键操作标记TraceID。  </li>
<li><strong>链路追踪</strong>：集成SkyWalking监控接口耗时、数据库查询性能，定位慢调用链。  </li>
<li><strong>健康检查</strong>：Spring Boot Actuator暴露<code>/health</code>端点，配合Prometheus+Grafana监控JVM状态。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="8-多环境部署与配置管理"><a href="#8-多环境部署与配置管理" class="headerlink" title="8. 多环境部署与配置管理"></a><strong>8. 多环境部署与配置管理</strong></h4><ul>
<li><strong>难点</strong>：<br>开发、测试、生产环境配置差异大，手动修改易出错。  </li>
<li><strong>解决方案</strong>：  <ul>
<li><strong>配置中心</strong>：使用Nacos统一管理环境变量，通过<code>spring.profiles.active</code>动态加载配置。  </li>
<li><strong>容器化部署</strong>：Docker+Jenkins Pipeline实现自动化构建，镜像区分环境标签（如<code>dev</code>&#x2F;<code>prod</code>）。  </li>
<li><strong>数据库版本控制</strong>：Liquibase管理SQL脚本变更，确保表结构一致性。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="技术路线：用户下单到商家通知全流程分层实现"><a href="#技术路线：用户下单到商家通知全流程分层实现" class="headerlink" title="技术路线：用户下单到商家通知全流程分层实现"></a>技术路线：用户下单到商家通知全流程分层实现</h3><hr>
<h4 id="1-用户端交互（微信小程序）"><a href="#1-用户端交互（微信小程序）" class="headerlink" title="1. 用户端交互（微信小程序）"></a><strong>1. 用户端交互（微信小程序）</strong></h4><ul>
<li><strong>前端技术栈</strong>：微信小程序原生框架 + WXML&#x2F;WXSS + JavaScript  </li>
<li><strong>流程</strong>：  <ul>
<li>用户登录：调用微信授权接口获取<code>openid</code>，结合后端生成的<strong>JWT令牌</strong>完成身份绑定。  </li>
<li>点餐下单：用户选择菜品后，前端调用后端<code>/order/create</code>接口提交订单数据（菜品ID、数量、地址等）。  </li>
<li>支付流程：对接微信支付API，完成支付后回调后端<code>/order/pay/callback</code>接口更新订单状态为“已支付”。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="2-网关层（Nginx反向代理）"><a href="#2-网关层（Nginx反向代理）" class="headerlink" title="2. 网关层（Nginx反向代理）"></a><strong>2. 网关层（Nginx反向代理）</strong></h4><ul>
<li><strong>功能</strong>：  <ul>
<li>反向代理：将用户请求分发至后端集群，提升接口可用性。  </li>
<li>负载均衡：采用轮询策略分配流量，避免单节点压力过大。  </li>
<li>跨域处理：通过配置<code>Access-Control-Allow-*</code>头部解决前后端跨域问题。  </li>
<li>静态资源托管：部署前端页面及Swagger API文档。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="3-控制层（SpringBoot-RestController）"><a href="#3-控制层（SpringBoot-RestController）" class="headerlink" title="3. 控制层（SpringBoot RestController）"></a><strong>3. 控制层（SpringBoot RestController）</strong></h4><ul>
<li><strong>核心组件</strong>：  <ul>
<li><strong>JWT校验</strong>：通过拦截器对非登录接口（如<code>/order/**</code>）进行令牌合法性验证，解析用户信息并存入<code>ThreadLocal</code>上下文。  </li>
<li><strong>请求处理</strong>：  <ul>
<li>接收小程序端订单创建请求，校验参数合法性（如库存、用户余额）。  </li>
<li>支付回调接口更新订单状态，并触发后续业务逻辑（如通知商家）。</li>
</ul>
</li>
<li><strong>API文档</strong>：集成Swagger3，自动生成RESTful接口文档，供前端和测试团队使用。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="4-业务层（Spring-Service）"><a href="#4-业务层（Spring-Service）" class="headerlink" title="4. 业务层（Spring Service）"></a><strong>4. 业务层（Spring Service）</strong></h4><ul>
<li><p><strong>订单服务（OrderService）</strong>：  </p>
<ul>
<li><strong>事务管理</strong>：使用<code>@Transactional</code>保证订单创建、库存扣减、支付状态更新的原子性。  </li>
<li><strong>缓存优化</strong>：通过<code>SpringCache</code>注解（如<code>@Cacheable</code>）缓存分类菜品数据，减少MySQL查询压力。  </li>
<li><strong>异步处理</strong>：支付成功后，通过<strong>WebSocket</strong>立即推送订单信息至商家端；非核心逻辑（如订单日志记录）使用<code>@Async</code>异步执行。</li>
</ul>
</li>
<li><p><strong>消息推送服务（WebSocketService）</strong>：  </p>
<ul>
<li>建立长连接：商家管理端通过<code>ws://</code>协议与后端建立WebSocket连接，绑定商家ID。  </li>
<li>实时通知：订单支付成功后，调用<code>convertAndSendToUser(商家ID, 订单详情)</code>推送新订单消息。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="5-数据访问层（MyBatis-Mapper-MySQL）"><a href="#5-数据访问层（MyBatis-Mapper-MySQL）" class="headerlink" title="5. 数据访问层（MyBatis Mapper + MySQL）"></a><strong>5. 数据访问层（MyBatis Mapper + MySQL）</strong></h4><ul>
<li><strong>数据库设计</strong>：  <ul>
<li>订单表（<code>order</code>）：存储订单ID、用户ID、金额、状态、时间等。  </li>
<li>订单明细表（<code>order_item</code>）：记录菜品ID、数量、价格。</li>
</ul>
</li>
<li><strong>ORM操作</strong>：  <ul>
<li>使用MyBatis动态SQL实现复杂查询（如关联查询用户历史订单）。  </li>
<li>通过<code>&lt;resultMap&gt;</code>映射实体类，结合<code>PageHelper</code>分页插件优化查询效率。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="6-缓存与高性能优化（Redis）"><a href="#6-缓存与高性能优化（Redis）" class="headerlink" title="6. 缓存与高性能优化（Redis）"></a><strong>6. 缓存与高性能优化（Redis）</strong></h4><ul>
<li><strong>热点数据缓存</strong>：  <ul>
<li>菜品分类信息：缓存至Redis，设置TTL为10分钟，通过<code>SpringCache</code>实现无缝切换。  </li>
<li>订单状态更新：使用Redis分布式锁（<code>Redisson</code>）防止并发场景下的状态覆盖。</li>
</ul>
</li>
<li><strong>防重复提交</strong>：用户提交订单时，基于<code>用户ID+时间戳</code>生成Redis键，防止短时间重复请求。</li>
</ul>
<hr>
<h4 id="7-实时通信与定时任务"><a href="#7-实时通信与定时任务" class="headerlink" title="7. 实时通信与定时任务"></a><strong>7. 实时通信与定时任务</strong></h4><ul>
<li><strong>WebSocket</strong>：  <ul>
<li>使用<code>Spring WebSocket</code>实现服务端推送，商家管理端监听<code>/topic/newOrder</code>频道接收实时订单。  </li>
<li>断线重连：前端通过心跳机制（每30秒发送Ping）维持连接稳定性。</li>
</ul>
</li>
<li><strong>SpringTask定时任务</strong>：  <ul>
<li>订单超时处理：每5分钟扫描状态为“未支付”且创建时间超过30分钟的订单，自动取消并释放库存。  </li>
<li>数据统计：每日凌晨生成商家销售额报表，通过POI导出Excel并邮件发送。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="8-安全与运维"><a href="#8-安全与运维" class="headerlink" title="8. 安全与运维"></a><strong>8. 安全与运维</strong></h4><ul>
<li><strong>安全措施</strong>：  <ul>
<li>敏感数据加密：用户密码通过MD5+盐值加密存储。  </li>
<li>权限控制：基于AOP切面实现<code>@PreAuthorize(&quot;hasRole(&#39;MERCHANT&#39;)&quot;)</code>，拦截越权操作。</li>
</ul>
</li>
<li><strong>运维监控</strong>：  <ul>
<li>日志管理：通过Logback记录接口请求日志，ELK集群实现日志分析与异常告警。  </li>
<li>性能监控：集成Prometheus + Grafana监控JVM内存、接口响应时间等指标。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="全流程时序图（简化版）"><a href="#全流程时序图（简化版）" class="headerlink" title="全流程时序图（简化版）"></a>全流程时序图（简化版）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">用户小程序 -&gt; Nginx -&gt; 控制层 -&gt; 业务层 -&gt; MySQL/Redis  <br>                ↓  <br>           WebSocket -&gt; 商家管理端  <br>                ↓  <br>          SpringTask -&gt; 定时扫描超时订单  <br></code></pre></td></tr></table></figure>

<p><strong>总结</strong>：通过分层架构设计，结合SpringBoot、Redis、WebSocket等技术，实现了从用户下单到商家实时通知的高效链路，同时通过缓存、异步、定时任务等优化手段保障系统性能和稳定性。</p>
<hr>
<h3 id="1-删除用户信息技术路线"><a href="#1-删除用户信息技术路线" class="headerlink" title="1. 删除用户信息技术路线"></a><strong>1. 删除用户信息技术路线</strong></h3><h4 id="1-1-权限校验与安全控制"><a href="#1-1-权限校验与安全控制" class="headerlink" title="1.1 权限校验与安全控制"></a><strong>1.1 权限校验与安全控制</strong></h4><ul>
<li><strong>接口设计</strong>：<code>DELETE /user/&#123;userId&#125;</code>  </li>
<li><strong>权限控制</strong>：  <ul>
<li>使用Spring Security或自定义AOP切面，通过<code>@PreAuthorize(&quot;hasRole(&#39;ADMIN&#39;)&quot;)</code>限制仅管理员可操作。  </li>
<li>请求头携带JWT令牌，拦截器解析后校验用户角色。</li>
</ul>
</li>
<li><strong>防越权</strong>：  <ul>
<li>参数校验：确保路径参数<code>userId</code>与当前用户身份匹配（如普通用户只能删除自己）。</li>
</ul>
</li>
</ul>
<h4 id="1-2-业务逻辑与数据一致性"><a href="#1-2-业务逻辑与数据一致性" class="headerlink" title="1.2 业务逻辑与数据一致性"></a><strong>1.2 业务逻辑与数据一致性</strong></h4><ul>
<li><strong>软删除实现</strong>：  <ul>
<li>数据库表设计：用户表增加<code>is_deleted</code>字段（0-正常，1-已删除）。  </li>
<li>SQL操作：<code>UPDATE user SET is_deleted=1 WHERE id=#&#123;userId&#125;</code>。</li>
</ul>
</li>
<li><strong>关联数据处理</strong>：  <ul>
<li>订单表标记：批量更新用户关联订单的<code>user_status</code>为“已删除”（如<code>UPDATE order SET user_status=&#39;deleted&#39; WHERE user_id=#&#123;userId&#125;</code>）。  </li>
<li>日志异步清理：通过RabbitMQ发送消息，由独立服务异步清理用户日志（避免主业务阻塞）。</li>
</ul>
</li>
</ul>
<h4 id="1-3-缓存与事务管理"><a href="#1-3-缓存与事务管理" class="headerlink" title="1.3 缓存与事务管理"></a><strong>1.3 缓存与事务管理</strong></h4><ul>
<li><strong>缓存清理</strong>：  <ul>
<li>删除用户后，清除Redis中与该用户相关的缓存（如用户信息、历史订单列表）。</li>
</ul>
</li>
<li><strong>事务保证</strong>：  <ul>
<li>使用<code>@Transactional</code>注解，确保用户标记删除与订单状态更新的原子性。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="2-商家端修改菜品信息技术路线"><a href="#2-商家端修改菜品信息技术路线" class="headerlink" title="2. 商家端修改菜品信息技术路线"></a><strong>2. 商家端修改菜品信息技术路线</strong></h3><h4 id="2-1-接口与权限设计"><a href="#2-1-接口与权限设计" class="headerlink" title="2.1 接口与权限设计"></a><strong>2.1 接口与权限设计</strong></h4><ul>
<li><strong>接口设计</strong>：<code>PUT /dish/&#123;dishId&#125;</code>  </li>
<li><strong>权限控制</strong>：  <ul>
<li>AOP切面校验商家身份：从<code>ThreadLocal</code>中获取当前用户角色，仅允许<code>MERCHANT</code>操作。  </li>
<li>数据归属校验：确保修改的菜品属于当前商家（如<code>SELECT merchant_id FROM dish WHERE id=#&#123;dishId&#125;</code>）。</li>
</ul>
</li>
</ul>
<h4 id="2-2-业务逻辑与缓存同步"><a href="#2-2-业务逻辑与缓存同步" class="headerlink" title="2.2 业务逻辑与缓存同步"></a><strong>2.2 业务逻辑与缓存同步</strong></h4><ul>
<li><strong>数据库操作</strong>：  <ul>
<li>更新菜品基本信息：<code>UPDATE dish SET name=#&#123;name&#125;, price=#&#123;price&#125; WHERE id=#&#123;dishId&#125;</code>。  </li>
<li>库存联动更新：若修改库存，需同步更新<code>inventory</code>表（事务保证一致性）。</li>
</ul>
</li>
<li><strong>缓存更新</strong>：  <ul>
<li>使用<code>@CacheEvict</code>注解清除Redis中该菜品的缓存（如<code>key=&quot;dish::#&#123;dishId&#125;&quot;</code>）。  </li>
<li>异步刷新分类缓存：通过消息队列通知其他服务更新分类菜品列表。</li>
</ul>
</li>
</ul>
<h4 id="2-3-日志与版本控制"><a href="#2-3-日志与版本控制" class="headerlink" title="2.3 日志与版本控制"></a><strong>2.3 日志与版本控制</strong></h4><ul>
<li><strong>操作日志</strong>：  <ul>
<li>通过AOP记录修改前后的菜品数据，存储至<code>dish_audit_log</code>表。</li>
</ul>
</li>
<li><strong>乐观锁防并发</strong>：  <ul>
<li>数据库表增加<code>version</code>字段，更新时校验版本号（<code>UPDATE ... WHERE id=#&#123;dishId&#125; AND version=#&#123;oldVersion&#125;</code>）。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="3-修改订单状态技术路线"><a href="#3-修改订单状态技术路线" class="headerlink" title="3. 修改订单状态技术路线"></a><strong>3. 修改订单状态技术路线</strong></h3><h4 id="3-1-状态机设计与接口规范"><a href="#3-1-状态机设计与接口规范" class="headerlink" title="3.1 状态机设计与接口规范"></a><strong>3.1 状态机设计与接口规范</strong></h4><ul>
<li><strong>接口设计</strong>：<code>PATCH /order/&#123;orderId&#125;/status</code>  </li>
<li><strong>状态流转规则</strong>：  <ul>
<li>定义合法状态变更（如“未支付”→“已支付”→“已完成”或“已取消”）。  </li>
<li>使用状态模式（如<code>OrderState</code>接口+具体状态类）封装校验逻辑。</li>
</ul>
</li>
</ul>
<h4 id="3-2-业务逻辑与消息通知"><a href="#3-2-业务逻辑与消息通知" class="headerlink" title="3.2 业务逻辑与消息通知"></a><strong>3.2 业务逻辑与消息通知</strong></h4><ul>
<li><strong>核心流程</strong>：  <ol>
<li>校验当前状态是否允许修改（如已完成的订单不可再变更）。  </li>
<li>更新订单状态：<code>UPDATE order SET status=#&#123;newStatus&#125; WHERE id=#&#123;orderId&#125;</code>。  </li>
<li>触发关联操作：  <ul>
<li>若状态变更为“已取消”，调用库存服务回滚库存（通过Feign调用）。  </li>
<li>若状态变更为“已完成”，发送MQ消息通知用户（短信&#x2F;小程序模板消息）。</li>
</ul>
</li>
</ol>
</li>
<li><strong>分布式事务</strong>：  <ul>
<li>使用Seata AT模式，保证订单状态更新与库存回滚的事务性。</li>
</ul>
</li>
</ul>
<h4 id="3-3-并发控制与幂等性"><a href="#3-3-并发控制与幂等性" class="headerlink" title="3.3 并发控制与幂等性"></a><strong>3.3 并发控制与幂等性</strong></h4><ul>
<li><strong>分布式锁</strong>：  <ul>
<li>使用Redis锁（<code>Redisson</code>）防止同时修改同一订单（锁键：<code>order:update:$&#123;orderId&#125;</code>）。</li>
</ul>
</li>
<li><strong>幂等设计</strong>：  <ul>
<li>请求参数增加唯一请求ID，数据库记录已处理请求，避免重复提交。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="技术路线对比与总结"><a href="#技术路线对比与总结" class="headerlink" title="技术路线对比与总结"></a><strong>技术路线对比与总结</strong></h3><table>
<thead>
<tr>
<th><strong>操作类型</strong></th>
<th><strong>技术共性</strong></th>
<th><strong>特殊处理</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>删除用户</strong></td>
<td>JWT鉴权、AOP权限控制、事务管理</td>
<td>软删除设计、关联数据异步清理</td>
</tr>
<tr>
<td><strong>修改菜品</strong></td>
<td>缓存更新、乐观锁、操作日志</td>
<td>分类缓存联动刷新、库存事务联动</td>
</tr>
<tr>
<td><strong>修改订单状态</strong></td>
<td>状态机、分布式事务、消息通知</td>
<td>分布式锁防并发、幂等性设计</td>
</tr>
</tbody></table>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>校园闪送项目笔记</div>
      <div>http://example.com/2025/03/06/校园闪送项目笔记/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>presbyter</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2025年3月6日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2025/03/09/%E5%A4%A9%E5%A4%A9%E5%95%86%E5%9F%8E%E9%9A%8F%E8%AE%B0/" title="天天商城随记">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">天天商城随记</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2025/02/23/%E5%BE%AE%E6%9C%8D%E5%8A%A1/" title="微服务">
                        <span class="hidden-mobile">微服务</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
